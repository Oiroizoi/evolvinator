<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
    <meta charset="utf-8">
    <title>Evolvinator</title>

    <link rel="preload" href="fonts/PfefferMediaeval.otf" as="font" type="font/otf" crossorigin>
    <link rel="preload" href="fonts/PfefferSimpelgotisch normal.otf" as="font" type="font/otf" crossorigin>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400..900&family=EB+Garamond:ital,wght@0,400..800;1,400..800"
        rel="stylesheet">

    <style>
        @font-face {
            font-family: "Pfeffer Mediæval";
            src: local("Pfeffer Mediæval"),
                url("fonts/PfefferMediaeval.otf") format("opentype");
            unicode-range: U+0100-02BA, U+02BD-02C5, U+02C7-02CC, U+02CE-02D7, U+02DD-02FF, U+0304, U+0308, U+0329, U+1D00-1DBF, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF;
        }

        @font-face {
            font-family: "Pfeffer Mediæval";
            src: local("Pfeffer Mediæval"),
                url("fonts/PfefferMediaeval.otf") format("opentype");
            unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
        }

        @font-face {
            font-family: "Pfeffer Simpelgotisch";
            src: local("Pfeffer Simpelgotisch"),
                url("fonts/PfefferSimpelgotisch normal.otf") format("opentype");
        }

        @font-face {
            font-family: "Rustic Capitals";
            src: local("Rustic Capitals"),
                url("fonts/RusticCapitals.ttf") format("truetype");
        }

        body {
            font: 16px "Segoe UI", sans-serif;
            line-height: 150%;
        }

        form {
            line-height: 200%;
        }

        label {
            display: inline-block;
        }

        input[type=button] {
            margin-left: 4px;
        }

        #table {
            margin-top: 20px;
            text-align: center;
            border-spacing: 0;
        }

        th {
            position: relative;
            padding: 5px 0;
            background-color: lightgray;
            border-color: black;
            cursor: pointer;
        }

        #headerArrow {
            position: absolute;
            top: 0;
            right: 0;
            height: 100%;
            aspect-ratio: 1;
            padding: 5px 0;
        }

        td {
            padding: 15px 12px 0 12px;
        }

        #outcomes:not(.expanded) .hidden td {
            display: none;
        }

        .spelling {
            font-style: italic;
        }

        #outcomes:not(.modernTypography) {
            #lat .spelling {
                font-family: "Cinzel";
                font-style: normal;
            }

            #LL .spelling {
                font-family: "Rustic Capitals";
                font-size: 14px;
                transform: translateY(2px);
                font-style: normal;
            }

            #OE .spelling {
                font-family: "Pfeffer Mediæval";
                font-feature-settings: "ss02";
                font-size: 18px;
                font-style: normal;
            }

            #EME .spelling,
            #OSp .spelling,
            #EOF .spelling,
            #LOF .spelling {
                font-family: "Pfeffer Mediæval";
                font-feature-settings: "hist";
                font-size: 18px;
                font-style: normal;
            }

            #LME .spelling,
            #OGP .spelling {
                font-family: "Pfeffer Simpelgotisch";
                font-feature-settings: "hist";
                font-size: 18px;
                font-style: normal;
            }

            #EModE .spelling,
            #EModSp .spelling,
            #MF .spelling {
                font-family: "EB Garamond";
                font-size: 18px;
                font-style: normal;
            }
        }

        .nonHist {
            font-feature-settings: initial !important;
        }

        #checkboxes {
            margin-top: 30px;
            font-size: 13px;
        }

        input[type="checkbox"] {
            vertical-align: text-top;
        }

        #checkboxes label {
            margin-right: 10px;
        }
    </style>
</head>

<body>
    <form autocomplete="off">
        <select name="from" id="from">
            <option value="OE">Old English</option>
            <option value="lat">Classical Latin</option>
        </select>
        →
        <select name="to" id="to">
            <option value="ModE">Modern English</option>
        </select>
        <br>

        <label for="word" id="wordLabel">Word:</label>
        <input type="text" name="word" id="word">
        <span id="buttons"></span>
        <br>

        <label for="stress" id="stressLabel">Stressed syllable:</label>
        <select name="stress" id="stress" style="margin-right: 8px;">
            <option>1</option>
        </select>

        <label for="pos" id="posLabel">Part of speech:</label>
        <select name="pos" id="pos"></select>
        <br>

        <input type="submit">
    </form>

    <div id="outcomes">
        <table id="table">
            <tr id="header"></tr>
        </table>
        <div id="checkboxes"></div>
    </div>
</body>

<script>
    let params = new URLSearchParams(window.location.search);
    let wordArg = params.get("word");
    let from = params.get("from") || "OE";
    let to = params.get("to") || "ModE";
    let stressArg = +params.get("stress") || 1;
    let word;
    let modernTypography = false;
    let partOfSpeech = params.get("pos");

    let outcomes = {};

    function init() {
        if (wordArg) {
            wordArg = wordArg.trim().toLowerCase();
            if (from == "OE") {
                wordArg = wordArg.replaceAll("ð", "þ").replaceAll("ƿ", "w").replaceAll("k", "c"); //Alternative spellings
                wordArg = wordArg.replaceAll("io", "eo").replaceAll("īo", "ēo")
                    .replaceAll("oe", "e").replaceAll("ōe", "ē").replaceAll("œ", "e").replaceAll("œ̄", "ē"); //Dialectalal vowels
            } else if (from == "lat") {
                wordArg = wordArg.replaceAll("k", "c").replaceAll("j", "i").replace(/^w/, "gu");
                wordArg = wordArg.replaceAll(/(?<=[eiouyāēīōūȳ])u(?=[aeiouyāēīōūȳ])/g, "v");
            }

            params.set("word", wordArg);
            window.history.replaceState({}, "", "?" + params);

            if (!document.getElementById("word").value)
                document.getElementById("word").value = wordArg;
        }

        document.getElementById("word").oninput();

        document.getElementById("to").innerHTML = "";
        if (from == "OE") {
            let ModE = document.createElement("option");
            ModE.value = "ModE";
            ModE.innerHTML = "Modern English";
            document.getElementById("to").append(ModE);

            let scots = document.createElement("option");
            scots.value = "scots";
            scots.innerHTML = "Modern Scots";
            document.getElementById("to").append(scots);

            if (to != "scots")
                to = "ModE";
        } else if (from == "lat") {
            let ModF = document.createElement("option");
            ModF.value = "ModF";
            ModF.innerHTML = "Modern French";
            document.getElementById("to").append(ModF);

            let ModPort = document.createElement("option");
            ModPort.value = "ModPort";
            ModPort.innerHTML = "Modern Portuguese";
            document.getElementById("to").append(ModPort);

            let ModSp = document.createElement("option");
            ModSp.value = "ModSp";
            ModSp.innerHTML = "Modern Spanish";
            document.getElementById("to").append(ModSp);

            if (to != "ModF" && to != "ModPort")
                to = "ModSp";
        }

        document.getElementById("from").value = from;
        document.getElementById("to").value = to;

        if (from == "OE")
            document.getElementById("word").placeholder = "Enter Old English word";
        else if (from == "lat")
            document.getElementById("word").placeholder = "Enter Classical Latin word";

        let specialChars;
        if (from == "OE")
            specialChars = ["ċ", "ġ", "þ", "æ", "ā", "ē", "ī", "ō", "ū", "ȳ", "ǣ"];
        else if (from == "lat")
            specialChars = ["ā", "ē", "ī", "ō", "ū", "ȳ"];
        document.getElementById("buttons").innerHTML = "";
        specialChars.forEach(char => {
            let button = document.createElement("input");
            button.value = char;
            button.type = "button";
            button.onclick = () => {
                let wordInput = document.getElementById("word");
                wordInput.setRangeText(char, wordInput.selectionStart, wordInput.selectionEnd, "end");
                wordInput.oninput();
                wordInput.focus();
            };
            document.getElementById("buttons").append(button);
        });

        if (from == "OE") {
            document.getElementById("stressLabel").style.display = "";
            document.getElementById("stress").style.display = "";
            document.getElementById("stress").value = stressArg;
        } else {
            document.getElementById("stressLabel").style.display = "none";
            document.getElementById("stress").style.display = "none";
        }

        if (from == "OE") {
            document.getElementById("pos").innerHTML = `
                <option value="inf">Infinitive verb</option>
                <option value="conjVerb">Conjugated verb</option>
                <option value="pastPtcp">Past participle</option>
                <option value="other" selected>Other</option>
            `;
        } else if (from == "lat") {
            document.getElementById("pos").innerHTML = `
                <option value="inf">Infinitive verb</option>
                <option value="conjVerb">Conjugated verb</option>
                <option value="other" selected>Other</option>
            `;
        }

        if (Array.from(document.getElementById("pos").options).some(option => option.value == partOfSpeech))
            document.getElementById("pos").value = partOfSpeech;

        document.getElementById("outcomes").style.display = "none";

        document.getElementById("header").onclick = () => {
            document.getElementById("outcomes").classList.toggle("expanded");
            if (document.getElementById("headerArrow").innerHTML == "▲")
                document.getElementById("headerArrow").innerHTML = "▼";
            else
                document.getElementById("headerArrow").innerHTML = "▲";
        };

        if (!document.getElementById("word").value)
            document.getElementById("word").focus();
    }

    document.getElementById("from").onchange = () => {
        from = document.getElementById("from").value;
        init();
    };

    function tableSetup() {
        document.getElementById("header").innerHTML = `<th colspan="4"> Expected outcomes: <div id="headerArrow">▼</div> </th>`;

        document.getElementById("checkboxes").innerHTML = `
            <label><input type="checkbox" id="expandChk">Automatically expand table</label>
            <label><input type="checkbox" id="modernChk">Use modern typography</label>
        `;

        document.getElementById("expandChk").onclick = function () {
            localStorage.setItem("ev-autoExpand", this.checked);
            if (this.checked && document.getElementById("headerArrow").innerHTML == "▼")
                document.getElementById("header").click();
        };

        document.getElementById("modernChk").onclick = function () {
            localStorage.setItem("ev-modernTypography", this.checked);
            document.getElementById("outcomes").classList.toggle("modernTypography");
            modernTypography = this.checked;
            getOutcomes();
        };

        if (localStorage.getItem("ev-autoExpand") == "true") {
            document.getElementById("expandChk").checked = true;
            document.getElementById("header").click();
        }

        if (localStorage.getItem("ev-modernTypography") == "true") {
            document.getElementById("modernChk").checked = true;
            document.getElementById("outcomes").classList.toggle("modernTypography");
            modernTypography = true;
        }
    }

    function addRow(id, name, date, spelling, word, hidden) {
        document.getElementById(id)?.remove();

        let row = document.createElement("tr");
        row.id = id;
        row.innerHTML = `<td>${name}</td> <td>c. ${date}</td> <td class="spelling">${spelling}</td> <td>[${word}]</td>`;
        if (hidden)
            row.classList.add("hidden");
        document.getElementById("table").append(row);

        word.forEach(segment => segment[id + "Value"] = segment.value);
        outcomes[id] = word.duplicate();
    }

    function getOutcomes() {
        word = new Word();
        word.partOfSpeech = partOfSpeech;

        try {
            if (from == "OE" && to == "ModE") {
                getIPA_OE();
                OE_to_EME();
                EME_to_LME();
                LME_to_EModE();
                EModE_to_ModE();
                ModE_to_UK();
                ModE_to_US();
                UK_to_AU();
            } else if (from == "OE" && to == "scots") {
                getIPA_OE();
                OE_to_EME("northumbrian");
                EME_to_LME("scots");
                LME_to_EModE("scots");
                EModE_to_ModE("scots");
                ModE_to_ModSc();
            } else if (from == "lat" && to == "ModSp") {
                getIPA_lat();
                lat_to_LL();
                LL_to_WR("spanish");
                WR_to_IR();
                IR_to_OSp();
                OSp_to_ModSp();
            } else if (from == "lat" && to == "ModF") {
                getIPA_lat();
                lat_to_LL();
                LL_to_WR("french");
                WR_to_EOF();
                EOF_to_LOF();
                LOF_to_MF();
                MF_to_ModF();
            } else if (from == "lat" && to == "ModPort") {
                getIPA_lat();
                lat_to_LL();
                LL_to_WR("portuguese");
                WR_to_IR();
                IR_to_OGP();
                OGP_to_ModPort();
                ModPort_to_Port();
                ModPort_to_Br();
            }

            document.getElementById("outcomes").style.display = "block";
        } catch (err) {
            console.error(err);
            alert("Error: invalid word");
        }
    }

    document.getElementById("wordLabel").onclick = () => document.getElementById("word").select();

    document.getElementById("word").onmousedown = function () {
        if (this == document.activeElement)
            this.onclick = null;
        else {
            this.onclick = () => {
                if (!window.getSelection().toString())
                    this.select();
            };
        }
    };
    document.getElementById("word").ontouchstart = document.getElementById("word").onmousedown;

    document.getElementById("word").oninput = function () {
        if (from == "OE") {
            let vowels = ["a", "ā", "e", "ē", "i", "ī", "o", "ō", "u", "ū", "y", "ȳ", "æ", "ǣ",
                "ea", "ēa", "eo", "ēo", "ie", "īe", "io", "īo", "oe", "ōe", "œ", "œ̄"];
            let numVowels = 0;
            for (let i = 0; i < this.value.length; i++) {
                if (vowels.includes(this.value[i] + this.value[i + 1])) {
                    numVowels++;
                    i++;
                }
                else if (vowels.includes(this.value[i]))
                    numVowels++;
            }
            let stressValue = document.getElementById("stress").value;
            document.getElementById("stress").innerHTML = "";
            for (let i = 0; i < Math.max(numVowels, 1); i++) {
                let option = document.createElement("option");
                option.innerHTML = i + 1;
                if (i == stressValue - 1)
                    option.selected = true;
                document.getElementById("stress").append(option);
            }
        }
    };

    class Word extends Array {
        constructor() {
            super();

            this.insert = (value, i) => this.splice(i, 0, new Segment(value, this));

            function segmentMatch(segment, chkValues) {
                chkValues = chkValues.split("/");
                let valueIncluded = false;
                if (chkValues.includes(segment.value))
                    valueIncluded = true;
                if (chkValues.includes("C") && segment.type == "consonant")
                    valueIncluded = true;
                if (chkValues.includes("V") && segment.type == "vowel")
                    valueIncluded = true;
                if (chkValues.includes("#") && !segment.value)
                    valueIncluded = true;
                return valueIncluded;
            }

            this.replace = (original, replacement, context = "") => {
                let ctxBefore = context.split("_")[0]?.split(",").filter(segment => segment);
                let ctxAfter = context.split("_")[1]?.split(",").filter(segment => segment) || [];
                ctxBefore.reverse();
                for (let i = 0; i < this.length; i++) {
                    let segment = this[i];
                    if (
                        segment.value == original
                        && ctxBefore.every((chkValues, j) => segmentMatch(segment.relIdx(-1 - j), chkValues))
                        && ctxAfter.every((chkValues, j) => segmentMatch(segment.relIdx(1 + j), chkValues))
                    )
                        segment.value = replacement;
                }
            };

            this.remove = (original, context = "") => {
                let ctxBefore = context.split("_")[0]?.split(",").filter(segment => segment);
                let ctxAfter = context.split("_")[1]?.split(",").filter(segment => segment) || [];
                ctxBefore.reverse();
                for (let i = 0; i < this.length; i++) {
                    let segment = this[i];
                    if (
                        segment.value == original
                        && ctxBefore.every((chkValues, j) => segmentMatch(segment.relIdx(-1 - j), chkValues))
                        && ctxAfter.every((chkValues, j) => segmentMatch(segment.relIdx(1 + j), chkValues))
                    ) {
                        segment.remove();
                        i--;
                    }
                }
            };

            this.replaceSeq = (str, replacement) => {
                let sequence = str.split(",");
                for (let i = 0; i < this.length; i++) {
                    let segment = this[i];
                    if (sequence.every((seqSegment, j) => segment.relIdx(j).value == seqSegment)) {
                        let newSegments = replacement.split(",").map(segment => new Segment(segment, this));
                        newSegments.forEach((newSegment, j) => {
                            if (newSegments.length > j) {
                                for (let key in segment.relIdx(j))
                                    if (!newSegment[key])
                                        newSegment[key] = segment.relIdx(j)[key];
                                newSegment.stressed = segment.relIdx(j).stressed;
                            }
                        });
                        this.splice(segment.i, sequence.length, ...newSegments);
                    }
                }
            };

            this.duplicate = () => {
                let newWord = new Word();
                this.forEach((segment, i) => {
                    let newSegment = new Segment(segment.value, newWord);
                    for (let key in segment)
                        if (!newSegment[key])
                            newSegment[key] = segment[key];
                    newSegment.stressed = segment.stressed;
                    newSegment.type = segment.type;
                    newWord.push(newSegment);
                });
                for (let key in this)
                    if (!newWord[key])
                        newWord[key] = this[key];
                return newWord;
            };

            this.toString = () => this.join("");
        };

        get vowels() {
            return this.filter(segment => segment.type == "vowel");
        }

        get stressedVowel() {
            return this.vowels.find(vowel => vowel.stressed);
        }
    }

    class Segment {
        constructor(value, word) {
            this.value = value;
            this.stressed = false;
            this.word = word;

            this.match = (...vals) => vals.includes(this.value);
            this.relIdx = diff => this.word[this.i + diff] || new Segment("", this.word);
            this.nextVowel = () => this.word.slice(this.i + 1).find(s => s.type == "vowel") || new Segment("", this.word);
            this.prevVowel = () => this.word.slice(0, this.i).reverse().find(s => s.type == "vowel") || new Segment("", this.word);
            this.remove = () => this.word.splice(this.i, 1);
            this.toString = () => {
                let str = "";
                for (let char of this.value) {
                    str += char;
                    if (this.nasalized && char != "̯")
                        str += "̃";
                }
                if (this.stressed && !this.relIdx(-1).stressed)
                    str = "ˈ" + str;
                return str;
            };

            if (this.value && ["a", "e", "i", "o", "u", "ɑ", "y", "æ", "ə", "ɛ", "ɪ", "ɔ", "ʊ", "ʏ"].includes(this.value[0]))
                this.type = "vowel";
            else if (this.value)
                this.type = "consonant";
        }

        get i() {
            return this.word.indexOf(this);
        }
    }

    init();
    if (wordArg) {
        tableSetup();
        getOutcomes();
    }

    function getIPA_OE() {
        let charToPhoneme = [
            ["a", "ɑ"],
            ["ā", "ɑː"],
            ["b", "b"],
            ["c", "k"],
            ["ċ", "t͡ʃ"],
            ["ċċ", "t,t͡ʃ"],
            ["cg", "ɣ,ɣ"],
            ["ċġ", "j,j"],
            ["d", "d"],
            ["e", "e"],
            ["ē", "eː"],
            ["ea", "æɑ̯"],
            ["ēa", "æːɑ̯"],
            ["eo", "eo̯"],
            ["ēo", "eːo̯"],
            ["f", "f"],
            ["g", "ɣ"],
            ["ġ", "j"],
            ["h", "h"],
            ["i", "i"],
            ["ī", "iː"],
            ["ie", "iy̯"],
            ["īe", "iːy̯"],
            ["l", "l"],
            ["m", "m"],
            ["n", "n"],
            ["o", "o"],
            ["ō", "oː"],
            ["p", "p"],
            ["r", "r"],
            ["s", "s"],
            ["sċ", "ʃ,ʃ"],
            ["t", "t"],
            ["u", "u"],
            ["ū", "uː"],
            ["w", "w"],
            ["x", "k,s"],
            ["y", "y"],
            ["ȳ", "yː"],
            ["þ", "θ"],
            ["æ", "æ"],
            ["ǣ", "æː"],
        ];

        for (let i = 0; i < wordArg.length; i++) {
            let phonemes;
            let digraphPair = charToPhoneme.find(pair => pair[0] == wordArg[i] + wordArg[i + 1]);
            if (digraphPair) {
                phonemes = digraphPair[1];
                i++;
            } else {
                phonemes = charToPhoneme.find(pair => pair[0] == wordArg[i])[1];
            }
            phonemes.split(",").forEach(phoneme => word.insert(phoneme, word.length));
        }

        let stressedVowel = word.vowels[stressArg - 1];
        stressedVowel.stressed = true;
        let onsetClusters = ["bl", "br", "dr", "dw", "fl", "fn", "fr", "ɣl", "ɣn", "ɣr", "hl", "hn", "hr", "hw", "kl", "kn", "kr", "kw", "pl", "pr",
            "sk", "skr", "ʃr", "sl", "sm", "sn", "sp", "spl", "spr", "st", "str", "sw", "tr", "tw", "wl", "wr", "θr", "θw"];
        if (stressedVowel.relIdx(-1).type == "consonant")
            stressedVowel.relIdx(-1).stressed = true;
        if (onsetClusters.includes(stressedVowel.relIdx(-2).value + stressedVowel.relIdx(-1).value))
            stressedVowel.relIdx(-2).stressed = true;
        if (onsetClusters.includes(stressedVowel.relIdx(-3).value + stressedVowel.relIdx(-2).value + stressedVowel.relIdx(-1).value))
            stressedVowel.relIdx(-3).stressed = true;
        if (stressedVowel.relIdx(1).type == "consonant" && stressedVowel.relIdx(2).type != "vowel")
            stressedVowel.relIdx(1).stressed = true;
        word.forEach(segment => {
            if (word.vowels[0].stressed && segment.i < word.vowels[0].i)
                segment.stressed = true;
        });

        //Allophones
        word.replace("ɣ", "g", "n/#_");
        word.replaceSeq("ɣ,ɣ", "g,g");
        word.forEach(segment => {
            if (segment.value == "ɣ" && segment.stressed && segment.i < stressedVowel.i)
                segment.value = "g";
        });
        word.replace("n", "ŋ", "_k/g");
        word.replace("l", "ɫ", "_C");
        word.replace("l", "ɫ", "ɫ_");
        word.replace("r", "rˠ", "_C");
        word.replace("r", "rˠ", "rˠ_");
        word.replaceSeq("h,l", "l̥");
        word.replaceSeq("h,n", "n̥");
        word.replaceSeq("h,r", "r̥");
        word.replaceSeq("h,w", "xʷ");
        word.replace("h", "x", "ɑ/ɑː/o/oː/u/uː/æɑ̯/æːɑ̯/eo̯/eːo̯/x_");
        word.replace("h", "x", "ɫ/rˠ_C/#");
        word.replace("h", "ç", "æ/æː/e/eː/i/iː/y/yː/iy̯/iːy̯/ç_");
        word.forEach(segment => {
            if (segment.match("x", "ç") && segment.relIdx(1) == stressedVowel)
                segment.value = "h";
        });
        word.replaceSeq("j,j", "d,d͡ʒ");
        word.forEach(segment => {
            if (segment.value == "j" && segment.relIdx(-1).value == "n" && segment.i > stressedVowel.i)
                segment.value = "d͡ʒ";
        });
        word.forEach(segment => {
            let voicedConsonants = ["b", "d", "ɣ", "j", "l", "ɫ", "m", "n", "r", "rˠ", "w"];
            if (
                (segment.relIdx(-1).stressed && (segment.relIdx(-1).type == "vowel" || segment.relIdx(-1).match(...voicedConsonants))
                    && (segment.relIdx(1).type == "vowel" || segment.relIdx(1).match(...voicedConsonants)))
                || (segment.relIdx(1).match(...voicedConsonants) && segment.relIdx(-1).type == "vowel" && !segment.stressed)
            ) {
                switch (segment.value) {
                    case "f":
                        segment.value = "v";
                        break;
                    case "θ":
                        segment.value = "ð";
                        break;
                    case "s":
                        segment.value = "z";
                        break;
                }
            }
        });
        word.forEach(segment => {
            if (segment.value == "ɑ" && segment.stressed && segment.relIdx(1).match("m", "n", "ŋ"))
                segment.value = "ɒ";
        });
        word.forEach(segment => {
            if (
                segment.type == "consonant" && segment.relIdx(1).value
                && (segment.value == segment.relIdx(1).value[0] || (segment.match("r", "rˠ") && segment.relIdx(1).match("r", "rˠ")))
                && (segment.relIdx(-1).type != "vowel" || segment.relIdx(2).type != "vowel")
                && !onsetClusters.includes(segment.relIdx(1).value + segment.relIdx(2).value)
            )
                segment.remove();
        });
        word.forEach(segment => {
            if (segment.value == "ʃ" && segment.relIdx(1).value == "ʃ" && (segment.relIdx(-1).type != "vowel" || segment.relIdx(2).type != "vowel"))
                segment.remove();
        });
        if (stressedVowel.relIdx(-1).value == "ʃ" && stressedVowel.relIdx(-2).value == "ʃ")
            stressedVowel.relIdx(-2).remove();

        addRow("OE", "Late Old English", "900", getSpelling_OE(), word);
    }

    function getIPA_lat() {
        let charToPhoneme = [
            ["a", "a"],
            ["ā", "aː"],
            ["ae", "ae̯"],
            ["au", "au̯"],
            ["b", "b"],
            ["c", "k"],
            ["ch", "kʰ"],
            ["d", "d"],
            ["e", "ɛ"],
            ["ē", "eː"],
            ["f", "f"],
            ["g", "g"],
            ["h", "h"],
            ["i", "ɪ"],
            ["ī", "iː"],
            ["l", "l"],
            ["m", "m"],
            ["n", "n"],
            ["o", "ɔ"],
            ["ō", "oː"],
            ["oe", "oe̯"],
            ["p", "p"],
            ["ph", "pʰ"],
            ["qu", "kʷ"],
            ["r", "r"],
            ["rh", "r̥"],
            ["s", "s"],
            ["t", "t"],
            ["th", "tʰ"],
            ["u", "ʊ"],
            ["ū", "uː"],
            ["v", "w"],
            ["x", "k,s"],
            ["y", "ʏ"],
            ["ȳ", "yː"],
            ["z", "z"],
        ];

        for (let i = 0; i < wordArg.length; i++) {
            let phonemes;
            let digraphPair = charToPhoneme.find(pair => pair[0] == wordArg[i] + wordArg[i + 1]);
            if (digraphPair) {
                phonemes = digraphPair[1];
                i++;
            } else {
                phonemes = charToPhoneme.find(pair => pair[0] == wordArg[i])[1];
            }
            phonemes.split(",").forEach(phoneme => word.insert(phoneme, word.length));
        }

        word.forEach(segment => {
            if (segment.value == "g" && segment.relIdx(1).value == "ʊ" && segment.relIdx(2).type == "vowel") {
                segment.value = "gʷ";
                segment.relIdx(1).remove();
            }

            if (segment.value == "ɪ" && segment.relIdx(1).type == "vowel" && segment.i == 0) {
                segment.value = "j";
                segment.type = "consonant";
            }

            if (segment.value == "ɪ" && segment.relIdx(-1).type == "vowel" && segment.relIdx(1).type == "vowel") {
                segment.value = "j";
                segment.type = "consonant";
                word.insert("j", segment.i);
            }
        });
        word.replace("ɛ", "e", "_V");
        word.replace("ɪ", "i", "_V");
        word.replace("ɔ", "o", "_V");
        word.replace("ʊ", "u", "_V");

        word.remove("g", "#_n");

        word.remove("h", "C_");
        word.replace("h", "ɦ", "V_V");

        word.replace("kʷ", "k", "_ʊ/u/uː");
        word.replace("gʷ", "g", "_ʊ/u/uː");

        word.forEach(segment => {
            if (segment.value == "z" && segment.relIdx(-1).type == "vowel" && segment.relIdx(1).type == "vowel")
                word.insert("z", segment.i);
        });

        let stressedVowel;
        if (word.at(-1).value == "k")
            stressedVowel = word.vowels.at(-1);
        else if (word.vowels.length < 3)
            stressedVowel = word.vowels[0];
        else if (
            word.vowels.at(-2).value.length > 1
            || (word.vowels.at(-2).relIdx(1).type == "consonant" && word.vowels.at(-2).relIdx(2).type == "consonant"
                && !(word.vowels.at(-2).relIdx(1).match("p", "t", "k", "b", "d", "g", "pʰ", "tʰ", "kʰ", "f") && word.vowels.at(-2).relIdx(2).match("l", "r")))
        )
            stressedVowel = word.vowels.at(-2);
        else
            stressedVowel = word.vowels.at(-3);
        stressedVowel.stressed = true;
        if (stressedVowel.relIdx(-1).type == "consonant")
            stressedVowel.relIdx(-1).stressed = true;
        if (stressedVowel.relIdx(-2).match("p", "t", "k", "b", "d", "g", "pʰ", "tʰ", "kʰ", "f") && stressedVowel.relIdx(-1).match("l", "r"))
            stressedVowel.relIdx(-2).stressed = true;
        if (stressedVowel.relIdx(-2).value == "s" && stressedVowel.relIdx(-1).match("p", "t", "k", "pʰ", "tʰ", "kʰ")
            && stressedVowel.relIdx(-3).type == "consonant")
            stressedVowel.relIdx(-2).stressed = true;
        if (stressedVowel.relIdx(-3).value == "s" && stressedVowel.relIdx(-2).match("p", "t", "k", "pʰ", "tʰ", "kʰ")
            && stressedVowel.relIdx(-1).match("l", "r") && stressedVowel.relIdx(-3).type == "consonant")
            stressedVowel.relIdx(-3).stressed = true;
        word.forEach(segment => {
            if (word.vowels[0].stressed && segment.i < word.vowels[0].i)
                segment.stressed = true;
        });

        //Allophones
        word.replace("l", "ɫ");
        word.replace("ɫ", "l", "_ɪ/i/iː");
        word.replace("ɫ", "l", "ɫ_");
        word.replace("ɫ", "l", "_l");
        word.replace("n", "ŋ", "_k/g/kʷ/gʷ/kʰ");
        word.replace("g", "ŋ", "_n");
        word.replace("b", "p", "_p/t/k/pʰ/tʰ/kʰ/f/s");
        word.replace("d", "t", "_p/t/k/pʰ/tʰ/kʰ/f/s");
        word.replace("r", "r̥", "_r̥");

        word.forEach(segment => {
            if (segment.relIdx(1).match("m", "n") && segment.relIdx(2).match("f", "s")) {
                switch (segment.value) {
                    case "a":
                        segment.value = "aː";
                        break;
                    case "ɛ":
                        segment.value = "eː";
                        break;
                    case "ɪ":
                        segment.value = "iː";
                        break;
                    case "ɔ":
                        segment.value = "oː";
                        break;
                    case "ʊ":
                        segment.value = "uː";
                        break;
                    case "ʏ":
                        segment.value = "yː";
                        break;
                }
                segment.value = segment.value.slice(0, 1) + "̃" + segment.value.slice(1);
                segment.relIdx(1).remove();
            }
        });
        if (word.at(-1).value == "m" && word.at(-2).type == "vowel" && !word.at(-2).stressed) {
            word.at(-2).value = word.at(-2).value.slice(0, 1) + "̃" + word.at(-2).value.slice(1);
            word.at(-1).remove();
        }

        addRow("lat", "Classical Latin", "AD 50", getSpelling_lat(), word);
    }

    function OE_to_EME(variety) {
        word = outcomes.OE.duplicate();

        word.replace("θ", "s", "_s");
        word.forEach(segment => {
            if (segment.type == "consonant" && segment.value == segment.relIdx(1).value && (segment.relIdx(-1).type != "vowel" || segment.relIdx(2).type != "vowel"))
                segment.remove();
        });

        word.replace("ɣ", "x", "_p/t/k/t͡ʃ/f/θ/s/ʃ/#");

        word.replace("x", "k", "_s");
        word.replace("ç", "k", "_s");

        word.forEach(segment => {
            if (segment.value == "n" && segment.relIdx(1).value == "d" && !segment.relIdx(1).stressed && segment.relIdx(2).stressed) {
                segment.relIdx(1).remove();
                if (segment.relIdx(-1).value == "ɑ")
                    segment.relIdx(-1).value = "o";
            }
        });

        //Anglian smoothing (occurred in Old English, but became standard later)
        word.replace("æɑ̯", "æ", "_k/x/ɣ");
        word.replace("æɑ̯", "e", "_ɫ/rˠ,k/x/ɣ");
        word.replace("æːɑ̯", "eː", "_k/x/ɣ");
        word.replace("æːɑ̯", "eː", "_ɫ/rˠ,k/x/ɣ");
        word.replace("eo̯", "e", "_k/x/ɣ");
        word.replace("eo̯", "e", "_ɫ/rˠ,k/x/ɣ");
        word.replace("eːo̯", "eː", "_k/x/ɣ");
        word.replace("eːo̯", "eː", "_ɫ/rˠ,k/x/ɣ");
        word.replace("x", "ç", "æ/e/eː/i/iː_");

        word.replace("d", "t", "_θ/s");

        word.forEach(segment => {
            if (segment.value == "h" && segment.relIdx(-1).type == "consonant" && !segment.stressed) {
                segment.remove();
            }
        });

        word.forEach(segment => {
            if (segment.type == "vowel" && segment.i > word.stressedVowel.i) {
                switch (word.partOfSpeech) {
                    case "conjVerb":
                        if (segment.relIdx(1).value == "θ")
                            segment.inSuffix = true;
                    case "pastPtcp":
                        if (segment.relIdx(1).value == "d")
                            segment.inSuffix = true;
                    case "inf":
                        if (segment.relIdx(1).value == "n" && segment == word.at(-2))
                            segment.inSuffix = true;
                    default:
                        if (segment.relIdx(1).value == "s" && segment == word.at(-2))
                            segment.inSuffix = true;
                }
            }
        });

        word.replace("iy̯", "y");
        word.replace("iːy̯", "yː");

        word.replace("l̥", "l");
        word.replace("n̥", "n");
        word.replace("r̥", "r");

        if (variety != "northumbrian")
            word.forEach(segment => {
                if (segment.value == "n" && segment.relIdx(1).match("r", "rˠ") && !segment.relIdx(1).stressed)
                    word.insert("d", segment.i + 1);

                if (segment.value == "m" && segment.relIdx(1).match("l", "ɫ", "r", "rˠ") && !segment.relIdx(1).stressed)
                    word.insert("b", segment.i + 1);
            });

        for (let i = 0; i < word.length; i++) {
            let segment = word[i];

            if (
                segment.match("m", "n", "l", "ɫ", "r", "rˠ") && segment.relIdx(-1).type != "vowel" && segment.relIdx(1).type != "vowel"
                && (!segment.relIdx(-1).match("ɫ", "rˠ", "j", "w") || (segment.relIdx(-1).value == "ɫ" && segment.value == "r"))
                && !(segment.relIdx(-1).value == "m" && segment.value == "n")
            ) {
                word.insert("ə", segment.i);
                i--;
            }

            if (segment.value == "j" && segment.relIdx(-1).type != "vowel" && segment.relIdx(1).type != "vowel") {
                segment.value = "iː";
                segment.type = "vowel";
            }
        }

        if (variety != "northumbrian")
            word.forEach(segment => {
                if (segment.match("e", "eo̯", "o", "y") && segment.relIdx(-1).value == "w" && segment.relIdx(1).match("r", "rˠ"))
                    segment.value = "u";
            });

        word.replace("æɑ̯", "æ");
        word.replace("æːɑ̯", "æː");
        word.replace("eo̯", "ø");
        word.replace("eːo̯", "øː");

        word.replace("ø", "e");
        word.replace("øː", "eː");
        word.replace("y", "i");
        word.replace("yː", "iː");

        word.replace("ɒ", "ɑ");

        //Homorganic lengthening
        word.forEach(segment => {
            if (variety == "northumbrian") {
                if (segment.type == "vowel" && segment.stressed && !segment.value.includes("ː")) {
                    if (
                        (segment.match("ɑ", "æ", "e", "i") && segment.relIdx(1).value == "ɫ" && segment.relIdx(2).value == "d")
                        || (segment.value == "ɑ" && segment.relIdx(1).value == "m" && segment.relIdx(2).value == "b")
                        || (segment.match("æ", "e", "o") && segment.relIdx(1).value == "rˠ" && segment.relIdx(2).value == "d")
                    ) {
                        segment.value = segment.value.slice(0, 1) + "ː" + segment.value.slice(1);
                        segment.lengthened = true;
                    }
                }
            } else {
                let lengtheningClusters = ["ɫd", "mb", "nd", "ŋg", "rˠd", "rˠn", "rˠz", "rˠð"];

                if (segment.type == "vowel" && segment.stressed && !segment.value.includes("ː") && lengtheningClusters.includes(segment.relIdx(1).value + segment.relIdx(2).value)) {
                    segment.value = segment.value.slice(0, 1) + "ː" + segment.value.slice(1);
                    segment.lengthened = true;
                }
            }
        });

        word.forEach(segment => {
            if (segment.value[1] == "ː" && segment.relIdx(1).type == "consonant" && segment.relIdx(2).type == "consonant" && (segment.relIdx(3).type == "consonant" || word.vowels.indexOf(segment) < word.vowels.length - 2))
                segment.value = segment.value.slice(0, 1) + segment.value.slice(2);
        });

        word.forEach(segment => {
            if (segment.value == "ɑː" && !segment.stressed && segment.relIdx(1).stressed)
                segment.value = "ɑ";

            if (segment.match("o", "ɑ") && segment.relIdx(1).match("n", "m", "ŋ") && segment.relIdx(2).stressed) {
                segment.value = "ɑ";
                if (segment.relIdx(2).type == "consonant")
                    segment.relIdx(1).remove();
            }
        });

        word.replace("æ", "a");
        word.replace("ɑ", "a");

        word.replace("æː", "ɛː");
        if (variety == "northumbrian")
            word.replace("ɑː", "aː");
        else
            word.replace("ɑː", "ɔː");

        word.replace("ç", "x", "a/x_");
        word.replace("x", "ç", "ɛː/e/eː/i/iː/ç_");

        word.forEach(segment => {
            if (segment.value == "ɣ" && segment.relIdx(-1).match("ɛː", "e", "eː", "i", "iː") && !segment.relIdx(1).stressed)
                segment.value = "ʝ";
        });

        //Vowel reduction
        word.forEach(segment => {
            if (
                segment.type == "vowel" && !segment.stressed && !segment.value.endsWith("ː")
                && ((segment.i > word.stressedVowel.i && !segment.relIdx(1).match("j", "w", "ɣ", "ʝ", "x", "ç"))
                    || (segment.value == "e" && (segment.relIdx(1).stressed || segment.relIdx(1).value == "rˠ" || segment.relIdx(1).type == "vowel")))
                && !(segment.value == "i" && segment.relIdx(1).value == "p")
            )
                segment.value = "ə";
        });
        word.forEach(segment => {
            if (segment.value == "ə" && segment.relIdx(1).match("ʃ", "ç", "ŋ") && !segment.relIdx(1).stressed)
                segment.value = "i";

            if (segment.value == "e" && segment.relIdx(1).match("j", "ɣ", "ç") && !segment.stressed)
                segment.value = "i";
            if (segment.value == "u" && segment.relIdx(1).match("w", "ɣ", "x") && !segment.stressed)
                segment.value = "o";
        });
        word.replaceSeq("ə,ə", "ə");
        word.forEach(segment => {
            if (segment.value == "ə" && segment.relIdx(-1).value == "j" && (segment.i < word.stressedVowel.i || segment.relIdx(-2).value != "rˠ") && segment != word.vowels.at(-1) && segment.relIdx(-2).type != "vowel") {
                segment.value = "i";
                segment.relIdx(-1).remove();
                if (segment.relIdx(-1).type == "vowel")
                    segment.remove();
            }

            if (segment.value == "ə" && segment.relIdx(1).value == "n" && ["conjVerb", "pastPtcp", "inf"].includes(word.partOfSpeech) && segment.i > word.stressedVowel.i)
                segment.inSuffix = true;
        });

        word.vowels.forEach(segment => {
            if (segment.relIdx(1).value == "j") {
                switch (segment.value) {
                    case "ɛː":
                    case "eː":
                        if (variety != "northumbrian" || segment.relIdx(2).type != "vowel")
                            segment.value = "e";
                        break;
                    case "i":
                    case "iː":
                        segment.value = "iː";
                        segment.relIdx(1).remove();
                        break;
                }
            }
        });

        addRow("EME", (variety == "northumbrian") ? "Early Northumbrian Middle English" : "Early Middle English", "1200", getSpelling_EME(), word, true);
    }

    function EME_to_LME(variety) {
        word = outcomes.EME.duplicate();

        if (variety == "scots") {
            word.replace("a", "e", "_s/ʃ");

            word.replace("e", "a", "_ɫ,ɣ");
        }

        word.forEach(segment => {
            if (segment.value == "oː" && segment.relIdx(1).value == "w" && (segment.stressed || !segment.relIdx(1).stressed))
                segment.value = "o";
        });

        word.replace("ʝ", "j");
        word.replace("ɣ", "w");

        word.forEach(segment => {
            if (segment.match("i", "iː") && segment.relIdx(1).value == "j" && !segment.relIdx(2).stressed) {
                segment.value = "iː";
                segment.relIdx(1).remove();
            }
        });

        //Delete short unstressed vowel between short vowel + liquid and consonant
        word.forEach(segment => {
            if (
                segment.type == "vowel" && !segment.stressed && !segment.value.includes("ː") && segment.relIdx(-1).match("l", "r")
                && segment.relIdx(-2).type == "vowel" && !segment.relIdx(-2).value.includes("ː") && !segment.inSuffix && segment.relIdx(1).type == "consonant"
                && !(segment.relIdx(1).match("m", "n", "ŋ") && segment.relIdx(2).match("p", "b", "t", "d", "t͡ʃ", "d͡ʒ", "k", "g"))
                && !(segment.relIdx(-1).value == "l" && segment.relIdx(1).match("l", "ɫ"))
                && !(segment.relIdx(-1).value.match("l", "r") && segment.relIdx(1).match("r", "rˠ"))
            ) {
                if (segment.relIdx(-1).value == "l")
                    segment.relIdx(-1).value = "ɫ";
                else if (segment.relIdx(-1).value == "r")
                    segment.relIdx(-1).value = "rˠ";
                segment.remove();
            }
        });

        word.forEach(segment => {
            if (segment.type == "vowel" && segment.i > word.stressedVowel.i) {
                switch (word.partOfSpeech) {
                    case "conjVerb":
                        if (segment.relIdx(1).value == "θ")
                            segment.inSuffix = true;
                    case "pastPtcp":
                        if (segment.relIdx(1).value == "d")
                            segment.inSuffix = true;
                    case "inf":
                        if (segment.relIdx(1).value == "n" && segment == word.at(-2))
                            segment.inSuffix = true;
                    default:
                        if (segment.relIdx(1).value == "s" && segment == word.vowels.at(-1))
                            segment.inSuffix = true;
                }
            }
        });

        //Drop schwa between vowel and consonant, except in inflectional suffixes
        word.forEach(segment => {
            if (segment.value == "ə" && (segment.relIdx(-1).type == "vowel" || (segment.relIdx(-1).match("j", "w") && segment.relIdx(-2).type == "vowel")) && segment.relIdx(1).type == "consonant" && !segment.relIdx(1).stressed && !segment.inSuffix)
                segment.remove();
        });

        word.forEach(segment => {
            if (segment.match("r", "rˠ") && segment.relIdx(-1).value == "w" && segment.relIdx(-2).type == "vowel" && !segment.stressed)
                word.insert("ə", segment.i);
        });

        word.forEach(segment => {
            if (segment.value == "x" && segment.relIdx(-1).type == "consonant" && segment.relIdx(1).type == "consonant")
                segment.remove();
        });

        word.replace("θ", "t", "f/s/ʃ/ç/x_");

        word.replace("t", "s", "_s");

        //Loss of [v] before most consonants
        word.forEach(segment => {
            if (segment.value == "v" && segment.relIdx(1).type == "consonant" && !segment.relIdx(1).match("l", "r", "n", "j"))
                segment.value = segment.relIdx(1).value[0];
        });
        word.forEach(segment => {
            if (segment.type == "consonant" && segment.value == segment.relIdx(1).value && (segment.relIdx(-1).type != "vowel" || segment.relIdx(2).type != "vowel"))
                segment.remove();
        });
        word.replaceSeq("w,w", "w");

        word.replace("oː", "o", "_x,C");

        for (let i = 0; i < word.length; i++) {
            let segment = word[i];

            if (segment.relIdx(1).value == "ç" && segment.type == "vowel" && !segment.match("i", "iː") && variety != "scots") {
                word.insert("j", segment.i + 1);
                i++;
            }

            if (segment.relIdx(1).value == "x" && segment.type == "vowel" && !segment.match("u", "uː") && (variety != "scots" || segment.match("a", "aː"))) {
                word.insert("w", segment.i + 1);
                i++;
            }
        }

        //Middle English diphthong development
        word.forEach(segment => {
            if (segment.type == "vowel" && segment.value != "ə" && (segment.stressed || !segment.relIdx(1).stressed)) {
                if (segment.relIdx(1).value == "j") {
                    switch (segment.value) {
                        case "a":
                        case "aː":
                            segment.value = "ai̯";
                            break;
                        case "ɛː":
                        case "e":
                            segment.value = "ɛi̯";
                            break;
                        case "eː":
                            if (variety == "scots")
                                return;
                            segment.value = "ei̯";
                            break;
                        case "i":
                        case "iː":
                            segment.value = "iː";
                            break;
                        case "ɔː":
                        case "o":
                        case "oː":
                            segment.value = "ɔi̯";
                            break;
                        case "u":
                        case "uː":
                            segment.value = "ui̯";
                            break;
                    }
                    segment.relIdx(1).remove();
                } else if (segment.relIdx(1).value == "w") {
                    switch (segment.value) {
                        case "a":
                        case "aː":
                            segment.value = "au̯";
                            break;
                        case "ɛː":
                        case "e":
                            segment.value = "ɛu̯";
                            break;
                        case "eː":
                            segment.value = "eu̯";
                            break;
                        case "i":
                        case "iː":
                            segment.value = "iu̯";
                            break;
                        case "ɔː":
                        case "o":
                            segment.value = "ɔu̯";
                            break;
                        case "oː":
                            if (variety == "scots")
                                return;
                            segment.value = "ou̯";
                            break;
                        case "u":
                        case "uː":
                            segment.value = "uː";
                            break;
                    }
                    segment.relIdx(1).remove();
                }
            }
        });

        word.replace("ei̯", "iː");
        word.replace("ou̯", "uː");
        word.replace("eu̯", "iu̯");

        if (variety == "scots")
            word.replace("eː", "i", "_ç");

        //Elision of intermediate schwa
        word.forEach(segment => {
            if (
                segment.value == "ə" && segment.relIdx(-1).type == "consonant" && segment.relIdx(1).type == "consonant"
                && (segment.relIdx(-2).type == "vowel" || segment.relIdx(-2).value == segment.relIdx(-1).value)
                && (segment.relIdx(2).type == "vowel" || segment.relIdx(2).value == "j" || segment.relIdx(2).value == segment.relIdx(1).value)
                && !(segment.relIdx(2) == word.at(-1) && segment.relIdx(2).value == "ə" && segment.relIdx(1).value != "s")
                && !(segment.relIdx(-1).value == "t͡ʃ" && segment.relIdx(1).value == "s")
                && !segment.relIdx(2).inSuffix
            )
                segment.remove();
        });
        word.forEach(segment => {
            if (segment.value == "m" && segment.relIdx(1).match("t", "s"))
                word.insert("p", segment.i + 1);

            if (segment.value == "m" && segment.relIdx(1).match("ɫ", "l", "r", "rˠ") && variety != "scots")
                word.insert("b", segment.i + 1);

            if (segment.match("ɫ", "n") && segment.relIdx(1).match("r", "rˠ") && variety != "scots")
                word.insert("d", segment.i + 1);

            if (segment.value == "m" && segment.relIdx(1).value == "ə" && segment.relIdx(2).match("l", "ɫ") && (segment.relIdx(-1).type == "vowel" || segment.relIdx(-1).match("rˠ", "m") && variety != "scots")) {
                word.insert("b", segment.i + 1);
                if (segment.relIdx(-1).value == "m")
                    segment.relIdx(-1).remove();
            }
        });
        word.replace("z", "s", "_p/t/k/t͡ʃ/f/θ/s");
        word.replace("s", "z", "b/d/g/v/ð_");

        word.forEach(segment => {
            if (
                segment.value == "b" && segment.relIdx(-1).value == "m" && !segment.relIdx(1).match("l", "r")
                && (segment.relIdx(1).type != "vowel" || segment.relIdx(1).inSuffix || segment == word.at(-2))
            ) {
                segment.relIdx(-1).droppedB = true;
                segment.remove();
            }

            if (
                segment.value == "n" && segment.relIdx(-1).value == "m"
                && (segment.relIdx(1).type != "vowel" || segment.relIdx(1).inSuffix || segment == word.at(-2))
            ) {
                segment.relIdx(-1).droppedN = true;
                segment.remove();
            }
        });

        //Trisyllabic laxing and open syllable lengthening
        word.vowels.forEach((vowel, i) => {
            if (i < word.vowels.length - 2 && vowel.relIdx(1).type != "vowel" && !vowel.relIdx(1).match("j", "w")) {
                if (vowel.value.endsWith("ː"))
                    vowel.value = vowel.value[0];
                word.replace("ɛ", "e");
                word.replace("ɔ", "o");
            } else if (vowel.stressed && (vowel.relIdx(2).type == "vowel" || vowel.relIdx(1).type == "vowel" || vowel == word.at(-1))) {
                switch (vowel.value) {
                    case "a":
                        vowel.value = "aː";
                        break;
                    case "e":
                        vowel.value = "ɛː";
                        break;
                    case "o":
                        vowel.value = "ɔː";
                        break;
                }
            }
        });

        //Vowel shortening before most clusters
        word.forEach(segment => {
            let nonShorteningClusters = ["st", "ɫd", "nd"];
            if (
                segment.relIdx(1).type == "consonant" && segment.relIdx(2).type == "consonant" && !segment.relIdx(1).match("j", "w")
                && !nonShorteningClusters.includes(segment.relIdx(1).value + segment.relIdx(2).value)
                && !(segment.value == "oː" && segment.relIdx(1).value == "rˠ" && segment.relIdx(2).value == "d")
                && !(segment.relIdx(1).value == "m" && segment.relIdx(2).value == "b" && segment.relIdx(3).inSuffix)
                && !(variety == "scots" && segment.relIdx(1).value == "rˠ")
            ) {
                switch (segment.value) {
                    case "aː":
                        segment.value = "a";
                        break;
                    case "ɛː":
                    case "eː":
                        segment.value = "e";
                        break;
                    case "iː":
                        segment.value = "i";
                        break;
                    case "ɔː":
                    case "oː":
                        segment.value = "o";
                        break;
                    case "uː":
                        segment.value = "u";
                        break;
                }
            }

            //Homorganic lengthening reversed in some cases
            if (segment.lengthened) {
                if (segment.relIdx(1).value == "n" && segment.relIdx(2).value == "d") {
                    if (segment.match("ɛː", "eː"))
                        segment.value = "e";

                    if (segment.match("ɔː", "oː"))
                        segment.value = "o";
                }

                if (segment.relIdx(1).value == "ɫ" && segment.relIdx(2).value == "d") {
                    if (segment.match("ɔː", "oː"))
                        segment.value = "o";

                    if (segment.value == "uː")
                        segment.value = "u";
                }

                if (segment.relIdx(1).value == "m" && segment.relIdx(2).value == "b" && segment.value == "uː")
                    segment.value = "u";
            }
        });

        //Early Scots vowel developments
        if (variety == "scots") {
            word.replace("oː", "øː");

            word.forEach(segment => {
                if (segment.stressed || !segment.relIdx(1).stressed) {
                    if (segment.value == "eː" && segment.relIdx(1).value == "j") {
                        segment.value = "ei̯";
                        segment.relIdx(1).remove();
                    }

                    if (segment.value == "øː" && segment.relIdx(1).value == "w") {
                        segment.value = "yu̯";
                        segment.relIdx(1).remove();
                    }
                }
            });

            word.replace("ei̯", "eː");
            word.replace("yu̯", "iu̯");

            word.replace("a", "aː", "_rˠ,C");
            word.replace("aː", "a", "_rˠ,rˠ");
        }

        word.forEach(segment => {
            if (segment.value == "d" && segment.relIdx(1).value == "ə" && segment.relIdx(2).match("r", "rˠ") && !segment.relIdx(-1).match("d", "n", "ɫ"))
                segment.value = "ð";
        });

        word.replace("eː", "ɛː", "_r/rˠ");

        word.forEach(segment => {
            if (segment.value == "w" && segment.relIdx(-1).value == "s" && segment.relIdx(1).match("o", "ɔː", "oː", "ɔu̯", "u", "uː") && variety != "scots") {
                segment.relIdx(-1).droppedW = true;
                segment.remove();
            }
        });

        //Fricative voicing after unstressed vowels
        if (variety != "scots")
            word.forEach(segment => {
                if (segment.relIdx(-1).type == "vowel" && !segment.relIdx(-1).stressed && segment.relIdx(1).type != "consonant" && !segment.relIdx(1).stressed) {
                    switch (segment.value) {
                        case "f":
                            segment.value = "v";
                            break;
                        case "θ":
                            segment.value = "ð";
                            break;
                        case "s":
                            segment.value = "z";
                            break;
                    }
                }
            });

        if (word.at(-2)?.value == "ə" && word.at(-1).match("z", "s"))
            word.sSuffix = true;

        //Degemination
        word.forEach(segment => {
            if (segment.type == "consonant" && segment.i < word.length - 1 && (segment.value == segment.relIdx(1).value[0] || segment.value == segment.relIdx(1).value)) {
                segment.relIdx(1).degeminated = true;
                segment.remove();
            }
        });

        word.forEach(segment => {
            if (segment.value == "f" && segment.relIdx(1).value == "n" && (segment.i == 0 || segment.stressed))
                segment.value = "s";
        });

        word.replace("ai̯", "æi̯");
        word.replace("ɛi̯", "æi̯");
        word.replace("au̯", "ɑu̯");
        word.replace("o", "ɔ");

        word.forEach(segment => {
            if (segment.type == "consonant" && segment.stressed && !segment.relIdx(1).stressed)
                segment.stressed = false;
        });

        if (word.at(-1).value == "ə") {
            word.at(-1).remove();
            word.droppedE = true;
        }
        word.forEach(segment => {
            if (segment.value == "ə" && segment.relIdx(1).type == "vowel")
                segment.remove();
        });
        if (word.stressedVowel.relIdx(-1).type == "consonant")
            word.stressedVowel.relIdx(-1).stressed = true;

        if (word.at(-2)?.value == "iː" && word.at(-1).value == "t͡ʃ" && !word.at(-2).stressed) {
            word.at(-1).remove();
            word.droppedE = false;
        }

        word.replaceSeq("w,l", "l");

        word.forEach(segment => {
            if (segment.value == "iː" && !segment.stressed && segment.relIdx(1).match("r", "rˠ"))
                word.insert("ə", segment.i + 1);
        });

        word.forEach(segment => {
            if (segment.value == "iː" && !segment.stressed && segment != word.at(-1) && !segment.inSuffix)
                segment.value = "i";
        });

        word.replace("iː", "i", "_t͡ʃ");

        word.forEach(segment => {
            if (
                segment.match("m", "n", "l", "r") && segment.relIdx(-1).type != "vowel" && segment.relIdx(1).type != "vowel"
                && !(segment.relIdx(-1).match("ɫ", "rˠ") && segment.value != "r")
            )
                word.insert("ə", segment.i);

            if (segment.value == "j" && segment.relIdx(1).type != "vowel") {
                if (segment.relIdx(1).type == "consonant" && segment.relIdx(2).type != "vowel")
                    segment.value = "i";
                else
                    segment.value = "iː";
                segment.type = "vowel";
            }

            if (segment.match("w", "xʷ") && segment.relIdx(1).type != "vowel" && segment.relIdx(1).value != "r") {
                segment.value = "ɔu̯";
                segment.type = "vowel";
            }
        });
        if (word.at(-1).value == "x" && word.at(-2)?.type == "consonant" && variety != "scots") {
            word.at(-1).value = "ɔu̯";
            word.at(-1).type = "vowel";
        }
        word.forEach(segment => {
            if (segment.value == "h" && segment.relIdx(1).type != "vowel")
                segment.remove();
        });

        word.forEach(segment => {
            if (segment.value == "j" && segment.relIdx(-1).type == "consonant" && !segment.stressed) {
                segment.value = "i";
                segment.type = "vowel";
            }
        });

        word.replace("l", "ɫ", "_C/#");
        word.replace("r", "rˠ", "_C/#");
        word.replace("ɫ", "l", "_V");
        word.replace("rˠ", "r", "_V");

        if (variety == "scots") {
            if (word.toString().endsWith("ədəst")) {
                word.at(-3).remove();
                word.at(-2).remove();
                word.at(-1).remove();
            }

            if (word.at(-1).value == "d" && word.at(-2).type == "vowel" && !word.at(-2).stressed)
                word.at(-1).value = "t";
            if (word.conjPastTense && word.vowels.at(-1).relIdx(1).value == "d" && !word.vowels.at(-1).stressed)
                word.vowels.at(-1).relIdx(1).value = "t";

            if (word.partOfSpeech == "conjVerb" && !word.vowels.at(-1).stressed) {
                if (word.at(-1).value == "θ") {
                    word.at(-1).value = "s";
                    word.sSuffix = true;
                }

                if (word.at(-2).value == "s" && word.at(-1).value == "t") {
                    word.at(-1).remove();
                    word.sSuffix = true;
                }
            }

            word.forEach(segment => {
                if (segment.value == "ʃ" && !segment.stressed && !segment.prevVowel().stressed) {
                    segment.value = "s";
                    if (segment == word.at(-1) && word.at(-2).type == "vowel" && !word.at(-2).stressed)
                        word.sSuffix = true;
                }
            });

            word.replace("i", "ɪ", "_C");

            word.forEach(segment => {
                if (segment.value == "ə" && segment.relIdx(1).match("t", "d", "θ", "ð", "s", "z", "l", "ɫ", "n") && !segment.relIdx(1).stressed)
                    segment.value = "ɪ";
            });

            if (word[0].value == "ɪ" && !word[0].stressed && (word[1]?.stressed || word[1]?.type == "vowel"))
                word[0].remove();

            //Loss of -en suffix
            if ((word.partOfSpeech == "inf" || word.partOfSpeech == "conjVerb") && word.at(-2)?.value == "ɪ" && word.at(-1).value == "n") {
                word.at(-2).remove();
                word.at(-1).remove();
                if (
                    word.at(-1).match("m", "n", "l", "r") && word.at(-2)?.type != "vowel"
                    && !(word.at(-2).match("ɫ", "rˠ") && word.at(-1).value != "r")
                    && !(word.at(-2).value == "m" && word.at(-1).value == "n")
                )
                    word.insert("ə", word.length - 1);

                if (word.at(-1).value == "w") {
                    word.at(-1).value = "ɔu̯";
                    word.at(-1).type = "vowel";
                }

                word.droppedE = true;
            } else if (word.partOfSpeech == "inf" && word.at(-1).value == "n" && word.at(-2).value.length > 1) {
                word.at(-1).remove();
                word.droppedE = true;
            }

            word.remove("b", "m_");
            word.remove("g", "ŋ_");

            word.forEach(segment => {
                if (segment.value == "ŋ" && segment.relIdx(1).type == "consonant" && !segment.relIdx(1).match("k", "l", "ɾ"))
                    segment.value = "n";
            });

            if (word.at(-1).value == "ŋ" && !word.vowels.at(-1).stressed) {
                word.at(-1).value = "n";
                word.at(-1).ing = true;
            }
        }

        if (variety == "scots")
            addRow("LME", "Early Scots", "1400", getSpelling_ESc(), word);
        else
            addRow("LME", "Late Middle English", "1400", getSpelling_LME(), word);
    }

    function LME_to_EModE(variety) {
        word = outcomes.LME.duplicate();

        //Drop y- prefix from verbs (was also lost from many nouns and adjectives, but remained in some)
        if (word[0].value == "i" && !word[0].stressed && (word[1]?.stressed || word[1]?.type == "vowel") && ["inf", "conjVerb", "pastPtcp"].includes(word.partOfSpeech))
            word[0].remove();

        if (word.partOfSpeech == "conjVerb" && word.toString().endsWith("ənd") && variety != "scots") {
            word.at(-3).value = "i";
            word.at(-2).value = "ŋ";
            word.at(-1).value = "g";
        }

        if (variety == "scots" && word.at(-1).value == "d" && word.at(-2).value == "n" && !word.vowels.at(-1).stressed) {
            word.at(-2).droppedD = true;
            word.at(-1).remove();
        }

        word.replace("ɔ", "a", "_n,d");

        if (variety != "scots")
            word.replace("u", "ɔ", "_ɫ,t/d/n");

        word.replace("xʷ", "h", "_ɔː/oː/uː");

        word.replace("e", "i", "_n,d͡ʒ");

        word.replace("ð", "d", "_l");
        word.replace("ð", "d", "_ə,ɫ");

        word.forEach(segment => {
            if (segment.value == "i" && segment.relIdx(1).type == "vowel" && !segment.relIdx(1).inSuffix)
                segment.value = "iː";
        });

        word.forEach(segment => {
            if (segment.value == "e" && !segment.stressed)
                segment.value = "i";
        });

        //Reduction of vowels in prefixes
        word.forEach(segment => {
            if (segment.type == "vowel" && !segment.stressed && segment.relIdx(1).stressed) {
                if (segment.relIdx(1).type == "vowel") {
                    segment.relIdx(-1).stressed = true;
                    if (segment == word.vowels[0])
                        for (let i = segment.i; i >= 0; i--)
                            word[i].stressed = true;
                    segment.remove();
                }
                else
                    segment.value = "ə";
            }
        });

        if (variety == "scots")
            word.replace("ɔ", "a", "_m/p/b/f");

        word.replace("ɔu̯", "ɑu̯", "_x,t");

        //H-loss
        if (variety != "scots") {
            word.forEach(segment => {
                if (segment.match("ç", "x")) {
                    if (segment.relIdx(-1).match("i", "u"))
                        segment.relIdx(-1).value += "ː";
                    segment.relIdx(-1).droppedH = true;
                    segment.remove();
                }
            });
        }

        //Loss of -en suffix
        if ((word.partOfSpeech == "inf" || word.partOfSpeech == "conjVerb") && word.at(-2)?.value == "ə" && word.at(-1).value == "n") {
            word.at(-2).remove();
            word.at(-1).remove();
            if (
                word.at(-1).match("m", "n", "l", "r") && word.at(-2)?.type != "vowel"
                && !(word.at(-2).match("ɫ", "rˠ") && word.at(-1).value != "r")
                && !(word.at(-2).value == "m" && word.at(-1).value == "n")
            )
                word.insert("ə", word.length - 1);

            if (word.at(-1).value == "w") {
                word.at(-1).value = "ɔu̯";
                word.at(-1).type = "vowel";
            }

            word.droppedE = true;
        } else if (word.partOfSpeech == "inf" && word.at(-1).value == "n" && word.at(-2).value.length > 1) {
            word.at(-1).remove();
            word.droppedE = true;
        }

        word.forEach(segment => {
            if (segment.value == "ə" && segment.relIdx(1).value == "n" && segment.relIdx(-1).type == "vowel" && segment.relIdx(-1).value.length > 1 && segment.relIdx(2).type != "consonant")
                segment.remove();
        });
        if (word.at(-4)?.type == "vowel" && word.at(-3).value == "r" && word.at(-2).match("ə", "ɪ") && !word.at(-2).stressed && word.at(-1).value == "n")
            word.at(-2).remove();
        word.replace("r", "rˠ", "_#");
        word.replace("i", "iː", "_V/#");

        if (word.partOfSpeech == "conjVerb" && word.at(-1).value == "ð" && word.at(-2).type == "vowel" && !word.at(-2).stressed) {
            word.thVerb = true;
            word.at(-1).value = "z";
            word.sSuffix = true;
        }
        if (word.partOfSpeech == "conjVerb" && word.at(-1).value == "θ" && word.at(-2).type == "consonant") {
            word.thVerb = true;
            word.insert("ə", -1);
            word.at(-1).value = "z";
            word.sSuffix = true;
        }

        if (variety == "scots" && word.sSuffix && word.at(-1).value == "s")
            word.at(-1).value = "z";

        //Loss of vowel in -es and -ed suffixes
        if (word.sSuffix && word.at(-1).value == "z" && word.at(-2).match("ə", "ɪ") && !word.at(-2).stressed && !word.at(-3).match("s", "z", "ʃ", "t͡ʃ", "d͡ʒ"))
            word.at(-2).remove();
        if ((word.partOfSpeech == "conjVerb" || word.partOfSpeech == "pastPtcp") && word.at(-1).match("d", "t") && word.at(-2).type == "vowel" && !word.at(-2).stressed) {
            word.pastTense = true;
            if (word.at(-1).value == "d" && word.at(-2)?.value == "ə" && !word.at(-3).match("t", "d"))
                word.at(-2).remove();
        }
        if (word.partOfSpeech == "pastPtcp" && word.at(-1).match("d", "t") && word.at(-2).type == "vowel")
            word.pastTense = true;
        if (word.partOfSpeech == "conjVerb" && word.toString().endsWith("dəst") && word.at(-5).type == "vowel" && !word.at(-5).stressed) {
            word.conjPastTense = true;
            if (word.at(-5)?.value == "ə" && !word.at(-6).match("t", "d"))
                word.at(-5).remove();
        }
        if (word.partOfSpeech == "conjVerb" && word.toString().endsWith("dən") && word.at(-4).type == "vowel" && !word.at(-4).stressed) {
            word.conjPastTense = true;
            if (word.at(-4)?.value == "ə" && !word.at(-5).match("t", "d"))
                word.at(-4).remove();
        }
        word.forEach(segment => {
            if (segment.value == "h" && segment.relIdx(1).type != "vowel")
                segment.remove();
        });
        word.replace("z", "s", "p/t/k/f/θ_");
        word.replace("d", "t", "p/k/t͡ʃ/f/θ/s/ʃ_");
        word.forEach(segment => {
            if (segment.match("m", "n", "l", "r") && segment.relIdx(-1).type != "vowel" && segment.relIdx(1).type != "vowel"
                && !(segment.relIdx(-1).match("l", "ɫ", "r", "rˠ") && segment.value != "r") && !(word.at(-2).value == "m" && word.at(-1).value == "n"))
                word.insert("ə", segment.i);
        });
        if (word.at(-2)?.value == "j" && word.at(-1).type == "consonant") {
            word.at(-2).value = "iː";
            word.at(-2).type = "vowel";
        }
        if (word.at(-2)?.match("w", "xʷ") && word.at(-1).type == "consonant") {
            word.at(-2).value = "ɔu̯";
            word.at(-2).type = "vowel";
        }
        word.replace("l", "ɫ", "_C/#");
        word.replace("r", "rˠ", "_C/#");
        word.replace("ɫ", "l", "_V");
        word.replace("rˠ", "r", "_V");

        word.sForm = word;

        if (word.conjPastTense && word.toString().endsWith("əst"))
            word.at(-3).remove();

        word.forEach(segment => {
            if (segment.value == "n" && segment.relIdx(-1).value == "ɫ" && segment.relIdx(1).type != "vowel")
                segment.remove();
        });

        word.forEach(segment => {
            if (variety == "scots" && segment.value == "v" && segment.relIdx(-1).match("ɫ", "rˠ"))
                segment.remove();
        });
        word.replace("ɫ", "l", "_V");

        word.replace("e", "a", "_rˠ");
        if (variety == "scots")
            word.replace("e", "a", "_r");

        if (variety == "scots")
            word.replace("e", "a", "w/xʷ_");

        word.EModEWord = word.duplicate();


        if (variety == "scots") {
            word.replace("r", "ɾ");
            word.replace("rˠ", "ɾ");
        } else {
            word.replace("rˠ", "ɹ̠");
        }

        //[ə] > [ɪ] frequently before coronal obstruents
        word.forEach(segment => {
            if (segment.value == "ə" && segment.relIdx(1).match("t", "d", "θ", "ð", "s", "z") && segment.relIdx(2).type != "vowel" && !segment.relIdx(1).stressed)
                segment.value = "ɪ";
        });

        //Vowel changes before /l/
        word.forEach(segment => {
            if (variety == "scots") {
                word.replace("aː", "ɑu̯", "_ɫ,d");

                word.forEach(segment => {
                    if (segment.value == "ɫ" && segment.relIdx(-1).match("a", "ɔ", "u") && !segment.relIdx(1).match("j", "w")) {
                        switch (segment.relIdx(-1).value) {
                            case "a":
                                segment.relIdx(-1).value = "ɑu̯";
                                break;
                            case "ɔ":
                                segment.relIdx(-1).value = "ɔu̯";
                                break;
                            case "u":
                                segment.relIdx(-1).value = "uː";
                                break;
                        }
                        segment.remove();
                    }
                });
            } else {
                if (segment.value == "ɫ" && segment.relIdx(-1).match("a", "ɔ")) {
                    if (segment.relIdx(1).match("t", "d", "t͡ʃ", "d͡ʒ", "s", "z", "ʃ", "l", "r", "k") || segment == word.at(-1)) {
                        if (segment.relIdx(-1).value == "a")
                            segment.relIdx(-1).value = "ɑu̯";
                        else if (segment.relIdx(-1).value == "ɔ")
                            segment.relIdx(-1).value = "ɔu̯";

                        if (segment.relIdx(1).value == "k")
                            segment.remove();
                    }
                    else if (segment.relIdx(1).value == "f" || (segment.relIdx(-1).value == "a" && segment.relIdx(1).value == "v"))
                        segment.remove();
                    else if (segment.relIdx(1).value == "m") {
                        if (segment.relIdx(-1).value == "a")
                            segment.relIdx(-1).value = "ɑː";
                        else if (segment.relIdx(-1).value == "ɔ")
                            segment.relIdx(-1).value = "ɔː";
                        segment.remove();
                    }
                }
            }
        });

        if (variety == "scots")
            word.replace("a", "ɑu̯", "_n,d/d͡ʒ");

        word.replace("i", "ɪ");
        word.replace("u", "ʊ");

        //Great Vowel Shift
        word.replace("iː", "əi̯");
        word.replace("eː", "iː");
        word.replace("ɛː", "eː");
        if (variety != "scots") {
            word.replace("uː", "əu̯");
            word.replace("əu̯", "uː", "j_");
            word.replace("əu̯", "uː", "_m/p/b/f/v");
            word.replace("oː", "uː");
        }
        word.replace("ɔː", "oː");
        word.replace("aː", "ɛː");
        if (variety == "scots")
            word.replace("ɛː", "aː", "w/xʷ_");

        word.replace("æi̯", "ɛi̯");
        word.replace("ɑu̯", "ɔː");
        word.replace("ɔu̯", "ou̯");
        word.replace("iu̯", "ɪu̯");
        word.replace("ɛu̯", "ɪu̯");
        word.replace("ɔi̯", "oi̯");
        if (variety != "scots")
            word.replace("ui̯", "oi̯");

        if (variety == "scots") {
            word.replace("ɔː", "ɑː");
            word.replace("aː", "ɑː");
        }

        if (variety != "scots")
            word.replace("ɔ", "ɒ");

        if (variety == "scots")
            word.forEach(segment => {
                if (segment.value == "t" && segment.relIdx(-1).match("p", "k"))
                    segment.remove();
            });

        if (variety == "scots")
            addRow("EModE", "Middle Scots", "1600", getSpelling_MSc(word), word, true);
        else
            addRow("EModE", "Early Modern English", "1600", getSpelling_EModE(word), word, true);
    }

    function EModE_to_ModE(variety) {
        word = outcomes.EModE.duplicate();

        if (word.thVerb) {
            word.sSuffix = true;
            word.EModEWord.sSuffix = true;
            word.at(-1).value = word.sForm.at(-1).value;
            word.EModEWord.at(-1).value = word.sForm.at(-1).value;
            if (word.at(-2).value == "ɪ" && word.sForm.at(-2).value != "ə") {
                word.at(-2).remove();
                word.EModEWord.at(-2).remove();
            }
            if (word.at(-3).type == "consonant" && word.sForm.at(-3).value == "ə") {
                word.insert("ə", -2);
                word.EModEWord.insert("ə", -2);
            }
            if (word.at(-2).value == "j" && word.sForm.at(-2).value == "iː") {
                word.at(-2).value = "əi̯";
                word.at(-2).type = "vowel";
                word.EModEWord.at(-2).value = "iː";
                word.EModEWord.at(-2).type = "vowel";
            }
            if (word.at(-2).match("w", "xʷ") && word.sForm.at(-2).value == "ɔu̯") {
                word.at(-2).value = "ou̯";
                word.at(-2).type = "vowel";
                word.EModEWord.at(-2).value = "ɔu̯";
                word.EModEWord.at(-2).type = "vowel";
            }
        }

        word.replace("r", "ɹ̠");

        word.replace("e", "ɛ");

        if (variety != "scots") {
            word.replace("ɛi̯", "ɛː");
            word.replace("ou̯", "oː");
        }

        word.forEach(segment => {
            if (segment.value == "w" && segment.relIdx(1).match("ɹ̠", "ɾ")) {
                segment.relIdx(1).droppedW = true;
                segment.remove();
            }
        });

        if (word.at(-1).value == "ð" && word.at(-2)?.type == "vowel" && !word.at(-2)?.stressed)
            word.at(-1).value = "θ";

        word.forEach(segment => {
            if (segment.match("k", "g") && segment.relIdx(1).value == "n") {
                if (segment.relIdx(-1).type == "vowel") {
                    segment.stressed = false;
                    if (segment.value == "kʰ")
                        segment.value = "k";
                } else if (!segment.relIdx(-1).match("ŋ", "ɫ", "ɹ̠", "ɾ", "s") || segment.relIdx(1).stressed) {
                    if (segment.relIdx(-1).value == "ŋ")
                        segment.relIdx(-1).value = "n";
                    if (segment.value == "k")
                        segment.relIdx(1).droppedK = true;
                    if (segment.value == "g")
                        segment.relIdx(1).droppedG = true;
                    segment.remove();
                }
            }
        });

        //Meet-meat merger
        word.replace("eː", "iː");
        word.replace("ɛː", "eː");

        if (variety == "scots") {
            outcomes.ModE = word.duplicate();
            return;
        }

        word.forEach(segment => {
            if (segment.match("p", "t", "k") && (segment.stressed || segment == word[0]) && segment.relIdx(-1).value != "s")
                segment.value += "ʰ";
        });

        //Foot-strut split
        word.forEach(segment => {
            if (segment.value == "ʊ" && !(segment.relIdx(-1).match("pʰ", "b", "f", "w") && segment.relIdx(1).match("ʃ", "l", "ɫ")))
                segment.value = "ʌ";
        });

        word.forEach(segment => {
            if (segment.value == "ŋ" && segment.relIdx(1).value == "g" && segment.relIdx(2).type != "vowel" && !segment.relIdx(2).match("l", "ɹ̠", "w"))
                segment.relIdx(1).remove();
        });

        word.forEach(segment => {
            if (segment.value == "a" && segment.relIdx(-1).match("w", "xʷ") && !segment.relIdx(1).match("k", "g", "ŋ"))
                segment.value = "ɒ";
        });

        word.replace("ɒ", "ɒː", "_f/θ/s");

        word.forEach(segment => {
            if (segment.relIdx(1).value == "ɹ̠" && segment.relIdx(2).type != "vowel") {
                switch (segment.value) {
                    case "a":
                        segment.value = "ɑː";
                        break;
                    case "ɒ":
                        segment.value = "ɔː";
                        break;
                    case "ɪ":
                    case "ʌ":
                    case "ɛ":
                        segment.value = "əː";
                        break;
                }
            }
        });

        word.replace("a", "æ");

        word.replace("uː", "ʊ", "_k");

        word.replace("uː", "oː", "_ɹ̠");

        word.forEach(segment => {
            if (segment.value == "ɪu̯") {
                segment.value = "uː";
                if (!segment.relIdx(-1).match("j", "t͡ʃ", "d͡ʒ", "ʃ", "ɹ̠", "w") && !(segment.relIdx(-1).value == "l" && segment.relIdx(-2).match("pʰ", "tʰ", "kʰ", "p", "t", "k", "b", "d", "g"))) {
                    word.insert("j", segment.i);
                    if (segment.stressed)
                        segment.relIdx(-1).stressed = true;
                }
            }
        });

        word.replace("h", "ç", "_j");

        word.replace("eː", "ɛə̯", "_ɹ̠");
        word.replace("iː", "ɪə̯", "_ɹ̠");
        word.replace("oː", "ɔə̯", "_ɹ̠");
        word.replace("uː", "ʊə̯", "_ɹ̠");
        word.forEach(segment => {
            if (segment.value == "ɹ̠" && segment.relIdx(-1).match("əi̯", "əu̯", "oi̯") && segment.relIdx(1).type != "vowel")
                word.insert("ə", segment.i);
        });

        //"Happy" shortening & tensing
        word.forEach(segment => {
            if (
                segment.match("əi̯", "iː") && !segment.stressed
                && (segment == word.at(-1) || segment.relIdx(1).type == "vowel" || ((word.sSuffix || word.pastTense) && segment == word.at(-2)))
            )
                segment.value = "i";
        });

        //Syllabic consonants
        word.forEach(segment => {
            if (segment.value == "ə" && segment.relIdx(1).match("m", "n", "ɫ") && segment.relIdx(2).type != "vowel") {
                segment.value = segment.relIdx(1).value + "̩";
                segment.relIdx(1).remove();
            }
        });

        word.forEach(segment => {
            if (segment.value == "t" && segment.relIdx(-1).match("f", "s") && segment.relIdx(1).match("n̩", "ɫ̩"))
                segment.remove();
        });

        word.replace("eː", "eɪ̯");
        word.replace("oː", "oʊ̯");
        word.replace("əi̯", "aɪ̯");
        word.replace("əu̯", "aʊ̯");
        word.replace("oi̯", "ɔɪ̯");

        word.replace("xʷ", "w");

        word.replace("tʰ", "t̠ʰ", "_ɹ̠");
        word.replace("t", "t̠", "_ɹ̠");
        word.replace("d", "d̠", "_ɹ̠");

        for (let i = 0; i < word.length; i++) {
            let segment = word[i];
            if (
                segment.match("t", "t͡ʃ") && !segment.stressed && (segment.relIdx(-1).type == "vowel" || segment.relIdx(-1).match("n", "ɫ", "ɹ̠"))
                && (segment.relIdx(1).type != "vowel" || segment.relIdx(1).value == "n̩")
            ) {
                word.insert("ʔ", segment.i);
                i++;
            }
        }

        if (word[0].type == "vowel") {
            word.insert("ʔ", 0);
            if (word[1].stressed)
                word[0].stressed = true;
        }

        word.modernSpelling = getSpelling_ModE(word.EModEWord);
        outcomes.ModE = word.duplicate();
    }

    function ModE_to_UK() {
        word = outcomes.ModE.duplicate();

        //Non-rhoticity
        word.forEach(segment => {
            if (segment.value == "ɹ̠" && segment.relIdx(-1).type == "vowel" && segment.relIdx(1).type != "vowel")
                segment.remove();
        });

        word.forEach(segment => {
            if (segment.value == "æ" && (segment.relIdx(1).match("f", "θ", "s") || (segment.relIdx(1).value == "n") && segment.relIdx(2).match("t͡ʃ", "s"))) {
                segment.value = "ɑː";
                segment.trapBath = true;
            }
        });

        word.replace("ɒː", "ɒ");

        word.replace("ɔə̯", "ɔː");

        word.replace("æ", "a");
        word.replace("ɒ", "ɔ");
        word.replace("ɔː", "oː");

        word.replace("oʊ̯", "əʉ̯");
        word.replace("uː", "ʊʉ̯");
        word.replace("ʌ", "ɐ");
        word.replace("ʊ", "ɵ");

        word.replace("iː", "ɪi̯");

        word.replace("əʉ̯", "ɒʊ̯", "_ɫ");
        word.replace("ʊʉ̯", "uː", "_ɫ");

        word.replace("ɛə̯", "ɛː");
        word.replace("ɪə̯", "ɪː");
        word.replace("ʊə̯", "oː");

        word.replace("eɪ̯", "ɛɪ̯");
        word.replace("ɔɪ̯", "oɪ̯");

        word.forEach(segment => {
            if (segment.value == "j" && segment.relIdx(-1).value == "s" && segment.relIdx(-2).type != "vowel")
                segment.remove();

            if (segment.value == "j" && segment.relIdx(-1).value == "l" && segment.stressed)
                segment.remove();
        });

        addRow("UK", "Modern English (UK)", "2000", word.modernSpelling, word);
    }

    function ModE_to_US() {
        word = outcomes.ModE.duplicate();

        word.replace("ɒ", "ɒː", "_ŋ/g");
        word.replace("ɒː", "ɔː");

        word.replace("ɒ", "ɔ", "_ɹ̠");

        word.replace("ɒ", "ɑː");

        word.forEach(segment => {
            if (segment.value.endsWith("ː"))
                segment.value = segment.value[0];
        });

        //Flapping
        word.forEach(segment => {
            if (segment.match("t", "d") && !segment.stressed && (segment.relIdx(-1).type == "vowel" || segment.relIdx(-1).value == "ɹ̠") && !segment.relIdx(-1).match("m̩", "n̩", "ɫ̩") && segment.relIdx(1).type == "vowel")
                segment.value = "ɾ";
        });

        word.replace("æ", "eə̯", "_m/n");

        word.replace("ʌ", "ɜ");

        word.replace("ɔə̯", "ɔ");

        //Yod-dropping
        word.forEach(segment => {
            if (segment.value == "j" && segment.relIdx(-1).match("n", "tʰ", "t", "d", "θ", "s", "l") && (segment.stressed || segment.relIdx(-2).type == "consonant"))
                segment.remove();
        });

        word.replace("ɛə̯", "ɛ");
        word.replace("æ", "ɛ", "_ɹ̠");
        word.replace("ɜ", "ə", "_ɹ̠");
        word.replace("ɪə̯", "ɪ");
        word.replace("ʊə̯", "ə", "t͡ʃ/d͡ʒ/ʃ/j/n/l/ɹ̠_");
        word.replace("ʊə̯", "ɔ");
        word.replace("ɛ", "e", "_ɹ̠");
        word.replace("ɔ", "o", "_ɹ̠");

        word.forEach(segment => {
            if (segment.value == "ə" && segment.relIdx(1).value == "ɹ̠" && (segment.relIdx(2).type != "vowel" || segment.stressed)) {
                segment.value = "ɚ";
                segment.relIdx(1).remove();
            }
        });
        word.forEach(segment => {
            if (segment.match("ɑ", "e", "ɪ", "o") && segment.relIdx(1).value == "ɹ̠" && segment.relIdx(2).type != "vowel") {
                segment.value += "ɚ̯";
                segment.relIdx(1).remove();
            }
        });

        //Weak vowel merger
        word.forEach(segment => {
            if (segment.match("ə", "ɪ") && !segment.stressed && segment.relIdx(1).value != "ŋ") {
                if (segment.relIdx(1).type == "consonant" && segment.relIdx(2).type != "vowel" && !segment.relIdx(1).stressed) {
                    if (segment.relIdx(1).match("m", "n", "ɫ")) {
                        segment.value = segment.relIdx(1).value + "̩";
                        segment.relIdx(1).remove();
                    }
                    else
                        segment.value = "ɨ";
                }
                else
                    segment.value = "ə";
            }
        });

        word.replace("l", "ɫ");

        word.replace("i", "iə̯", "_ɫ,C/#");
        word.replace("u", "uə̯", "_ɫ,C/#");

        addRow("US", "Modern English (US)", "2000", word.modernSpelling, word, true);
    }

    function UK_to_AU() {
        word = outcomes.UK.duplicate();

        word.forEach(segment => {
            if (segment.trapBath && segment.relIdx(1).value == "n")
                segment.value = "a";
        });

        //Flapping
        word.forEach(segment => {
            if (segment.match("t", "d") && !segment.stressed && (segment.relIdx(-1).type == "vowel" || segment.relIdx(-1).value == "ɹ̠") && !segment.relIdx(-1).match("m̩", "n̩", "ɫ̩") && segment.relIdx(1).type == "vowel")
                segment.value = "ɾ";
        });

        word.forEach(segment => {
            if (segment.value == "j" && segment.relIdx(-1).value == "θ" && (segment.stressed || segment.relIdx(-2).type == "consonant"))
                segment.remove();
        });

        //Yod-coalescence
        word.replaceSeq("tʰ,j", "t͡ʃ");
        word.replaceSeq("t,j", "t͡ʃ");
        word.replaceSeq("d,j", "d͡ʒ");
        word.replaceSeq("s,j", "ʃ");
        word.replaceSeq("z,j", "ʒ");

        //Weak vowel merger
        word.forEach(segment => {
            if (segment.match("ə", "ɪ") && !segment.stressed && segment.relIdx(1).value != "ŋ") {
                if (segment.relIdx(1).type == "consonant" && segment.relIdx(2).type != "vowel" && !segment.relIdx(1).stressed) {
                    if (segment.relIdx(1).match("m", "n", "ɫ")) {
                        segment.value = segment.relIdx(1).value + "̩";
                        segment.relIdx(1).remove();
                    }
                    else
                        segment.value = "ɨ";
                }
                else
                    segment.value = "ə";
            }
        });

        word.replace("l", "ɫ");

        word.replace("a", "æ");
        word.replace("ɛ", "e");
        word.replace("ɪ", "i");
        word.replace("ɵ", "u");
        word.replace("aɪ̯", "ɑe̯");
        word.replace("ɛɪ̯", "æɪ̯");
        word.replace("aʊ̯", "æɔ̯");
        word.replace("əʉ̯", "ɜʉ̯");
        word.replace("ɑː", "ɐː");
        word.replace("ɛː", "eː");
        word.replace("əː", "ɘː");
        word.replace("ə", "ɐ", "_#");
        word.replace("ɒʊ̯", "ɔʊ̯");
        word.replace("æ", "ɛː", "_m/n/ŋ");
        word.replace("ɪi̯", "iː", "_ɫ");

        word.forEach(segment => {
            if (segment.value == "ɪː" && !(segment.relIdx(1).type == "consonant" && segment.relIdx(2).type != "vowel"))
                segment.value = "ɪə̯";
        });

        addRow("AU", "Modern English (AU)", "2000", word.modernSpelling, word, true);
    }

    function ModE_to_ModSc() {
        word = outcomes.ModE.duplicate();

        word.replace("øː", "ɪu̯", "_k/x");

        word.forEach(segment => {
            if (segment.value == "ɪu̯") {
                segment.value = "uː";
                if (!segment.relIdx(-1).match("j", "t͡ʃ", "d͡ʒ", "ʃ", "ɾ", "w") && !(segment.relIdx(-1).value == "l" && segment.relIdx(-2).match("p", "t", "k", "b", "d", "g"))) {
                    word.insert("j", segment.i);
                    if (segment.stressed)
                        segment.relIdx(-1).stressed = true;
                }
            }
        });

        word.replace("h", "ç", "_j");

        word.forEach(segment => {
            if (segment.match("əi̯", "iː") && !segment.stressed && (segment == word.at(-1) || segment.relIdx(1).type == "vowel" || ((word.sSuffix || word.pastTense) && segment == word.at(-2))))
                segment.value = "e";
        });

        //Scottish Vowel Length Rule
        word.forEach(segment => {
            if (segment.relIdx(1).type == "consonant" && (!segment.relIdx(1).match("v", "ð", "z", "ɾ") || segment.relIdx(2).type == "consonant") && !(segment == word.at(-2) && word.pastTense)) {
                switch (segment.value) {
                    case "iː":
                        segment.value = "i";
                        break;
                    case "eː":
                        if (segment.i == 0) {
                            segment.value = "ɪ";
                            word.insert("j", segment.i);
                            segment.relIdx(-1).stressed = segment.stressed;
                        }
                        else
                            segment.value = "e";
                        break;
                    case "oː":
                        segment.value = "o";
                        break;
                    case "uː":
                        segment.value = "u";
                        break;
                    case "øː":
                        segment.value = "ø";
                        break;
                    case "ɛi̯":
                        segment.value = "e";
                        break;
                }
            } else {
                switch (segment.value) {
                    case "a":
                        segment.value = "aː";
                        break;
                    case "ɛ":
                        segment.value = "ɛː";
                        break;
                    case "ɔ":
                        segment.value = "ɔː";
                        break;
                    case "əi̯":
                        segment.value = "əːi̯";
                        break;
                }
            }
        });

        word.replace("əːi̯", "ai̯");

        word.replace("ui̯", "əi̯");

        word.forEach(segment => {
            if (segment.value == "ɛi̯" && (segment == word.at(-1) || segment.relIdx(1).inSuffix || (word.sSuffix && segment == word.at(-2))))
                segment.value = "əi̯";
        });
        word.replace("ɛi̯", "eː");

        word.forEach(segment => {
            if (segment.value == "d" && segment.relIdx(-1).value == "n" && segment.relIdx(1).value != "ɾ") {
                segment.relIdx(-1).droppedD = true;
                segment.remove();
            }

            if (segment.value == "d" && segment.relIdx(-1).value == "ɫ" && (segment == word.at(-1) || segment.relIdx(1).inSuffix)) {
                segment.relIdx(-1).droppedD = true;
                segment.remove();
            }
        });

        if (word.pastTense && word.at(-2).value == "ɪ" && !word.at(-3).match("p", "b", "t", "d", "k", "g")) {
            if (word.at(-3).match("d͡ʒ", "v", "ð", "z") || (word.vowels.at(-2).stressed && word.at(-3).match("m", "n", "ŋ", "l", "ɾ")))
                word.at(-1).value = "d";
            word.at(-2).remove();
        }
        word.replace("l", "ɫ", "_C/#");
        word.replace("ɫ", "l", "_V");

        word.forEach(segment => {
            if (segment.match("m", "n", "ɫ", "ɾ") && segment.relIdx(-1).type != "vowel" && segment.relIdx(1).type != "vowel" && !segment.relIdx(1).match("j", "w")
                && !(segment.relIdx(-1).match("ɫ", "ɾ") && segment.value != "ɾ") && !(word.at(-2).value == "m" && word.at(-1).value == "n"))
                word.insert("ə", segment.i);
        });
        if (word.at(-2)?.value == "j" && word.at(-1).type == "consonant") {
            word.at(-2).value = "iː";
            word.at(-2).type = "vowel";
        }
        if (word.at(-2)?.match("w", "xʷ") && word.at(-1).type == "consonant") {
            word.at(-2).value = "ou̯";
            word.at(-2).type = "vowel";
        }

        word.forEach(segment => {
            if (segment.value == "ɪ" && segment.relIdx(1).value == "n" && segment.i > word.stressedVowel.i)
                segment.value = "ə";
        });

        word.forEach(segment => {
            if (segment.value == "t" && segment.relIdx(-1).match("f", "s", "ç", "x") && segment.relIdx(1).value == "ə" && segment.relIdx(2).match("n", "ɫ"))
                segment.remove();
        });

        word.replace("l", "ɫ");

        word.replace("ʊ", "ʌ");
        word.replace("ou̯", "ʌu̯");

        word.replace("t͡ʃ", "ʃ", "n_");
        word.replace("d͡ʒ", "ʒ", "n_");

        word.replace("ai̯", "aɪ̯");
        word.replace("oi̯", "oɪ̯");

        word.replace("ɪ", "ʌ", "w/xʷ_");

        word.replace("ɪ", "ə", "_ɫ/ɾ");

        word.replace("ø", "ʏ");

        for (let i = 0; i < word.length; i++) {
            let segment = word[i];
            if (segment.match("t", "t͡ʃ") && !segment.stressed && (segment.relIdx(-1).type == "vowel" || segment.relIdx(-1).match("n", "ɫ", "ɾ")) && segment.relIdx(1).type != "vowel") {
                word.insert("ʔ", segment.i);
                i++;
            }
        }

        if (word[0].type == "vowel") {
            word.insert("ʔ", 0);
            if (word[1].stressed)
                word[0].stressed = true;
        }

        word.forEach(segment => {
            if (segment.value == "ʌu̯" && !segment.stressed && segment.relIdx(1).type != "vowel")
                segment.value = "e";
        });

        word.replace("øː", "eː", "_#");

        addRow("scots", "Modern Scots", "2000", getSpelling_ModSc(word), word);
    }

    function lat_to_LL() {
        word = outcomes.lat.duplicate();

        word.replace("ɫ", "l", "_V");

        word.remove("ɦ");
        word.remove("h");

        word.replace("pʰ", "f");
        word.replace("tʰ", "t");
        word.replace("kʰ", "k");
        word.replace("r̥", "r");
        word.replaceSeq("z,z", "d,d͡z");
        word.replace("z", "d͡z");

        if (word[0].match("p", "t", "k", "b", "d", "g", "f") && word[1].type == "consonant" && !word[1].match("l", "r"))
            word[0].remove();

        //Denasalization
        if (word.at(-1).value.endsWith("̃"))
            word.at(-1).value = word.at(-1).value[0];

        word.replace("m", "n", "_#");

        word.replace("ʏ", "ɪ");
        word.replace("yː", "iː");
        word.replace("y", "i");

        word.forEach(segment => {
            if (segment.match("a", "ɛ", "ɪ", "ɔ", "ʊ") && segment.relIdx(1).value == segment.value) {
                if (segment.relIdx(1).stressed)
                    segment.stressed = true;
                segment.relIdx(1).remove();
            }
        });

        word.forEach(segment => {
            if (segment.value == "w" && segment.relIdx(-1).match("a", "aː") && segment.relIdx(-1) == word.stressedVowel && segment.relIdx(1).value == "ɪ" && segment.relIdx(2).match("t", "k"))
                segment.relIdx(1).remove();
        });

        word.replace("w", "β", "_V");

        word.forEach(segment => {
            if (segment.value == "ɪ" && segment.relIdx(-1).match("a", "aː", "e", "eː", "o", "oː") && segment != word.vowels.at(-1)) {
                segment.value = "j";
                segment.type = "consonant";
                if (segment.stressed)
                    segment.relIdx(-1).stressed = true;
            }

            if (segment.value == "ʊ" && segment.relIdx(-1).match("a", "aː", "e", "eː", "o", "oː") && segment != word.vowels.at(-1)) {
                segment.value = "w";
                segment.type = "consonant";
                if (segment.stressed)
                    segment.relIdx(-1).stressed = true;
            }
        });

        word.forEach(segment => {
            if (segment.type == "vowel" && segment == word.vowels.at(-2) && word.vowels.length > 2 && segment.relIdx(1).type == "consonant" && segment.relIdx(2).type == "consonant") {
                segment.stressed = true;
                word.vowels.at(-3).stressed = false;
            }
        });

        word.forEach(segment => {
            if (segment.match("ɪ", "iː") && segment.relIdx(1).match("ɪ", "i", "iː")) {
                segment.value = "iː";
                if (segment.relIdx(1).stressed)
                    segment.stressed = true;
                segment.relIdx(1).remove();
            }
        });

        word.replace("ae̯", "ɛː");
        word.replace("oe̯", "eː");

        word.forEach(segment => {
            if (segment.match("i", "e", "iː", "eː") && segment.relIdx(1).type == "vowel" && (!segment.stressed || segment == word.vowels.at(-3)) && !(segment.i == 1 && segment.relIdx(-1).value == "w")) {
                segment.value = "j";
                segment.type = "consonant";
                if (segment.stressed)
                    segment.relIdx(1).stressed = true;
                if (segment.relIdx(1).stressed)
                    segment.stressed = true;
            }

            if (segment.match("u", "o", "uː", "oː") && segment.relIdx(1).type == "vowel" && !segment.stressed && !(segment.i == 1 && segment.relIdx(-1).value == "j")) {
                segment.value = "w";
                segment.type = "consonant";
                if (segment.relIdx(1).stressed)
                    segment.stressed = true;
            }

            if (segment.match("u", "o", "uː", "oː") && segment.relIdx(1).type == "vowel" && segment == word.vowels.at(-3) && !(segment.i == 1 && segment.relIdx(-1).value == "j")) {
                segment.relIdx(1).stressed = true;
                if (word.vowels.length > 3) {
                    word.forEach(segment => segment.stressed = false);
                    word.vowels.at(-4).stressed = true;
                }
                segment.value = "w";
                segment.type = "consonant";
            }
        });
        word.remove("j", "#/C_j");

        word.forEach(segment => {
            if (segment.value == "w" && segment.relIdx(-1).type == "consonant" && segment.relIdx(-2).type == "consonant" && !segment.relIdx(-1).match("k", "g", "n"))
                segment.remove();

            if (segment.value == "w" && segment.relIdx(1).match("ɔ", "o", "oː", "ʊ", "u", "uː") && !segment.relIdx(1).stressed)
                segment.remove();
        });

        word.replace("kʷ", "k", "_ɔ/o/oː/ʊ/u/uː");
        word.replace("gʷ", "g", "_ɔ/o/oː/ʊ/u/uː");

        word.replace("w", "β", "#/V_V");

        word.replace("e", "ɛ");
        word.replace("i", "ɪ");
        word.replace("o", "ɔ");
        word.replace("u", "ʊ");
        word.replace("ʊ", "u", "_ɪ/iː");

        word.forEach(segment => {
            if (segment.value == "j" && segment.relIdx(-1).value == "r" && segment.relIdx(1).match("ɛ", "eː")) {
                segment.relIdx(1).value = "eː";
                segment.remove();
            }

            if (segment.value == "w" && segment.relIdx(1).match("ɔ", "oː")) {
                segment.relIdx(1).value = "oː";
                segment.remove();
            }
        });

        word.forEach(segment => {
            if (
                segment.value == "au̯" && !segment.stressed
                && ((segment.relIdx(1).match("k", "g") && segment.relIdx(2).match("ʊ", "u", "uː"))
                    || (segment.relIdx(1).type == "consonant" && segment.relIdx(2).match("k", "g") && segment.relIdx(3).match("ʊ", "u", "uː")))
            )
                segment.value = "a";
        });

        word.replaceSeq("kʷ", "k,w");
        word.replaceSeq("gʷ", "g,w");

        word.remove("w", "k/g_j");

        word.replace("g", "w", "_m");
        word.replaceSeq("a,w", "au̯");
        word.replaceSeq("au̯,w", "au̯");
        word.remove("w", "uː_");

        word.remove("s", "k_s");

        word.forEach(segment => {
            if (
                segment.value == "k" && segment.relIdx(1).value == "s"
                && !(segment.relIdx(-1).type == "vowel" && segment.relIdx(2).type == "vowel")
                && !(segment == word.at(-2) && segment.relIdx(-1).stressed)
            )
                segment.remove();
        });

        word.replace("eː", "iː", "_s,t,j");
        word.replace("oː", "uː", "_s,t,j");

        //Early syncope
        word.forEach(segment => {
            if (
                segment.value == "ʊ" && !segment.stressed && segment != word.vowels[0]
                && segment.relIdx(-1).match("t", "d", "k", "g") && segment.relIdx(1).match("l", "r") && segment.relIdx(2).type == "vowel"
                && !(word.partOfSpeech == "inf" && segment.relIdx(1).value == "r" && segment == word.at(-3))
            )
                segment.remove();

            if (
                segment.type == "vowel" && !segment.match("a", "aː") && !segment.stressed
                && segment.relIdx(-1).value == "s" && segment.relIdx(1).match("p", "t", "k") && segment.relIdx(-2).type == "vowel"
                && (segment.relIdx(2).type == "vowel" || segment.relIdx(2).match("l", "r"))
            )
                segment.remove();

            if (segment.value == "ɪ" && !segment.stressed && segment == word.vowels.at(-2) && segment.relIdx(-1).match("l", "r", "n") && segment.relIdx(1).match("t", "d") && segment.relIdx(-2).type == "vowel")
                segment.remove();
        });
        word.forEach(segment => {
            if (
                segment.value == segment.relIdx(1).value && !(segment.relIdx(-1).type == "vowel" && segment.relIdx(2).type == "vowel") && segment.type == "consonant" && !segment.relIdx(-1).match("j", "w") && !segment.relIdx(2).match("j", "w")
                && !(segment.relIdx(1).match("p", "t", "k", "b", "d", "g") && segment.relIdx(2).match("l", "r"))
            )
                segment.remove();
        });
        word.forEach(segment => {
            if (segment.value == "m" && segment.relIdx(1).match("l", "r"))
                word.insert("b", segment.i + 1);
        });
        word.replace("l", "ɫ", "_C");
        word.replace("ɫ", "l", "_j/w");
        word.replace("ɫ", "l", "_l");

        word.replace("b", "β", "V_V/w/r");

        word.replace("t", "k", "_l");
        word.replace("d", "g", "_l");
        word.replace("t", "k", "_k,l");
        word.replace("d", "g", "_g,l");

        word.forEach(segment => {
            if (segment.value == "j" && segment.i < word.vowels[0].i && segment.relIdx(-1).type == "consonant" && !segment.relIdx(-1).match("t", "k", "d", "g", "d͡z")) {
                segment.value = "i";
                segment.type = "vowel";
                segment.stressed = false;
            }
        });

        //Palatalization (with gemination in many cases)
        word.forEach(segment => {
            if (segment.type == "consonant" && segment.relIdx(1).value == "j" && segment.value != "j") {
                if (
                    !segment.match("s", "t", "r")
                    && (segment.relIdx(-1).type == "vowel" || (segment.match("p", "t", "k", "b", "d", "g") && segment.relIdx(-1).match("ɫ", "r")))
                )
                    word.insert(segment.value, segment.i);
                segment.value += "ʲ";
                segment.relIdx(1).remove();
            }
        });

        if (word[0].value == "s" && word[1].type == "consonant" && word[1].value != "w")
            word.insert("ɪ", 0);

        if (word.partOfSpeech == "conjVerb" && word.at(-1).value == "r")
            word.at(-1).remove();

        if (word.at(-1).value == "r" && word.at(-2).type == "vowel" && !word.at(-2).stressed && word.at(-3).match("p", "t", "k", "b", "d", "g", "f")) {
            word.insert("r", -2);
            word.at(-1).remove();
        }

        //Allophonic lengthening
        word.forEach(segment => {
            if (segment.type == "vowel" && segment.value.endsWith("ː"))
                segment.value = segment.value[0];

            if (
                segment.type == "vowel" && segment.stressed && segment.value.length == 1
                && !(segment.relIdx(1).type == "consonant" && segment.relIdx(2).type != "vowel" &&
                    !(segment.relIdx(1).match("p", "t", "k", "b", "d", "g", "f", "β") && segment.relIdx(2).match("l", "r", "w")))
            )
                segment.value += "ː";
        });

        word.forEach(segment => {
            if (segment.value == "ɛ" && !segment.stressed)
                segment.value = "e";

            if (segment.value == "ɔ" && !segment.stressed)
                segment.value = "o";
        });

        //Assimilation of /d/
        word.forEach(segment => {
            if (segment.value == "d" && ["m", "n", "p", "t", "k", "b", "d", "g", "f", "β"].includes(segment.relIdx(1).value[0]))
                segment.value = segment.relIdx(1).value[0];
        });

        word.replace("s", "z", "_m/mʲ/n/nʲ/b/bʲ/d/dʲ/g/ɟ/β/βʲ/z/zʲ/l/lʲ/r/rʲ");
        word.replace("z", "s", "s_");

        word.forEach(segment => {
            if (segment.match("p", "k") && segment.relIdx(-1).match("m", "ŋ") && segment.relIdx(1).type == "consonant" && !segment.relIdx(1).match("l", "r", "w"))
                segment.remove();
        });

        word.replace("tʲ", "t͡sʲ");
        word.replace("dʲ", "d͡zʲ");
        word.replace("d͡z", "d͡zʲ", "V/C_");

        word.replace("j", "d͡zʲ", "#_");

        word.replace("kʲ", "c");
        word.replace("gʲ", "ɟ");
        word.replace("k", "c", "_c");
        word.replace("g", "ɟ", "_ɟ");
        word.replace("ŋ", "ɲ", "_c/ɟ");

        word.remove("ɫ", "_nʲ");

        word.forEach(segment => {
            if (segment.value == "j" && segment.relIdx(-1).type == "vowel" && segment.relIdx(1).type == "vowel")
                word.insert("j", segment.i);
        });

        word.replaceSeq("au̯", "a,w");

        word.forEach(segment => {
            if (segment.type == "consonant")
                segment.stressed = false;
        });
        if (word.stressedVowel.relIdx(-1).type == "consonant" && !(word.stressedVowel.relIdx(-1).value == "w" && word.stressedVowel.relIdx(-2).type == "vowel"))
            word.stressedVowel.relIdx(-1).stressed = true;
        if (word.stressedVowel.relIdx(-2).match("p", "t", "k", "b", "d", "g", "f", "β") && word.stressedVowel.relIdx(-1).match("l", "r"))
            word.stressedVowel.relIdx(-2).stressed = true;
        if (word.stressedVowel.relIdx(-2).type == "consonant" && word.stressedVowel.relIdx(-1).value == "w")
            word.stressedVowel.relIdx(-2).stressed = true;
        if (word.stressedVowel.relIdx(-2).value == "s" && word.stressedVowel.relIdx(-1).match("p", "t", "k")
            && word.stressedVowel.relIdx(-3).type == "consonant")
            word.stressedVowel.relIdx(-2).stressed = true;
        if (word.stressedVowel.relIdx(-3).value == "s" && word.stressedVowel.relIdx(-2).match("p", "t", "k")
            && word.stressedVowel.relIdx(-1).match("l", "r") && word.stressedVowel.relIdx(-4).type == "consonant")
            word.stressedVowel.relIdx(-3).stressed = true;
        word.forEach(segment => {
            if (word.vowels[0].stressed && segment.i < word.vowels[0].i)
                segment.stressed = true;
        });

        addRow("LL", "Vulgar Late Latin", "400", getSpelling_lat(), word);
    }

    function LL_to_WR(variety) {
        word = outcomes.LL.duplicate();

        word.replace("nʲ", "ɲ", "V/C_");
        word.replace("n", "ɲ", "_ɲ");
        word.replace("lʲ", "ʎ", "V/C_");
        word.replace("l", "ʎ", "_ʎ");

        word.replace("k", "kʲ", "_ɛ/ɛː/e/eː/ɪ/ɪː/i/iː");
        word.replace("g", "gʲ", "_ɛ/ɛː/e/eː/ɪ/ɪː/i/iː");

        if (variety == "portuguese") {
            word.remove("p", "_pʲ");
            word.remove("b", "_bʲ");
        }

        //Consonant assimilation
        word.replace("p", "s", "_s/sʲ");
        word.replace("d", "s", "_s/sʲ");
        word.replace("r", "s", "_s/sʲ");
        word.replace("p", "t", "_t/t͡sʲ");
        word.replace("b", "d", "_d/d͡zʲ");
        word.replace("b", "β", "_β/βʲ");
        if (variety != "french")
            word.replace("m", "n", "_n/ɲ");
        word.remove("s", "s_C");

        if (variety != "french") {
            word.forEach(segment => {
                if (segment.value == "d͡zʲ" && segment.relIdx(-1).value == "d" && segment.relIdx(-2).type == "consonant" && !(variety == "spanish" && segment.relIdx(-2).match("j", "w"))) {
                    segment.value = "t͡sʲ";
                    segment.relIdx(-1).value = "t";
                }
            });
            word.replace("d͡zʲ", "t͡sʲ", "m/n/ɫ/r_");
        }

        if (variety == "french")
            word.replace("d͡z", "d͡zʲ");

        word.replace("gʲ", "j");
        word.replace("ɟ", "j");
        word.replace("d͡zʲ", "j");
        word.replace("d", "j", "_j");
        word.replace("g", "j", "_j");
        word.replace("ɲ", "n", "_j");
        word.replace("ŋ", "n", "_j");
        word.forEach(segment => {
            if (segment.value == "j" && segment.relIdx(1).value == "j" && segment.relIdx(-1).type == "consonant" && segment.relIdx(-1).value != "w")
                segment.remove();
        });

        word.replace("c", "t͡sʲ");
        word.replace("t͡sʲ", "t", "_t͡sʲ");
        word.replace("ɲ", "n", "_t͡sʲ");
        word.replace("ʎ", "ɫ", "_t͡sʲ");

        //First lenition
        word.replace("f", "β", "V/j/w_V/w/r/rʲ");
        word.replace("fʲ", "βʲ", "V/j/w_V");
        word.replace("s", "z", "V/j/w_V/w");
        word.replace("sʲ", "zʲ", "V/j/w_V");
        word.replace("bʲ", "βʲ", "V/j/w_V");
        word.replace("g", "ɣ", "V/j/w_V/w/r/rʲ");
        word.replace("p", "b", "V/j_V/w/r/rʲ/l");
        word.replace("pʲ", "bʲ", "V/j_V");
        word.replace("k", "g", "V/j_V/w/r/rʲ/l");
        word.replace("kʲ", "gʲ", "V/j_V");
        word.replace("t͡sʲ", "d͡zʲ", "V/j_V");
        //Preceding /w/ prevented voicing of stops in Ibero-Romance
        //Lenition of /t/ and /d/ occurred later in Gallo-Romance
        if (variety == "french") {
            word.replace("p", "b", "w_V/w/r/rʲ/l");
            word.replace("pʲ", "bʲ", "w_V");
            word.replace("k", "g", "w_V/w/r/rʲ/l");
            word.replace("kʲ", "gʲ", "w_V");
            word.replace("t͡sʲ", "d͡zʲ", "w_V");
        } else {
            word.replace("d", "ð", "V/j/w_V/w/r/rʲ/#");
            word.replace("t", "d", "V/j_V/w/r/rʲ/#");
        }

        word.replace("kʲ", "c");
        word.replace("gʲ", "ɟ");
        word.replace("k", "c", "_c");
        word.replace("g", "ɟ", "_ɟ");

        word.replace("d͡z", "d͡zʲ");

        //In early Ibero-Romance, all infinitives are stressed on the penult
        if (variety != "french" && word.partOfSpeech == "inf" && !word.vowels.at(-2)?.stressed && word.at(-3)?.type == "vowel" && word.at(-2).value == "r" && word.at(-1).type == "vowel") {
            if (word.stressedVowel.value.endsWith("ː"))
                word.stressedVowel.value = word.stressedVowel.value[0];

            if (word.stressedVowel.value == "ɛ")
                word.stressedVowel.value = "e";
            else if (word.stressedVowel.value == "ɔ")
                word.stressedVowel.value = "o";

            word.forEach(segment => segment.stressed = false);
            word.vowels.at(-2).stressed = true;

            if (word.stressedVowel.relIdx(-1).type == "consonant" && !(word.stressedVowel.relIdx(-1).value == "w" && word.stressedVowel.relIdx(-2).type == "vowel"))
                word.stressedVowel.relIdx(-1).stressed = true;
            if (word.stressedVowel.relIdx(-2).match("p", "t", "k", "b", "d", "g", "f", "β") && word.stressedVowel.relIdx(-1).match("l", "r"))
                word.stressedVowel.relIdx(-2).stressed = true;
            if (word.stressedVowel.relIdx(-2).type == "consonant" && word.stressedVowel.relIdx(-1).value == "w")
                word.stressedVowel.relIdx(-2).stressed = true;
            word.forEach(segment => {
                if (word.vowels[0].stressed && segment.i < word.vowels[0].i)
                    segment.stressed = true;
            });

            if (
                word.stressedVowel.value.length == 1
                && !(word.stressedVowel.relIdx(1).type == "consonant" && word.stressedVowel.relIdx(2).type != "vowel" &&
                    !(word.stressedVowel.relIdx(1).match("p", "t", "k", "b", "d", "g", "f", "β") && word.stressedVowel.relIdx(2).match("l", "r", "w")))
            )
                word.stressedVowel.value += "ː";
        }
        if (
            variety == "spanish" && word.partOfSpeech == "inf" && word.vowels.at(-2)?.stressed && word.vowels.at(-2).value == "eː"
            && (word.vowels.at(-3)?.match("i", "u") || word.vowels.at(-2).relIdx(-1).value == "j")
        )
            word.vowels.at(-2).value = "iː";

        //Metaphony
        word.forEach(segment => {
            if (segment.stressed && segment == word.vowels.at(-2) && segment.nextVowel().value == "i") {
                if (segment.match("e", "eː", "ɪ", "ɪː"))
                    segment.value = "i" + segment.value.slice(1);

                if (segment.match("o", "oː", "ʊ", "ʊː"))
                    segment.value = "u" + segment.value.slice(1);
            }
        });

        word.replace("g", "ʎ", "V_l/ʎ");
        word.replace("l", "ʎ", "ʎ_");
        word.replace("ŋ", "ɲ", "V_n");
        word.replace("n", "ɲ", "ɲ_");
        if (variety == "french")
            word.replaceSeq("n,j", "ɲ,ɲ");

        //Later syncope
        let approximants = ["l", "ɫ", "ʎ", "r", "rʲ", "j", "w"];
        let nasals = ["m", "mʲ", "n", "ɲ", "ŋ"];
        let sibilants = ["s", "sʲ", "z", "zʲ", "t͡sʲ", "d͡zʲ"];
        let fricatives = ["f", "fʲ", "β", "βʲ", "ð", "ɣ"];
        let stops = ["p", "pʲ", "b", "bʲ", "t", "d", "c", "ɟ", "k", "g"];
        word.slice().reverse().forEach(segment => {
            if (segment.type == "vowel" && !segment.stressed && segment.value != "a" && segment != word.vowels[0] && segment != word.vowels.at(-1) && segment.relIdx(-1).type != "vowel") {
                let newWord = word.duplicate();
                newWord[segment.i].remove();
                let surrounded = s => s.type == "consonant" && s.relIdx(-1).type == "consonant" && s.relIdx(1).type == "consonant"
                    && !((s.relIdx(-1).value.slice(0, -1) || s.relIdx(-1).value) == s.value[0] && s.relIdx(-2).type == "vowel")
                    && !(s.relIdx(1).value[0] == (s.value.slice(0, -1) || s.value) && s.relIdx(2).type == "vowel");

                if (
                    !newWord.some(s => s.match(...approximants, ...fricatives) && surrounded(s) && s.value != "w"
                        && !(s.relIdx(-1).match(...approximants) && s.relIdx(1).match(...approximants)))
                    && !newWord.some(s => s.match(...nasals) && surrounded(s) && !s.relIdx(-1).match(...approximants, ...nasals)
                        && !s.relIdx(1).match(...approximants, ...nasals))
                    && !newWord.some(s => surrounded(s) && !s.relIdx(-1).match(...approximants, ...nasals, ...fricatives, "s", "sʲ", "z", "zʲ")
                        && !s.relIdx(1).match(...approximants, ...nasals, "β", "s", "z")
                        && !(s.match(...stops) && s.relIdx(-1).match(...stops) && s.relIdx(1).match(...stops, "t͡sʲ", "d͡zʲ")))
                    && !newWord.some(s => s.match(...sibilants) && surrounded(s) && !s.relIdx(-1).match(...approximants))
                    && !newWord.some(s => surrounded(s) && s.relIdx(-1).match(...sibilants) && s.relIdx(1).match("s", "sʲ", "z", "zʲ"))
                    && !newWord.some(s => s.match(...sibilants) && surrounded(s) && !s.relIdx(1).match(...stops, ...sibilants))
                    && !newWord.some(s => s.match("β", "βʲ", "ð", "ɣ", "c", "ɟ") && surrounded(s))
                    && !newWord.some(s => s.match("f", "fʲ", "j") && s.relIdx(-1).type == "consonant" && s.relIdx(-1).value[0] != s.value[0]
                        && !s.relIdx(-1).match(...approximants, ...nasals, "s", "sʲ", "z", "zʲ"))
                    && !newWord.some(s => s.match("f", "fʲ") && s.relIdx(1).type == "consonant" && !s.relIdx(1).match("f", "fʲ", "l", "ɫ", "ʎ", "r", "rʲ"))
                    && !newWord.some(s => s.match("β", "βʲ") && s.relIdx(-1).match(...stops, "t͡sʲ", "d͡zʲ"))
                    && !newWord.some(s => s.match("ð", "ɣ") && s.relIdx(-1).match(...stops, ...nasals, "l", "ɫ"))
                    && !newWord.some(s => s.match("l", "ʎ") && s.relIdx(-1).match("t", "d") && s.relIdx(-2).type == "consonant")
                    && !newWord.some(s => s.match("l", "ʎ") && s.relIdx(-1).match("c", "ɟ"))
                    && !(segment.relIdx(-1).value == "w" && segment.relIdx(1).value == "r")
                    && !(segment.relIdx(1).match("β", "βʲ") && segment.relIdx(-1).match(...stops))
                    && !(segment.relIdx(-1).match("k", "g") && segment.relIdx(1).match("t", "d", ...sibilants))
                    && !(segment.relIdx(1).match("k", "g") && segment.relIdx(2).match("t", "d", "t͡sʲ", "d͡zʲ"))
                    && !(segment.relIdx(1).value == "ɲ" && !segment.relIdx(-1).match(...nasals))
                    && !(segment.relIdx(1).match(...nasals) && segment.relIdx(2).value == "ɲ" && !segment.relIdx(-1).match(...nasals))
                    && !(segment.relIdx(1).value == "ʎ" && !segment.relIdx(-1).match("l", "ɫ", "ʎ"))
                    && !(segment.relIdx(1).value == "j" && segment.relIdx(2).value == "j")
                    && !(segment.relIdx(1).value == "t" && segment.relIdx(2).value == "t͡sʲ" && segment.relIdx(-1).match(...stops))
                    && !(variety != "french" && newWord.some(s => s.match(...nasals) && surrounded(s) && !s.relIdx(1).match(...nasals)))
                    && !(variety != "french" && newWord.some(s => s.match(...stops) && surrounded(s) && s.relIdx(1).value == "m"))
                    && !(variety != "french" && segment == word.vowels.at(-2) && segment.relIdx(2).match("e", "i") && !segment.relIdx(1).match("n", "ɟ")
                        && !segment.relIdx(-1).match("m") && !(segment.relIdx(1).value == "r" && segment.relIdx(-2).value != "r"))
                    && !(variety != "french" && segment.relIdx(-1).value == "j" && segment.relIdx(-2).value == "j")
                    && !(variety != "french" && segment.relIdx(-1).match("c", "ɟ") && segment.relIdx(1).value == "r")
                    && !(variety != "french" && segment.relIdx(-1).match("β", "βʲ") && !segment.relIdx(1).match(...approximants) && segment.i < word.stressedVowel.i)
                    && variety != "portuguese"
                )
                    segment.remove();

                if (
                    variety == "portuguese" && segment.match("e", "ɪ", "i")
                    && (
                        segment.relIdx(-1).match("m", "l", "r")
                        || (segment.relIdx(-1).value == "ɟ" && segment.relIdx(1).value == "d")
                        || (segment.relIdx(-1).match("d", "ð") && segment.relIdx(1).value == "ɟ")
                        || (segment.relIdx(-1).value == "n" && segment.prevVowel().stressed)
                    )
                    && !(segment.relIdx(-1).value == "m" && segment.relIdx(1).value == "n")
                    && segment.relIdx(1).value != "ð"
                    && !newWord.some(s => s.match(...approximants, ...nasals) && surrounded(s))
                )
                    segment.remove();
            }
        });
        if (variety == "french") {
            word.replace("ɟ", "j", "_C");
            word.replace("g", "j", "V,t/d_");
        }
        word.replace("t", "c", "_c");
        word.replace("d", "ɟ", "_ɟ");
        word.replace("ð", "ɟ", "_ɟ");

        //Voicing assimilation
        word.forEach(segment => {
            if (segment.relIdx(-1).match("p", "pʲ", "t", "c", "k", "t͡sʲ", "f", "fʲ", "s", "sʲ")) {
                switch (segment.value) {
                    case "b":
                        segment.value = "p";
                        break;
                    case "bʲ":
                        segment.value = "pʲ";
                        break;
                    case "d":
                        segment.value = "t";
                        break;
                    case "ɟ":
                        segment.value = "c";
                        break;
                    case "g":
                        segment.value = "k";
                        break;
                    case "d͡zʲ":
                        segment.value = "t͡sʲ";
                        break;
                    case "β":
                        segment.value = "f";
                        break;
                    case "βʲ":
                        segment.value = "fʲ";
                        break;
                    case "z":
                        segment.value = "s";
                        break;
                    case "zʲ":
                        segment.value = "sʲ";
                        break;
                }
            }

            if (segment.relIdx(-1).match("b", "bʲ", "d", "ɟ", "g", "d͡zʲ", "β", "βʲ", "z", "zʲ")) {
                switch (segment.value) {
                    case "p":
                        segment.value = "b";
                        break;
                    case "pʲ":
                        segment.value = "bʲ";
                        break;
                    case "t":
                        segment.value = "d";
                        break;
                    case "c":
                        segment.value = "ɟ";
                        break;
                    case "k":
                        segment.value = "g";
                        break;
                    case "t͡sʲ":
                        segment.value = "d͡zʲ";
                        break;
                    case "f":
                        segment.value = "β";
                        break;
                    case "fʲ":
                        segment.value = "βʲ";
                        break;
                    case "s":
                        segment.value = "z";
                        break;
                    case "sʲ":
                        segment.value = "zʲ";
                        break;
                }
            }
        });

        //Middle consonant loss
        for (let i = 0; i < word.length; i++) {
            let segment = word[i];
            if (
                segment.type == "consonant" && segment.relIdx(-1).type == "consonant" && segment.relIdx(1).type == "consonant"
                && !segment.relIdx(-1).match("j", "w") && segment.relIdx(1).value != "w"
                && !(segment.relIdx(1).match(...approximants) && !segment.match(...approximants, ...nasals))
                && !(segment.match(...sibilants) && segment.relIdx(-1).match(...approximants, ...nasals))
                && !(segment.relIdx(-1).match(...approximants, ...nasals) && !segment.match(...approximants, ...nasals) && segment.value == segment.relIdx(1).value[0])
                && !(segment.value == "m" && segment.relIdx(1).value == "n" && segment.relIdx(-1).match(...approximants))
                && !(segment.relIdx(-1).match(...nasals) && segment.match(...stops) && segment.relIdx(1).value == "n")
            ) {
                segment.remove();
                i--;
            }

            if (
                segment.type == "consonant" && segment.value == segment.relIdx(1).value[0]
                && !((segment.relIdx(-1).type == "vowel" || segment.relIdx(-1).match(...approximants, ...nasals))
                    && (segment.relIdx(2).type == "vowel" || segment.relIdx(2).value == "w"
                        || (segment.relIdx(1).match(...stops, "f", "fʲ") && segment.relIdx(2).match(...approximants))))
            ) {
                segment.remove();
                i--;
            }
        }
        word.forEach(segment => {
            if (segment.value == segment.relIdx(1).value[0] + "ʲ") {
                segment.value = segment.value[0];
                segment.relIdx(1).value += "ʲ";
            }
        });
        word.forEach(segment => {
            if (segment.match("m", "mʲ") && segment.relIdx(1).match("l", "r", "rʲ"))
                word.insert("b", segment.i + 1);

            if (segment.match("s", "sʲ") && segment.relIdx(1).match("r", "rʲ"))
                word.insert("t", segment.i + 1);

            if (segment.match("z", "zʲ") && segment.relIdx(1).match("r", "rʲ"))
                word.insert("d", segment.i + 1);
        });
        word.forEach(segment => {
            if (segment.match(...stops, ...fricatives) && segment.relIdx(1).match(...approximants) && segment.relIdx(1).stressed && !(segment.match("t", "d", "ð") && segment.relIdx(1).value == "l"))
                segment.stressed = true;
        });

        word.replace("l", "ɫ", "_C");
        word.replace("ɫ", "l", "_l");
        word.replace("n", "ŋ", "_k/g");
        word.replace("n", "ɲ", "_c/ɟ/ɲ");
        word.replace("ŋ", "ɲ", "_c/ɟ");
        word.replace("ɫ", "ʎ", "_c/ɟ/ʎ");
        word.replace("s", "z", "_m/mʲ/n/ɲ/l/ʎ/r/rʲ/b/bʲ/d/ɟ/g/β/βʲ/ð/ɣ/z/zʲ");
        word.replace("b", "β", "_d");
        word.replace("ð", "d", "_d/d͡zʲ");
        word.replace("sʲ", "s", "_t͡sʲ");
        word.replace("zʲ", "z", "_d͡zʲ");
        word.replace("s", "sʲ", "_c");
        word.replace("z", "zʲ", "_ɟ");
        word.replaceSeq("t,s", "t͡sʲ");
        word.replaceSeq("t,sʲ", "t͡sʲ");
        word.replaceSeq("d,z", "d͡zʲ");
        word.replaceSeq("d,zʲ", "d͡zʲ");
        word.remove("s", "c/t͡sʲ_");
        word.remove("sʲ", "c/t͡sʲ_");
        word.remove("z", "ɟ/d͡zʲ_");
        word.remove("zʲ", "ɟ/d͡zʲ_");

        word.replaceSeq("ɫ,j", "ʎ,ʎ");
        if (variety == "french")
            word.replaceSeq("n,j", "ɲ,ɲ");

        if (variety == "french") {
            word.replace("k", "t", "_t͡sʲ");
            word.replace("g", "d", "_d͡zʲ");
        }

        if (variety == "french") {
            word.replace("d", "ð", "V/j/w_V/w/r/rʲ/#");
            word.replace("t", "d", "V/j/w_V/j/w/r/rʲ/#");
        }

        //Palatalization of velars before coronals
        word.forEach(segment => {
            if (segment.match("k", "g") && (segment.relIdx(-1).type == "vowel" || segment.relIdx(-1).value == "w") && segment.relIdx(1).match("t", "d", "t͡sʲ", "d͡zʲ", "s", "sʲ", "z", "zʲ"))
                segment.value = "j";

            if (segment.value == "ŋ" && segment.relIdx(1).match("t", "d", "t͡sʲ", "d͡zʲ", "s", "sʲ", "z", "zʲ"))
                segment.value = "ɲ";
        });

        word.forEach(segment => {
            if (segment.value == "ŋ" && !segment.relIdx(1).match("k", "g"))
                segment.value = "n";
        });

        if (variety == "portuguese" && word.vowels.at(-3)?.value == "ɛ" && word.vowels.at(-3).stressed && word.vowels.at(-2).value == "ɪ")
            word.vowels.at(-3).value = "e";

        if (word.stressedVowel.relIdx(-1).match("ʎ", "ɲ"))
            word.stressedVowel.relIdx(-2).stressed = false;
        if (word.stressedVowel.relIdx(-2).value == "s" && word.stressedVowel.relIdx(-1).match(...stops))
            word.stressedVowel.relIdx(-2).stressed = false;

        word.replace("s", "s̺");
        word.replace("z", "z̺");
        word.replace("sʲ", "s̺ʲ");
        word.replace("zʲ", "z̺ʲ");

        outcomes.WR = word.duplicate();
    }

    function WR_to_IR() {
        word = outcomes.WR.duplicate();

        word.forEach(segment => {
            if (segment.value.endsWith("ː"))
                segment.value = segment.value[0];
        });

        word.replace("ɪ", "i", "_ɲ,t/t͡sʲ");
        word.replace("ʊ", "u", "_ɲ,t/t͡sʲ");

        word.replace("c", "t͡sʲ");
        word.replace("ɟ", "d͡zʲ");
        word.replace("t͡sʲ", "t", "_t͡sʲ");
        word.replace("d͡zʲ", "d", "_d͡zʲ");
        word.replace("ɲ", "n", "_t͡sʲ/d͡zʲ");
        word.replace("ʎ", "ɫ", "_t͡sʲ/d͡zʲ");
        word.replace("s̺ʲ", "s̺", "_t͡sʲ");
        word.replace("z̺ʲ", "z̺", "_d͡zʲ");

        if (word.at(-1).type == "consonant" && word.at(-2).type == "consonant" && !word.at(-2).match("j", "w"))
            word.at(-1).remove();
        word.replace("m", "n", "_#");
        word.replace("ɲ", "n", "_#");
        word.replace("ŋ", "n", "_#");

        word.forEach(segment => {
            if (segment.match("p", "t", "k") && segment.relIdx(1).match("p", "t", "k", "t͡sʲ"))
                segment.value = segment.relIdx(1).value[0];
        });

        word.replace("ɫ", "j", "ʊ_t/s̺");

        if (word.vowels.at(-1).value == "ʊ" && !word.vowels.at(-1).stressed)
            word.vowels.at(-1).value = "u";

        word.replace("ɪ", "e");
        word.replace("ʊ", "o");

        if ((word.partOfSpeech == "inf" || word.partOfSpeech == "conjVerb") && word.stressedVowel.relIdx(-1).value == "w" && word.stressedVowel.relIdx(-2).type == "consonant" && !word.stressedVowel.relIdx(-2).match("k", "g"))
            word.stressedVowel.relIdx(-1).remove();

        word.forEach(segment => {
            if (segment.match("a", "ɔ", "o") && segment.relIdx(1).match("p", "t", "b", "d", "f", "β", "s̺", "z̺") && segment.relIdx(2).value == "w") {
                segment.relIdx(2).remove();
                word.insert("w", segment.i + 1);
            }
        });
        word.replace("ɔ", "o", "_w");
        word.remove("w", "o_");

        word.forEach(segment => {
            if (segment.type == "vowel" && segment.stressed && segment.relIdx(1).match("e", "i")) {
                segment.relIdx(1).value = "j";
                segment.relIdx(1).type = "consonant";
            }

            if (segment.type == "vowel" && segment.stressed && segment.value != "i" && segment.relIdx(1).match("o", "u")) {
                segment.relIdx(1).value = "w";
                segment.relIdx(1).type = "consonant";
            }
        });

        word.remove("j", "ɛ/e/i_j");
        word.remove("j", "V/w_V");

        word.replace("ɛ", "i", "_a");
        word.replace("ɔ", "u", "_a");
        word.forEach(segment => {
            if (segment.value == "e" && segment.relIdx(1).value == "a" && segment.stressed)
                segment.value = "i";

            if (segment.value == "o" && segment.relIdx(1).value == "a" && segment.stressed)
                segment.value = "u";
        });

        word.forEach(segment => {
            if (segment.value == "w" && segment.relIdx(-1).value == "k" && !(segment.relIdx(1).value == "a" && segment.i >= word.stressedVowel.i - 1))
                segment.remove();

            if (segment.value == "w" && segment.relIdx(-1).value == "g" && segment.relIdx(1).value != "a")
                segment.remove();
        });

        word.forEach(segment => {
            if (segment.value == "o" && segment.relIdx(1).value == "j" && segment.relIdx(2).type == "consonant" && segment.relIdx(2).value != "j")
                segment.value = "u";
        });

        word.forEach(segment => {
            if ((segment.match("s̺ʲ", "z̺ʲ", "rʲ") || (segment.value == "s̺" && segment.relIdx(1).value == "s̺ʲ")) && segment.relIdx(-1).type == "vowel") {
                if (segment.relIdx(-1).value != "i")
                    word.insert("j", segment.i);
                if (segment.value == "s̺" && segment.relIdx(1).value == "s̺ʲ")
                    segment.relIdx(1).value = "s̺";
                else if (segment.value.endsWith("ʲ"))
                    segment.value = segment.value.slice(0, -1);
            }
        });

        word.replace("s̺", "ʃ", "j_V/s̺");
        word.replace("s̺", "ʃ", "ʃ_");

        word.forEach(segment => {
            if (segment.value == "j" && segment.relIdx(-1).value == "i" && segment.relIdx(1).type != "vowel" && segment.relIdx(1).value != "j")
                segment.remove();

            if (segment.value == "w" && segment.relIdx(-1).value == "u")
                segment.remove();
        });

        word.forEach(segment => {
            if (
                segment.value == "ð" && (segment.relIdx(-1).type == "vowel" || segment.relIdx(-1).match("j", "w"))
                && (segment.relIdx(1).type == "vowel" || segment.relIdx(1).match("l", "r"))
                && !(segment.relIdx(-1).match("a", "ɔ", "o", "u") && segment.relIdx(1).match("a", "ɔ", "o", "u"))
            )
                segment.remove();
        });

        word.forEach(segment => {
            if (segment.value.endsWith("ʲ") && !segment.match("t͡sʲ", "d͡zʲ")) {
                if (segment.relIdx(1).type == "vowel")
                    word.insert("j", segment.i + 1);
                segment.value = segment.value.slice(0, -1);
            }
        });

        word.forEach(segment => {
            if (segment.match("e", "i") && segment.relIdx(1).type == "vowel" && segment.prevVowel().stressed) {
                segment.value = "j";
                segment.type = "consonant";
            }
        });

        word.forEach(segment => {
            if (segment.value == "j" && segment.relIdx(-1).type == "consonant" && segment.relIdx(1) == word.vowels[0]) {
                segment.value = "i";
                segment.type = "vowel";
                segment.relIdx(-1).stressed = false;
                segment.relIdx(-2).stressed = false;
            }
        });

        word.remove("g", "#_l");

        word.replace("l", "ʎ", "p/k/f_");

        word.replaceSeq("ŋ,g,l", "ɲ,ʎ");

        word.forEach(segment => {
            if (segment.value == "r" && !segment.relIdx(1).value.startsWith("r") && !segment.relIdx(-1).match("r", "s̺", "z̺", "t͡sʲ", "d͡zʲ") && segment.i != 0)
                segment.value = "ɾ";
        });
        word.forEach(segment => {
            if (segment.value == "ɾ" && segment.relIdx(-1).value == "m")
                word.insert("b", segment.i);

            if (segment.value == "ɾ" && segment.relIdx(-1).match("ɫ", "n", "ɲ"))
                word.insert("d", segment.i);

            if (segment.value == "ɾ" && segment.stressed && segment.relIdx(-1).match("b", "d"))
                segment.relIdx(-1).stressed = true;
        });

        word.replace("z̺", "s̺", "_#/p/t/k/t͡sʲ/s̺");
        word.replace("s̺", "z̺", "_m/n/ɲ/b/d/g/d͡zʲ/β/ð/ɣ/l/ʎ/r");
        word.replace("d͡zʲ", "t͡sʲ", "_#/p/t/k/t͡sʲ/s̺");
        word.replace("t͡sʲ", "d͡zʲ", "_m/n/ɲ/b/d/g/d͡zʲ/β/ð/ɣ/l/ʎ/r");

        //Nasal assimilation
        word.replace("m", "n", "_t/d/t͡sʲ/d͡zʲ/s̺/z̺/t͡ʃ/ʃ/β/ð/h");
        word.replace("m", "ŋ", "_k/g/ɣ");
        word.replace("m", "ɲ", "_ɲ");
        word.replace("n", "m", "_p/b");
        word.replace("ɲ", "n", "_t/d/t͡sʲ/d͡zʲ/s̺/z̺/t͡ʃ/ʃ/β/ð/h");

        word.replace("ʎ", "ɫ", "_C");
        word.replace("ɫ", "ʎ", "_ʎ");

        word.replace("n", "ɫ", "_m");

        word.remove("k", "_#");
        word.remove("b", "_#");

        //Degemination
        word.forEach(segment => {
            if (segment.type == "consonant" && segment.value == segment.relIdx(1).value[0] && !segment.relIdx(1).match("m", "n", "ɲ", "l", "ʎ", "r", "t͡sʲ", "d͡zʲ"))
                segment.remove();
        });

        word.replace("a", "e", "_j,C/#");
        word.replace("a", "o", "_w");

        if (word.stressedVowel.relIdx(-1).type == "consonant" && word.stressedVowel.relIdx(-1).value != "w")
            word.stressedVowel.relIdx(-1).stressed = true;
        word.forEach(segment => {
            if (word.vowels[0].stressed && segment.i < word.vowels[0].i)
                segment.stressed = true;
        });

        addRow("IR", "Ibero-Romance", "800", "", word, true);
    }

    function IR_to_OSp() {
        word = outcomes.IR.duplicate();

        word.replace("t͡sʲ", "t͡s");
        word.replace("d͡zʲ", "d͡z");

        word.remove("s̺", "_t͡s");
        word.remove("z̺", "_d͡z");

        word.forEach(segment => {
            if (segment.value == "j" && segment.relIdx(-1).value == "n" && segment.relIdx(-2).type == "vowel" && ((word.partOfSpeech == "inf" && segment.nextVowel().stressed) || (word.partOfSpeech == "conjVerb" && segment.prevVowel().stressed))) {
                segment.relIdx(-1).value = "ɲ";
                segment.remove();
            }
        });
        word.replace("j", "d͡z", "V,ɾ/n_");

        //Pre-yod raising
        word.vowels.forEach((segment, i) => {
            if (segment.relIdx(1).match("j", "ʎ", "ɲ")) {
                switch (segment.value) {
                    case "ɛ":
                        segment.value = "e";
                        break;
                    case "ɔ":
                        segment.value = "o";
                        break;
                }
            } else if (segment.nextVowel().relIdx(-1).value == "j" && segment.relIdx(1).value != "w") {
                switch (segment.value) {
                    case "ɛ":
                        segment.value = "e";
                        break;
                    case "e":
                        segment.value = "i";
                        break;
                    case "ɔ":
                        segment.value = "o";
                        break;
                    case "o":
                        segment.value = "u";
                        break;
                }
            }
        });

        word.replace("ɛ", "ie̯");
        word.replace("ɔ", "ue̯");

        word.remove("j", "e_C");
        word.remove("w", "o_");

        word.replace("f", "ɸ");

        if (word[0].value == "j" && word[1].value == "a" && !word[1].stressed)
            word[1].value = "e";

        if (word[0].value == "j" && word[1].match("e", "i") && !word[1].stressed)
            word[0].remove();

        word.vowels.forEach(segment => {
            if (segment.value == "e" && segment.nextVowel().stressed && segment.nextVowel().relIdx(-1).match("j", "ɲ") && segment.relIdx(1).value != "j")
                segment.value = "i";

            if (segment.value == "o" && segment.nextVowel().stressed && (segment.nextVowel().relIdx(-1).match("j", "ɲ") || (segment.relIdx(1).value == "j" && segment.relIdx(2).type == "vowel")))
                segment.value = "u";
        });
        word.remove("j", "i_C");

        word.replace("t", "t͡ʃ", "j_V");

        word.remove("p", "_ʎ");
        word.remove("k", "_ʎ");
        word.remove("ɸ", "_ʎ");

        word.remove("ʎ", "ɲ_");

        word.replace("ʎ", "ʒ", "V/C_");

        word.forEach(segment => {
            if (segment.value == "ʒ" && segment.relIdx(-1).type == "consonant" && !segment.relIdx(-1).match("ʒ", "j", "w"))
                segment.value = "t͡ʃ";
        });
        word.replace("m", "n", "_t͡ʃ");
        word.replace("ŋ", "n", "_t͡ʃ");

        word.remove("s̺", "_t͡ʃ");

        word.remove("w", "n_e/i/ie̯");
        word.replaceSeq("n,w", "ŋ,g,w");
        if (word.stressedVowel.relIdx(-3).value == "ŋ")
            word.stressedVowel.relIdx(-3).stressed = false;

        word.replace("a", "o", "_w");

        word.replaceSeq("l,l", "ʎ,ʎ");
        word.replaceSeq("n,n", "ɲ,ɲ");

        //Degemination
        word.forEach(segment => {
            if (segment.type == "consonant" && (segment.value == segment.relIdx(1).value || segment.value == segment.relIdx(1).value[0]))
                segment.remove();
        });

        if (word[0].value == "j" && (word[1].match("o", "u", "ue̯") || (word[1].value == "a" && !word[1].stressed)))
            word[0].value = "ʒ";

        if (!word.vowels.at(-1).stressed) {
            if (word.vowels.at(-1).value == "i")
                word.vowels.at(-1).value = "e";

            if (word.vowels.at(-1).value == "u")
                word.vowels.at(-1).value = "o";
        }

        //Loss of final /e/
        if (
            word.partOfSpeech != "conjVerb" && word.at(-1).value == "e" && !word.at(-1).stressed
            && word.at(-2).match("l", "ɾ", "n", "s̺", "z̺", "t͡s", "d͡z", "d", "ð", "j", "w", "ʎ", "ɲ")
            && (word.at(-3).type == "vowel" || (word.at(-4).type == "vowel" && word.at(-3).match("j", "w")))
        )
            word.at(-1).remove();
        if (word.partOfSpeech != "conjVerb" && word.at(-1).value == "e" && !word.at(-1).stressed && word.at(-2).type == "vowel")
            word.at(-1).remove();
        word.replace("ʎ", "l", "_#");
        word.replace("ɲ", "n", "_#");
        word.replace("z̺", "s̺", "_#");
        word.replace("d͡z", "t͡s", "_#");

        if (word.stressedVowel.value == "i" && word.stressedVowel.prevVowel().value == "i")
            word.stressedVowel.prevVowel().value = "e";

        word.remove("j", "o/u_t͡s/d͡z/t͡ʃ/s̺/z̺/ʃ/ʒ");

        word.forEach(segment => {
            if (segment.value == "o" && segment.relIdx(1).value == "j" && segment.relIdx(2).type == "consonant") {
                if (segment.nextVowel().stressed) {
                    segment.value = "u";
                } else {
                    segment.value = "ue̯";
                    segment.relIdx(1).remove();
                }
            }
        });

        word.forEach(segment => {
            if (segment.value == "ie̯") {
                word.insert("j", segment.i);
                if (segment.stressed)
                    segment.relIdx(-1).stressed = true;
                segment.value = "e";
            }

            if (segment.value == "ue̯") {
                word.insert("w", segment.i);
                if (segment.stressed)
                    segment.relIdx(-1).stressed = true;
                segment.value = "e";
            }

            if (segment.value == "e" && segment.relIdx(1).value == "w") {
                segment.value = "j";
                segment.type = "consonant";
                segment.relIdx(1).value = "o";
                segment.relIdx(1).type = "vowel";
                if (segment.stressed)
                    segment.relIdx(1).stressed = true;
            }
        });
        word.remove("j", "j_");
        word.forEach(segment => {
            if (segment.value == "u" && segment.relIdx(1).value == "j" && segment.relIdx(2).type != "vowel" && !segment.stressed) {
                segment.value = "w";
                segment.type = "consonant";
                segment.relIdx(1).value = "i";
                segment.relIdx(1).type = "vowel";
            }

            if (segment.value == "i" && segment.relIdx(1).value == "w" && segment.relIdx(2).type != "vowel" && !segment.stressed) {
                segment.value = "j";
                segment.type = "consonant";
                segment.relIdx(1).value = "u";
                segment.relIdx(1).type = "vowel";
            }
        });

        word.forEach(segment => {
            if (segment.value == "i" && !segment.stressed && (segment.relIdx(-1).type == "vowel" || segment.relIdx(1).type == "vowel")) {
                segment.value = "j";
                segment.type = "consonant";
            }

            if (segment.value == "u" && !segment.stressed && (segment.relIdx(-1).type == "vowel" || segment.relIdx(1).type == "vowel")) {
                segment.value = "w";
                segment.type = "consonant";
            }

            if (segment.match("j", "w") && segment.relIdx(1).type == "vowel" && segment.relIdx(1).stressed) {
                segment.stressed = true;
                if (segment.relIdx(-1).type == "consonant")
                    segment.relIdx(-1).stressed = true;
                if (segment.relIdx(-1).match("l", "ɾ") && segment.relIdx(-2).match("p", "t", "k", "b", "d", "g", "β", "ð", "ɣ", "ɸ"))
                    segment.relIdx(-2).stressed = true;
            }
        });

        word.vowels.forEach(segment => {
            if (segment.nextVowel().stressed && segment.nextVowel().relIdx(-1).match("j", "ʎ", "ɲ")) {
                if (segment.value == "e" && segment.nextVowel().value != "i")
                    segment.value = "i";
                else if (segment.value == "o")
                    segment.value = "u";
            }
        });

        word.remove("j", "j/ʎ/ɲ/ʒ_");
        word.remove("w", "w_");
        word.remove("j", "C_w");
        word.remove("w", "C_j");
        word.remove("j", "_i");
        word.remove("w", "_u");

        word.replace("ɸ", "h", "_V");

        word.replace("j", "ʝ", "#/V_V");

        word.replace("n", "ɾ", "m_");
        word.replace("n", "ɾ", "m/n/ŋ,p/t/k/b/d/g_");
        word.forEach(segment => {
            if (segment.value == "ɾ" && segment.relIdx(-1).value == "m") {
                word.insert("b", segment.i);
                if (segment.stressed)
                    segment.relIdx(-1).stressed = true;
            }
        });

        word.remove("t", "t͡s_");
        word.remove("d", "d͡z_");

        word.replace("ɫ", "l");

        word.replace("d", "ð");
        word.replace("g", "ɣ");
        word.replace("ð", "d", "#/n/l_");
        word.replace("ɣ", "g", "#/ŋ_");

        if (word.at(-1).value == "ð" && word.partOfSpeech == "conjVerb")
            word.at(-1).remove();

        if (word.stressedVowel.relIdx(-1).type == "consonant")
            word.stressedVowel.relIdx(-1).stressed = true;
        if (word.stressedVowel.relIdx(-1).value == "ɾ" && word.stressedVowel.relIdx(-2).match("p", "t", "k", "b", "d", "g", "f", "β"))
            word.stressedVowel.relIdx(-2).stressed = true;
        word.forEach(segment => {
            if (word.vowels[0].stressed && segment.i < word.vowels[0].i)
                segment.stressed = true;
        });

        addRow("OSp", "Old Spanish", "1200", getSpelling_OSp(), word);
    }

    function OSp_to_ModSp() {
        word = outcomes.OSp.duplicate();

        word.replace("ɸ", "f");
        word.replace("n", "ɱ", "_f");

        word.forEach(segment => {
            if (segment.match("p", "t", "k") && segment.relIdx(1).match("m", "n", "ɲ"))
                segment.remove();
        });

        word.forEach(segment => {
            if (segment.value == "h") {
                segment.relIdx(1).droppedCons = true;
                segment.remove();
            }
        });

        word.forEach(segment => {
            if (segment.value == "i" && !segment.stressed && (segment.relIdx(-1).type == "vowel" || segment.relIdx(1).type == "vowel")) {
                segment.value = "j";
                segment.type = "consonant";
            }

            if (segment.value == "u" && !segment.stressed && (segment.relIdx(-1).type == "vowel" || segment.relIdx(1).type == "vowel")) {
                segment.value = "w";
                segment.type = "consonant";
            }
        });

        word.forEach(segment => {
            if (segment.value == "e" && segment.relIdx(-1).value == "j" && segment.relIdx(1).value == "ʎ") {
                segment.value = "i";
                segment.relIdx(-1).remove();
                if (segment.stressed && segment.prevVowel().value == "i")
                    segment.prevVowel().value = "e";
            }
        });

        word.remove("j", "ʃ_");

        word.replace("n", "m", "_β");
        word.replace("b", "β");
        word.replace("β", "b", "#/m_");

        word.forEach((segment => {
            if (segment.value == "β" && segment.relIdx(1).type == "consonant" && !segment.relIdx(1).match("j", "w", "l", "ɾ"))
                segment.value = "w";
        }));
        word.forEach(segment => {
            if (segment.value == "i" && segment.relIdx(1).value == "w" && segment.relIdx(2).type != "vowel" && !segment.stressed) {
                segment.value = "j";
                segment.type = "consonant";
                segment.relIdx(1).value = "u";
                segment.relIdx(1).type = "vowel";
            }
        });
        word.remove("w", "o/u_");

        word.replace("d͡z", "z");
        word.replace("t͡s", "s");

        word.replace("z", "s");
        word.replace("z̺", "s̺");
        word.replace("ʒ", "ʃ");

        word.replace("f", "v", "V_m/n/ɲ/l/ɾ/β/ð/ɣ");
        word.replace("s", "z", "_m/n/ɲ/l/r/β/ð/ɣ");
        word.replace("s̺", "z̺", "_m/n/ɲ/l/r/β/ð/ɣ");

        word.replace("ð", "z", "_ɣ");

        //r-l substitution
        let liquids = word.filter(segment => segment.match("l", "ɾ") || (segment.value == "r" && segment.i == 0));
        if (word.stressedVowel.relIdx(1).value == "ɾ" && word.stressedVowel.relIdx(1) == liquids.at(-1))
            liquids.pop();
        if (liquids.length >= 2) {
            let firstLiquid = liquids.at(-2);
            let secondLiquid = liquids.at(-1);
            if (firstLiquid.value == "r") {
                if (!secondLiquid.relIdx(-1).match("t", "d", "ð"))
                    secondLiquid.value = "l";
            } else if (secondLiquid.relIdx(-1).type == "consonant" && secondLiquid.relIdx(-1).value != "ɾ" && firstLiquid.relIdx(-1).type != "consonant") {
                firstLiquid.value = "l";
                secondLiquid.value = "ɾ";
            } else if (!secondLiquid.relIdx(-1).match("t", "d", "ð")) {
                firstLiquid.value = "ɾ";
                secondLiquid.value = "l";
            }
        }
        word.replace("ɾ", "r", "#_");
        word.forEach(segment => {
            if (segment.value == "ɾ" && segment.relIdx(-1).match("n", "z")) {
                word.insert("d", segment.i);
                if (segment.stressed)
                    segment.relIdx(-1).stressed = true;
            }
        });

        word.forEach(segment => {
            if (segment.type == "vowel" && segment.value == segment.relIdx(-1).value && !segment.stressed && !segment.relIdx(-1).stressed)
                segment.remove();
        });

        if (word.stressedVowel.relIdx(-1).type == "consonant")
            word.stressedVowel.relIdx(-1).stressed = true;
        word.forEach(segment => {
            if (word.vowels[0].stressed && segment.i < word.vowels[0].i)
                segment.stressed = true;
        });

        let EModSpWord = word.duplicate();
        addRow("EModSp", "Early Modern Spanish", "1600", getSpelling_EModSp(), word, true);


        word.replace("ʃ", "x");

        word.replace("ʎ", "ʝ");
        word.replace("ʝ", "ɟ͡ʝ", "#/n_");
        word.replace("w", "w̝", "#_");

        word.replace("β", "β̞");
        word.replace("ð", "ð̞");
        word.replace("ɣ", "ɣ̞");

        let beforeSplit = word.duplicate();

        word.replace("s", "θ");
        word.replace("z", "ð");

        word.replace("x", "χ");

        addRow("Spain", "Modern Spanish (Spain)", "2000", getSpelling_ModSp(EModSpWord), word);


        word = beforeSplit;

        word.replace("s̺", "s");
        word.replace("z̺", "z");

        addRow("LatAm", "Modern Spanish (Lat. Am.)", "2000", getSpelling_ModSp(EModSpWord), word, true);
    }

    function IR_to_OGP() {
        word = outcomes.IR.duplicate();

        word.replace("ɣ", "j", "V_ɾ");
        word.forEach(segment => {
            if (segment.value == "a" && segment.relIdx(1).value == "j" && segment.relIdx(2).type != "vowel" && segment.relIdx(2).value != "j")
                segment.value = "e";
        });

        //Pre-yod raising
        word.vowels.forEach((segment, i) => {
            if (segment.relIdx(1).value == "j") {
                switch (segment.value) {
                    case "ɛ":
                        segment.value = "e";
                        break;
                    case "ɔ":
                        segment.value = "o";
                        break;
                }
            } else if (segment.nextVowel().relIdx(-1).value == "j" && segment.relIdx(1).value != "w") {
                switch (segment.value) {
                    case "ɛ":
                        segment.value = "e";
                        break;
                    case "e":
                        segment.value = "i";
                        break;
                    case "ɔ":
                        segment.value = "o";
                        break;
                    case "o":
                        segment.value = "u";
                        break;
                }
            }
        });

        if (word.vowels.at(-3)?.value == "ɛ" && word.vowels.at(-2).value == "i")
            word.vowels.at(-3).value = "i";

        if (word.stressedVowel.prevVowel().value == "e" && word.stressedVowel.relIdx(-1).value == "w")
            word.stressedVowel.prevVowel().value = "i";

        word.replace("ɣ", "g");

        word.replaceSeq("p,ʎ", "t͡ʃ");
        word.replaceSeq("k,ʎ", "t͡ʃ");
        word.replaceSeq("f,ʎ", "t͡ʃ");

        word.remove("s̺", "_t͡ʃ");

        word.replace("b", "β", "ɫ/ɾ_");

        if (word.at(-1).value == "n" && !word.at(-2).stressed && word.partOfSpeech != "conjVerb")
            word.at(-1).remove();

        word.replace("w", "β", "ð/ɫ_");
        word.replace("w", "n", "n_ɛ/e/i");
        word.replaceSeq("n,w", "ŋ,g,w");

        word.replace("ɫ", "w", "a_p/t/t͡sʲ");
        word.replace("a", "o", "_w");

        word.replace("b", "l", "V_l");

        if (word.at(-1).value == "d")
            word.at(-1).remove();

        //Loss of final /e/ and /i/
        if (word.partOfSpeech != "conjVerb" && word.at(-1).match("e", "i") && !word.at(-1).stressed && word.at(-2).match("l", "ɾ", "n", "s̺", "z̺", "t͡sʲ", "d͡zʲ", "j", "w") && word.at(-3).type == "vowel")
            word.at(-1).remove();
        if (word.partOfSpeech == "conjVerb" && word.at(-1).match("e", "i") && !word.at(-1).stressed && word.at(-2).match("ɾ", "d͡zʲ") && (word.at(-3).type == "vowel"))
            word.at(-1).remove();
        word.replace("z̺", "s̺", "_#");
        word.replace("d͡zʲ", "t͡sʲ", "_#");
        word.replace("l", "ɫ", "_#");

        word.replace("e", "i", "_ŋ");
        word.forEach(segment => {
            if (segment.value == "o" && segment.relIdx(1).value == "ŋ" && segment.stressed)
                segment.value = "u";
        });

        //Nasalization
        word.forEach(segment => {
            if (segment.type == "vowel" && segment.relIdx(1).match("m", "n", "ŋ") && (segment.relIdx(2).type != "vowel" || segment.relIdx(1).value == "n") && !segment.relIdx(2).match("m", "n", "j", "w")) {
                if (segment.relIdx(2).value == "i" && segment.relIdx(2).stressed && segment.relIdx(3).type == "vowel")
                    segment.relIdx(2).value += "̃";
                else
                    segment.value += "̃";
                segment.relIdx(1).remove();
            }
        });

        word.remove("ð");
        word.remove("l", "V/j/w_V");

        //Degemination
        word.forEach(segment => {
            if (segment.type == "consonant" && (segment.value == segment.relIdx(1).value || segment.value == segment.relIdx(1).value[0]))
                segment.remove();
        });

        word.replace("l", "ɾ", "p/b/k/g_");

        word.remove("ʎ", "ɲ_");

        if (word[0].value == "e" && word[1]?.value == "j" && !word[0].stressed) {
            word[0].value = "i";
            word[1].remove();
        }

        if (!word.vowels.at(-1).stressed) {
            if (word.vowels.at(-1).value == "i")
                word.vowels.at(-1).value = "e";

            if (word.vowels.at(-1).value == "u" && word.at(-1).type == "consonant")
                word.vowels.at(-1).value = "o";
        }

        word.forEach(segment => {
            if (segment.match("e", "ẽ") && (segment.relIdx(-1).match("i", "ĩ") || segment.relIdx(1).match("i", "ĩ")) && !segment.relIdx(-1).match("e", "ẽ") && !segment.relIdx(1).match("e", "ẽ") && !segment.stressed)
                segment.value = "i" + segment.value.slice(1);
        });

        word.remove("b", "_#");

        word.replaceSeq("s̺,t͡sʲ", "s̺ʲ");

        word.replace("t͡sʲ", "t͡s");
        word.replace("d͡zʲ", "d͡z");

        word.remove("t", "t͡s_");
        word.remove("d", "d͡z_");

        word.forEach(segment => {
            if (segment.type == "consonant" && segment.relIdx(1).value == "j" && !segment.value.endsWith("ʲ") && segment.value != "w") {
                segment.value += "ʲ";
                segment.relIdx(1).remove();
            }
        });

        word.forEach(segment => {
            if (segment.value.endsWith("ʲ")) {
                if (segment.relIdx(-1).type == "vowel" && !segment.relIdx(-1).value.endsWith("̃"))
                    word.insert("j", segment.i);
                segment.value = segment.value.slice(0, -1);
            }
        });
        word.remove("j", "i/ĩ_");

        word.replace("j", "ʒ", "_V");

        word.replace("s̺", "ʃ", "j_V");
        word.replace("z̺", "ʒ", "j_V");

        word.replace("ɛ̃", "ẽ");
        word.replace("ɔ̃", "õ");

        if (word.stressedVowel.relIdx(-1).type == "consonant" && word.stressedVowel.relIdx(-1).value != "w")
            word.stressedVowel.relIdx(-1).stressed = true;

        addRow("OGP", "Old Galician-Portuguese", "1300", getSpelling_OGP(), word);
    }

    function OGP_to_ModPort() {
        word = outcomes.OGP.duplicate();

        word.forEach(segment => {
            if (segment.value == "w" && segment.relIdx(-1).type == "vowel" && segment.relIdx(1).type == "vowel")
                word.insert("β", segment.i + 1);
        });

        word.replace("β", "v");

        word.replace("e", "ɛ", "_ɫ");

        word.replace("ɛ", "e", "_j/w");

        word.replace("õ", "ã", "_#");
        if (word.at(-1).value == "ã")
            word.insert("o", word.length);

        word.replace("a", "ã", "ã_");
        word.replace("e", "ẽ", "ẽ_");
        word.replace("i", "ĩ", "ĩ_");
        word.replace("o", "õ", "õ_");
        word.replace("u", "ũ", "ũ_");

        word.forEach(segment => {
            if (segment.value == "j" && segment.relIdx(-1).value.endsWith("̃") && segment.relIdx(1).match("t", "d", "t͡s", "d͡z"))
                segment.remove();
        });

        //Elimination of hiatus
        for (let i = 0; i < word.length; i++) {
            let segment = word[i];

            if (segment.relIdx(1).type == "vowel" && !segment.stressed) {
                switch (segment.value) {
                    case "a":
                    case "ã":
                        if (segment.value == "a" && segment.relIdx(1).value == "e" && segment.relIdx(1).stressed)
                            segment.relIdx(1).value = "ɛ";
                        else if (segment.value == "a" && segment.relIdx(1).value == "o" && segment.relIdx(1).stressed)
                            segment.relIdx(1).value = "ɔ";
                        else if (segment.relIdx(1).value == "e")
                            segment.relIdx(1).value = "i";
                        else if (segment.relIdx(1).value == "o")
                            segment.relIdx(1).value = "u";
                        else if (segment.relIdx(1).value == "a" && segment.relIdx(1).i < word.stressedVowel.i)
                            segment.relIdx(1).value = "aː";

                        if (segment.relIdx(1).match("a", "ã", "aː", "ɛ", "e", "ẽ", "ɔ", "õ")) {
                            segment.remove();
                            i--;
                        }
                        break;
                    case "e":
                    case "ẽ":
                        if (segment.relIdx(1).match("e", "ẽ") && !(segment.value == "ẽ" && segment.relIdx(2).value == "j")) {
                            if (segment.relIdx(1).value == "e" && segment.relIdx(1).i < word.stressedVowel.i)
                                segment.relIdx(1).value = "eː";
                            segment.remove();
                            i--;
                        } else if (segment.relIdx(1).value == "a" && segment.relIdx(1).nextVowel().stressed) {
                            segment.value = "ɛ";
                            segment.relIdx(1).remove();
                        } else if (!segment.relIdx(1).nextVowel().stressed) {
                            segment.value = "i";
                        }
                        break;
                    case "i":
                    case "ĩ":
                        if (segment.relIdx(1).value == "e" && segment.relIdx(1).stressed) {
                            segment.relIdx(1).value = "ɛ";
                        } else if (segment.relIdx(1).match("i", "ĩ") || (segment.relIdx(1).match("e", "ẽ") && segment.relIdx(1).nextVowel().stressed)) {
                            if (segment.value == "ĩ")
                                segment.relIdx(1).value = "ĩ";
                            else
                                segment.relIdx(1).value = "i";
                            segment.remove();
                            i--;
                        }
                        break;
                    case "o":
                    case "õ":
                        if (segment.relIdx(1).match("o", "õ", "u", "ũ")) {
                            if (segment.value == "õ" && segment.relIdx(1).value == "u" && segment != word.at(-2))
                                segment.relIdx(1).value = "ũ";
                            else if (segment.relIdx(1).value == "o" && segment.relIdx(1).i < word.stressedVowel.i)
                                segment.relIdx(1).value = "oː";
                            segment.remove();
                            i--;
                        } else if (segment.relIdx(1).value == "a" && segment.relIdx(1).nextVowel().stressed) {
                            segment.value = "ɔ";
                            segment.relIdx(1).remove();
                        } else if (!segment.relIdx(1).nextVowel().stressed) {
                            segment.value = "u";
                        }
                        break;
                    case "u":
                    case "ũ":
                        if (segment.relIdx(1).value == "o" && segment.relIdx(1).stressed) {
                            segment.relIdx(1).value = "ɔ";
                        } else if (segment.relIdx(1).match("u", "ũ")) {
                            segment.remove();
                            i--;
                        }
                        break;
                }
            }
            word.remove("j", "i_");
            word.remove("w", "u_");

            if (segment.relIdx(-1).type == "vowel" && (segment.relIdx(-1).stressed || segment.nextVowel().stressed)) {
                switch (segment.value) {
                    case "a":
                        if (segment.relIdx(-1).value == "o" || (segment.relIdx(-1).value == "õ" && segment == word.vowels.at(-2)))
                            segment.relIdx(-1).value = "ɔ";

                        if (segment.relIdx(-1).match("a", "ã", "ɛ", "ɔ"))
                            segment.remove();
                        break;
                    case "e":
                    case "i":
                        if (segment.relIdx(-1).match("e", "ẽ", "i", "ĩ"))
                            segment.remove();
                        else
                            segment.value = "i";
                        break;
                    case "o":
                    case "u":
                        if (segment.relIdx(-1).match("ɔ", "o", "õ", "u", "ũ"))
                            segment.remove();
                        else
                            segment.value = "u";
                        break;
                    case "ã":
                    case "ẽ":
                    case "ĩ":
                    case "õ":
                    case "ũ":
                        if (segment.relIdx(-1).value == segment.value)
                            segment.remove();
                        break;
                }
            }
        }
        word.remove("j", "_j/w");
        word.remove("w", "_j/w");

        word.forEach(segment => {
            if (segment.value == "ĩ" && segment.relIdx(1).match("a", "o") && (segment.stressed || segment.relIdx(1).stressed)) {
                word.insert("ɲ", segment.i + 1);
                segment.value = "i";
            }
        });

        //Syllabification
        if (word.stressedVowel.relIdx(-1).type == "consonant" && !word.stressedVowel.relIdx(-1).match("j", "w"))
            word.stressedVowel.relIdx(-1).stressed = true;
        if (word.stressedVowel.relIdx(-1).value == "ɾ" && word.stressedVowel.relIdx(-2).match("p", "t", "k", "b", "d", "g", "f", "β"))
            word.stressedVowel.relIdx(-2).stressed = true;
        word.forEach(segment => {
            if (word.vowels[0].stressed && segment.i < word.vowels[0].i)
                segment.stressed = true;
        });

        if (word.at(-1).value == "ɾ" && word.vowels.at(-2)?.stressed)
            word.insert("e", word.length);

        //Final raising
        word.forEach(segment => {
            if (segment == word.at(-1) && !segment.stressed) {
                switch (segment.value) {
                    case "a":
                        segment.value = "ɐ";
                        break;
                    case "e":
                        segment.value = "i";
                        break;
                    case "o":
                        segment.value = "u";
                        break;
                }
            }
        });
        word.forEach(segment => {
            if (segment.value == "a" && !segment.stressed)
                segment.value = "ɐ";
        });

        word.replace("ã", "ɐ̃");
        word.forEach(segment => {
            if (segment.value == "a" && segment.relIdx(1).match("m", "n", "ɲ") && segment.stressed)
                segment.value = "ɐ";
        });

        word.replace("aː", "a");
        word.replace("eː", "ɛ");
        word.replace("oː", "ɔ");

        word.forEach(segment => {
            if (segment.value == "i" && !segment.stressed && segment.relIdx(-1).type == "vowel") {
                segment.value = "j";
                segment.type = "consonant";
            }

            if (segment.value == "u" && !segment.stressed && segment.relIdx(-1).type == "vowel" && !(segment.relIdx(-1).match("e", "ẽ") && segment.relIdx(-1).stressed)) {
                segment.value = "w";
                segment.type = "consonant";
            }
        });

        //Denasalization before vowels and certain consonants
        word.forEach(segment => {
            if (segment.value.endsWith("̃") && (segment.relIdx(1).type == "vowel" || segment.relIdx(1).match("ɾ", "m", "n", "ɲ")))
                segment.value = segment.value[0];

            if (segment.value.endsWith("̃") && segment.relIdx(1).match("j", "w") && segment.relIdx(2).match("ɾ", "m", "n", "ɲ"))
                segment.value = segment.value[0];
        });

        word.forEach(segment => {
            if (segment.value == "e" && segment.stressed && segment.relIdx(1).type == "vowel" && segment.relIdx(1).value != "ẽ")
                word.insert("j", segment.i + 1);
        });

        if (word.vowels.at(-1).value == "ẽ")
            word.insert("j", word.vowels.at(-1).i + 1);

        word.replaceSeq("ɫ,n", "l");

        word.remove("j", "u_C");
        word.remove("j", "o_ʃ");

        word.replace("s̺", "s");
        word.replace("z̺", "z");

        word.EModPortWord = word.duplicate();

        word.replace("t͡s", "s");
        word.replace("d͡z", "z");
        word.replace("t͡ʃ", "ʃ");
        word.replace("d͡ʒ", "ʒ");

        word.forEach(segment => {
            if (segment.value.endsWith("̃") && segment.relIdx(1).match("j", "w"))
                segment.relIdx(1).value += "̃";
        });

        //Gemination of intervocalic semivowels
        word.forEach(segment => {
            if (segment.match("j", "w") && segment.relIdx(-1).type == "vowel" && segment.relIdx(1).type == "vowel")
                word.insert(segment.value, segment.i);
        });

        word.replace("r", "ʁ");

        word.replace("ɐ", "ɜ");
        word.replace("ɐ̃", "ɜ̃");

        outcomes.ModPort = word.duplicate();
    }

    function ModPort_to_Port() {
        word = outcomes.ModPort.duplicate();

        word.forEach(segment => {
            if (segment.i != 0 && segment.relIdx(-1).value != "ɫ" && !segment.relIdx(-1).value.endsWith("̃")) {
                switch (segment.value) {
                    case "b":
                        segment.value = "β";
                        break;
                    case "d":
                        segment.value = "ð";
                        break;
                    case "g":
                        segment.value = "ɣ";
                        break;
                }
            }
        });

        word.forEach(segment => {
            if (segment.value == "i" && !segment.stressed && segment.relIdx(1).type == "vowel" && segment.relIdx(-1).value != "ɾ") {
                segment.value = "j";
                segment.type = "consonant";
                if (segment.relIdx(1).stressed) {
                    segment.stressed = true;
                    if (segment.relIdx(-1).type == "consonant")
                        segment.relIdx(-1).stressed = true;
                }
            }

            if (segment.value == "u" && !segment.stressed && segment.relIdx(1).type == "vowel" && segment.relIdx(-1).value != "ɾ") {
                segment.value = "w";
                segment.type = "consonant";
                if (segment.relIdx(1).stressed) {
                    segment.stressed = true;
                    if (segment.relIdx(-1).type == "consonant")
                        segment.relIdx(-1).stressed = true;
                }
            }
        });

        word.forEach(segment => {
            if (segment.value == "s" && segment.relIdx(1).type != "vowel" && !segment.relIdx(1).match("j", "w"))
                segment.value = "ʃ";
        });

        word.forEach(segment => {
            if (segment.value == "e" && !segment.stressed && !segment.relIdx(1).match("j", "w"))
                segment.value = "ɨ";

            if (
                segment.value == "i" && !segment.stressed && !segment.relIdx(1).match("j", "w")
                && (segment.relIdx(-1).match("ʎ", "ɲ", "ʃ", "ʒ") || segment.relIdx(1).match("ʎ", "ɲ", "ʃ", "ʒ") || segment.prevVowel().match("i", "ĩ") || segment.nextVowel().match("i", "ĩ"))
            )
                segment.value = "ɨ";
        });
        if (word.at(-1).value == "i" && !word.at(-1).stressed)
            word.at(-1).value = "ɨ";

        word.forEach(segment => {
            if (segment.value == "o" && !segment.stressed && !segment.relIdx(1).match("j", "w", "ɫ"))
                segment.value = "u";
        });

        if (word[0].value == "ɨ" && !word[0].stressed)
            word[0].value = "i";

        word.replace("l", "ɫ");

        word.remove("w", "o_");

        word.replace("e", "ɜ", "_j/ʎ/ɲ/ʒ");
        word.replace("ẽ", "ɜ̃", "_j̃");

        addRow("Port", "Modern Portuguese (Portugal)", "2000", getSpelling_ModPort(word.EModPortWord), word);
    }

    function ModPort_to_Br() {
        word = outcomes.ModPort.duplicate();

        if (word.stressedVowel.relIdx(1).match("m", "n", "ɲ"))
            word.stressedVowel.value += "̃";
        word.replace("ɛ̃", "ẽ");
        word.replace("ɔ̃", "õ");

        word.forEach(segment => {
            if (segment.value == "ɜ" && !segment.stressed && segment != word.at(-1))
                segment.value = "a";

            if (segment.value == "ɛ" && !segment.stressed)
                segment.value = "e";

            if (segment.value == "ɔ" && !segment.stressed)
                segment.value = "o";
        });

        if (word[0].value == "ẽ" && !word[0].stressed)
            word[0].value = "ĩ";

        word.replace("ɲ", "j̃");

        word.remove("w", "o_");

        word.replace("ɫ", "w", "_C/#");

        word.replace("t", "t͡ʃ", "_i");
        word.replace("d", "d͡ʒ", "_i");

        word.replace("ɾ", "ʁ", "_C/#");
        word.replace("ʁ", "h");
        word.replace("h", "ɦ", "_m/n/j̃/b/d/g/v/z/ʒ/l");
        if (word.partOfSpeech == "inf")
            word.remove("h", "_#");

        if (word.at(-1).value == "s" && word.at(-2).match("a", "ɛ", "e", "ɔ", "o", "u") && word.at(-2).stressed)
            word.insert("j", -1);

        addRow("Br", "Modern Portuguese (Brazil)", "2000", getSpelling_ModPort(word.EModPortWord, "br"), word, true);
    }

    function WR_to_EOF(variety) {
        word = outcomes.WR.duplicate();

        word.remove("j", "V/w_V");

        word.replace("ɪ", "e");
        word.replace("ɪː", "eː");
        word.replace("ʊ", "o");
        word.replace("ʊː", "oː");

        word.replace("ɛ", "ie̯", "_j");
        word.replace("ɔ", "uo̯", "_j");

        addRow("GR", "Gallo-Romance", "600", "", word, true);

        word.replace("ɛː", "ie̯");
        word.replace("ɔː", "uo̯");

        word.replace("ɛ", "e", "_ɲ");
        word.replace("ɔ", "o", "_ɲ");

        word.replace("ɣ", "β", "o/oː_a/aː");

        word.replace("β", "t", "_t/t͡sʲ");
        word.replace("β", "d", "_d/d͡zʲ");

        //Second lenition
        word.replace("b", "β", "V/j/w_V/w/r/rʲ");
        word.replace("bʲ", "βʲ", "V/j/w_V/w/r/rʲ");
        word.replace("d", "ð", "V/j/w_V/w/r/rʲ/#");
        word.replace("g", "ɣ", "V/j/w_V/w/r/rʲ");

        word.forEach(segment => {
            if (segment.type == "vowel" && segment.stressed && segment.relIdx(1).match("e", "i")) {
                segment.relIdx(1).value = "j";
                segment.relIdx(1).type = "consonant";
            }

            if (segment.type == "vowel" && segment.stressed && segment.relIdx(1).match("o", "u")) {
                segment.relIdx(1).value = "w";
                segment.relIdx(1).type = "consonant";
            }
        });

        //Loss of all unstressed penultimate vowels
        if (word.vowels.at(-3)?.stressed)
            word.vowels.at(-2).remove();
        word.forEach(segment => {
            if (segment.value == "ð" && segment.relIdx(-1).type == "consonant" && !segment.relIdx(-1).match("j", "w"))
                segment.remove();
        });
        word.remove("β", "s̺/t͡sʲ_");

        //Voicing assimilation
        word.forEach(segment => {
            if (segment.relIdx(-1).match("p", "pʲ", "t", "c", "k", "t͡sʲ", "f", "fʲ", "s̺", "s̺ʲ")) {
                switch (segment.value) {
                    case "b":
                        segment.value = "p";
                        break;
                    case "bʲ":
                        segment.value = "pʲ";
                        break;
                    case "d":
                        segment.value = "t";
                        break;
                    case "ɟ":
                        segment.value = "c";
                        break;
                    case "g":
                        segment.value = "k";
                        break;
                    case "d͡zʲ":
                        segment.value = "t͡sʲ";
                        break;
                    case "β":
                        segment.value = "f";
                        break;
                    case "βʲ":
                        segment.value = "fʲ";
                        break;
                    case "z̺":
                        segment.value = "s̺";
                        break;
                    case "z̺ʲ":
                        segment.value = "s̺ʲ";
                        break;
                }
            }

            if (segment.relIdx(-1).match("b", "bʲ", "d", "ɟ", "g", "d͡zʲ", "β", "βʲ", "z̺", "z̺ʲ")) {
                switch (segment.value) {
                    case "p":
                        segment.value = "b";
                        break;
                    case "pʲ":
                        segment.value = "bʲ";
                        break;
                    case "t":
                        segment.value = "d";
                        break;
                    case "c":
                        segment.value = "ɟ";
                        break;
                    case "k":
                        segment.value = "g";
                        break;
                    case "t͡sʲ":
                        segment.value = "d͡zʲ";
                        break;
                    case "f":
                        segment.value = "β";
                        break;
                    case "fʲ":
                        segment.value = "βʲ";
                        break;
                    case "s̺":
                        segment.value = "z̺";
                        break;
                    case "s̺ʲ":
                        segment.value = "z̺ʲ";
                        break;
                }
            }
        });

        //Middle consonant loss
        let approximants = ["l", "ɫ", "ʎ", "r", "rʲ", "j", "w"];
        let nasals = ["m", "mʲ", "n", "ɲ", "ŋ"];
        let sibilants = ["s̺", "s̺ʲ", "z̺", "z̺ʲ", "t͡sʲ", "d͡zʲ"];
        let fricatives = ["f", "fʲ", "β", "βʲ", "ð", "ɣ"];
        let stops = ["p", "pʲ", "b", "bʲ", "t", "d", "c", "ɟ", "k", "g"];
        for (let i = 0; i < word.length; i++) {
            let segment = word[i];
            if (
                segment.type == "consonant" && segment.relIdx(-1).type == "consonant" && segment.relIdx(1).type == "consonant"
                && !segment.relIdx(-1).match("j", "w", "β", "ɣ") && segment.relIdx(1).value != "w"
                && !(segment.relIdx(1).match(...approximants) && !segment.match(...approximants, ...nasals))
                && !(segment.match("s̺", "s̺ʲ", "z̺", "z̺ʲ") && segment.relIdx(-1).match(...approximants, ...nasals))
                && !(segment.relIdx(-1).match(...approximants, ...nasals) && !segment.match(...approximants, ...nasals) && segment.value == segment.relIdx(1).value[0])
                && !(segment.value == "m" && segment.relIdx(1).value == "n" && segment.relIdx(-1).match(...approximants))
                && !(segment.relIdx(-1).match(...nasals) && segment.match(...stops) && segment.relIdx(1).value == "n")
            ) {
                segment.remove();
                i--;
            }

            if (
                segment.type == "consonant" && segment.value == segment.relIdx(1).value[0]
                && !((segment.relIdx(-1).type == "vowel" || segment.relIdx(-1).match(...approximants, ...nasals))
                    && (segment.relIdx(2).type == "vowel" || segment.relIdx(2).value == "w"
                        || (segment.relIdx(1).match(...stops, "f", "fʲ") && segment.relIdx(2).match(...approximants))))
            ) {
                segment.remove();
                i--;
            }
        }
        word.forEach(segment => {
            if (segment.value == segment.relIdx(1).value[0] + "ʲ") {
                segment.value = segment.value[0];
                segment.relIdx(1).value += "ʲ";
            }
        });
        word.forEach(segment => {
            if (segment.value == "m" && segment.relIdx(1).match("l", "r", "rʲ"))
                word.insert("b", segment.i + 1);

            if (segment.value == "s̺" && segment.relIdx(1).match("r", "rʲ"))
                word.insert("t", segment.i + 1);

            if (segment.value == "z̺" && segment.relIdx(1).match("r", "rʲ"))
                word.insert("d", segment.i + 1);
        });
        word.forEach(segment => {
            if (segment.match(...stops, ...fricatives) && segment.relIdx(1).match(...approximants) && segment.relIdx(1).stressed && !(segment.match("t", "d", "ð") && segment.relIdx(1).value == "l"))
                segment.stressed = true;
        });

        word.replace("l", "ɫ", "_C");
        word.replace("ɫ", "l", "_l");
        word.replace("n", "ŋ", "_k/g");
        word.replace("s̺", "z̺", "_m/mʲ/n/ɲ/l/ʎ/r/rʲ/b/bʲ/d/ɟ/g/β/βʲ/ð/ɣ/z/zʲ");
        word.replace("ð", "d", "_d/d͡zʲ");
        word.replace("s̺ʲ", "s̺", "_t͡sʲ");
        word.replace("z̺ʲ", "z̺", "_d͡zʲ");

        word.replace("c", "tʲ");
        word.replace("ɟ", "dʲ");
        word.replace("tʲ", "t", "_r");
        word.replace("dʲ", "d", "_r");
        word.replace("ɲ", "n", "_tʲ/dʲ");
        word.replace("ʎ", "ɫ", "_tʲ/dʲ");
        word.replace("tʲ", "t", "_tʲ");
        word.replace("dʲ", "d", "_dʲ");

        word.replaceSeq("ŋ,g,n", "ɲ,ɲ");

        word.replace("w", "β", "n_");
        word.forEach(segment => {
            if (segment.value == "n" && segment.relIdx(1).value == "β")
                segment.stressed = false;
        });

        word.replaceSeq("ɫ,w", "l,l");
        word.replace("w", "s̺", "s̺_");
        word.forEach(segment => {
            if (segment.type == "consonant" && segment.relIdx(1).value == "w" && segment.relIdx(-1).type == "vowel" && segment.value != "ɣ")
                segment.value = "w";
        });

        word.forEach(segment => {
            if (segment.value == "β" && segment.relIdx(1).type == "consonant" && !(segment.relIdx(1).match("β", "βʲ", "r", "rʲ") && segment.relIdx(2).type == "vowel")) {
                if (segment.relIdx(-1).match("ɔ", "uo̯", "o", "oː", "u", "uː", "w"))
                    segment.remove();
                else
                    segment.value = "w";
            }
        });
        word.remove("β", "C_C");

        word.forEach(segment => {
            if (segment.type == "vowel" && segment.value.endsWith("ː"))
                segment.value = segment.value[0];

            if (
                segment.type == "vowel" && segment.stressed && segment.value.length == 1 && !segment.match("ɛ", "ɔ")
                && !(segment.relIdx(1).type == "consonant" && segment.relIdx(2).type != "vowel"
                    && !(segment.relIdx(1).match("p", "b", "t", "d", "k", "g", "f", "β", "ð", "ɣ")
                        && segment.relIdx(2).match("l", "r", "rʲ", "w") && !(segment.relIdx(1).match("t", "d", "ð") && segment.relIdx(2).value == "l")))
            )
                segment.value += "ː";
        });
        word.replace("aː", "a", "_b,l");

        if (variety != "norman") {
            word.replace("k", "t͡ʃ", "_a/aː");
            word.replace("g", "d͡ʒ", "_a/aː");
            word.replace("k", "t", "_t͡ʃ");
            word.replace("g", "d", "_d͡ʒ");
        }

        word.forEach(segment => {
            if (segment.value == "ɣ" && segment.relIdx(-1).value == "e" && segment.relIdx(1).value == "r" && segment.i < word.stressedVowel.i)
                segment.remove();
        });

        word.forEach(segment => {
            if (segment.value == "ɣ" && !segment.relIdx(-1).match("ɔ", "uo̯", "o", "oː", "u", "uː", "w") && !segment.relIdx(1).match("ɔ", "uo̯", "o", "oː", "u", "uː", "w"))
                segment.value = "j";

            if (segment.value == "ɣ" && !segment.relIdx(-1).match("ɔ", "uo̯", "o", "oː", "u", "uː", "w") && segment.relIdx(-1).stressed && segment.relIdx(1).value == "w" && variety != "norman")
                segment.value = "j";
        });
        word.remove("j", "C_C");

        word.replace("k", "j", "a/ɛ/e/i_#");

        word.remove("j", "_j");

        word.replace("g", "j", "d_");

        word.replace("t͡sʲ", "s̺ʲ", "_C");
        word.replace("d͡zʲ", "z̺ʲ", "_C");

        word.replace("ɲ", "mʲ", "m_");

        word.replace("pʲ", "t͡ʃ");
        word.replace("bʲ", "d͡ʒ");
        word.replace("fʲ", "t͡ʃ");
        word.replace("βʲ", "d͡ʒ");
        word.replace("p", "t", "_t͡ʃ");
        word.replace("b", "d", "_d͡ʒ");
        word.replace("f", "t", "_t͡ʃ");
        word.replace("β", "d", "_d͡ʒ");
        word.replaceSeq("mʲ", "n,d͡ʒ");
        word.remove("n", "#/C_d͡ʒ");
        word.forEach(segment => {
            if (segment.value == "n" && segment.relIdx(1).value == "d͡ʒ")
                segment.stressed = false;
        });

        word.replaceSeq("t,j", "t͡ʃ");

        word.forEach(segment => {
            if (segment.value == "j" && segment.relIdx(-1).type != "vowel" && segment.relIdx(-1).value != "w")
                segment.value = "d͡ʒ";
        });

        if (variety == "norman")
            word.replace("t͡sʲ", "t͡ʃ");

        word.replace("d͡zʲ", "z̺ʲ", "V_V");

        word.replace("tʲ", "t͡sʲ");
        word.replace("dʲ", "d͡zʲ");
        word.replace("s̺ʲ", "s̺", "_t͡sʲ");
        word.replace("z̺ʲ", "z̺", "_d͡zʲ");

        word.replace("n", "nʲ", "j_");
        word.replace("t", "tʲ", "j_");
        word.replace("d", "dʲ", "j_");
        word.replace("r", "rʲ", "j_");

        word.replace("t͡sʲ", "s̺ʲ", "s̺_");
        word.replace("t͡sʲ", "s̺ʲ", "_C");

        word.forEach(segment => {
            if (segment.type == "vowel" && segment.relIdx(1).value == "w" && !segment.match("u", "uː")) {
                if (!segment.match("ie̯", "uo̯"))
                    segment.value = segment.value[0];
                segment.value = segment.value + "u̯";
                segment.relIdx(1).remove();
            }
        });

        word.forEach(segment => {
            if (segment.type == "vowel" && segment.value != "i" && segment.relIdx(1).value != "j" && (segment.relIdx(1).match("d͡zʲ", "s̺ʲ", "z̺ʲ", "rʲ") || segment.nextVowel().relIdx(-1).match("s̺ʲ", "rʲ")))
                word.insert("j", segment.i + 1);
        });
        word.replace("ɛ", "ie̯", "_j");
        word.replace("ɔ", "uo̯", "_j");

        word.forEach(segment => {
            if (segment.match("n", "t", "d", "r") && segment.prevVowel().relIdx(1).match("j", "ɲ"))
                segment.value += "ʲ";
        });

        word.forEach(segment => {
            if (segment.value == "aː" && (segment.relIdx(-1).value.endsWith("ʲ") || segment.relIdx(-1).match("j", "ɲ", "ʎ", "t͡ʃ", "d͡ʒ")))
                segment.value = "ie̯";

            if (segment.value == "eː" && (segment.relIdx(-1).value.endsWith("ʲ") || segment.relIdx(-1).match("j", "ɲ", "ʎ", "t͡ʃ", "d͡ʒ")))
                segment.value = "ie̯i̯";
        });

        word.forEach(segment => {
            if (segment.type == "vowel" && segment.relIdx(1).value == "j") {
                if (!segment.match("i", "iː")) {
                    if (!segment.match("ie̯", "uo̯", "au̯"))
                        segment.value = segment.value[0];
                    segment.value += "i̯";
                }
                if (!(segment.relIdx(2).type == "vowel" && segment.relIdx(2).stressed))
                    segment.relIdx(1).remove();
            }
        });
        word.replace("ii̯", "i");

        word.forEach(segment => {
            if (segment.value == "ɣ" && segment.relIdx(-1).value != "iː" && !segment.relIdx(-1).value.endsWith("i̯") && segment.relIdx(-1).stressed && segment.relIdx(1).match("o", "u"))
                segment.value = "w";
        });

        word.replace("aː", "au̯", "_w");

        word.replace("oː", "ou̯");
        word.replace("eː", "ei̯");
        word.replace("aː", "ai̯", "_m/n");
        word.replace("aː", "æ");
        word.replace("iː", "i");
        word.replace("uː", "u");

        word.replace("ou̯", "o", "_m/n");

        word.replace("au̯", "ɔ");
        word.replace("au̯i̯", "ɔi̯");
        word.replace("ie̯i̯", "i");
        word.replace("uo̯i̯", "ui̯");
        word.replace("ai̯", "i", "nʲ/tʲ/dʲ/t͡sʲ/t͡ʃ/d͡zʲ/d͡ʒ/s̺ʲ/z̺ʲ/lʲ/rʲ/j/ɲ/ʎ_");

        word.forEach(segment => {
            if (segment.value.endsWith("ʲ"))
                segment.value = segment.value.slice(0, -1);
        });

        //Unstressed final vowel loss
        let finalVowel = word.vowels.at(-1);
        if (!finalVowel.stressed) {
            if (
                finalVowel.value == "a"
                || finalVowel.relIdx(-1).match("t͡ʃ", "d͡ʒ")
                || (finalVowel.relIdx(-2).value == "d" && finalVowel.relIdx(-1).value == "d͡z")
                || (finalVowel.relIdx(1).type == "consonant" && finalVowel.relIdx(2).type == "consonant")
                || (finalVowel.relIdx(-2).value == "ð" && finalVowel.relIdx(-1).value == "β")
            )
                finalVowel.value = "ə";
            else
                finalVowel.remove();
        }
        if (word.at(-2)?.match("p", "t", "k", "b", "d", "g") && word.at(-1).match("ð", "p", "k"))
            word.at(-2).remove();
        word.replace("ð", "d", "C_");
        word.remove("ð", "_d");
        word.replace("d", "t", "p/t/k_");
        if (word.at(-2)?.value == word.at(-1).value[0] && word.at(-1).type == "consonant")
            word.at(-2).remove();
        if (word.at(-1).match("m", "n", "ɲ", "l", "ɫ", "ʎ", "r", "j") && word.at(-2).type == "consonant" && !(word.at(-2).value == "r" && word.at(-1).match("m", "n")))
            word.insert("ə", word.length);
        if (word.at(-1).type == "consonant" && word.at(-2).match("m", "n", "ɲ", "l", "ɫ", "ʎ", "r", "j") && word.at(-3).type == "consonant" && !(word.at(-3).value == "r" && word.at(-2).match("m", "n")) && word.at(-3).value != word.at(-2).value)
            word.insert("ə", -1);
        if (word.at(-1).match("p", "k", "b", "d", "g", "f") && word.at(-2).match("p", "t", "k", "b", "d", "g", "f") && word.at(-1).value[0] != word.at(-2).value)
            word.insert("ə", word.length);
        if (word.at(-1).type == "consonant" && word.at(-2).match("p", "k", "b", "d", "g", "f") && word.at(-3).match("p", "t", "k", "b", "d", "g", "f") && word.at(-2).value[0] != word.at(-3).value)
            word.insert("ə", -1);
        if (word.at(-1).value == "s̺" && word.at(-2).match("s̺", "z̺", "t͡s", "d͡z"))
            word.at(-1).remove();
        word.replace("l", "ɫ", "_C/#");
        word.replace("ɫ", "l", "_l/V");
        word.forEach(segment => {
            if (segment.value == "m" && segment.relIdx(1).match("l", "r"))
                word.insert("b", segment.i + 1);

            if (segment.value == "s̺" && segment.relIdx(1).value == "r")
                word.insert("t", segment.i + 1);

            if (segment.value == "z̺" && segment.relIdx(1).value == "r")
                word.insert("d", segment.i + 1);
        });
        word.replace("d", "ð", "ə_#");
        word.remove("w", "C/ai̯_#");

        word.forEach(segment => {
            if (segment.value == "r" && segment.relIdx(-1).match("ɫ", "ʎ", "n", "ɲ"))
                word.insert("d", segment.i);
        });

        word.remove("w", "u_");

        word.replace("n", "t", "n/r_s̺");

        word.replace("d͡z", "z̺", "V_V");

        word.replace("n", "m", "m_");

        //Nasal assimilation
        word.remove("m", "m_C");
        word.remove("n", "n_C");
        word.replace("n", "m", "_m/p/b");
        word.replace("ŋ", "m", "_m/p/b");
        word.replace("m", "n", "_t/d/t͡s/d͡z/t͡ʃ/d͡ʒ/ð/s̺/z̺/f/β");
        word.replace("ŋ", "n", "_t/d/t͡s/d͡z/t͡ʃ/d͡ʒ/ð/s̺/z̺/f/β");
        word.replace("m", "ɲ", "_ɲ");
        word.replace("m", "ŋ", "_k/g/ɣ");
        word.replace("n", "ŋ", "_k/g/ɣ");

        word.forEach(segment => {
            if (segment.value == "r" && segment.relIdx(-1).value != "r" && segment.relIdx(1).value != "r" && segment.i != 0)
                segment.value = "ɾ";
        });

        //Degemination
        word.forEach(segment => {
            if (segment.type == "consonant" && (segment.value == segment.relIdx(1).value[0] || segment.value == segment.relIdx(1).value) && segment.value != "r")
                segment.remove();
        });

        word.remove("β", "V_ɔ/o/u/uo̯/ou̯");
        word.forEach(segment => {
            if (segment.value == "β" && segment.relIdx(-1).value == "u" && segment.relIdx(-1).stressed)
                segment.remove();
        });

        word.remove("ɣ");
        word.replace("ŋ", "n", "_#");
        word.replace("ɫ", "l", "_V");
        if (word.stressedVowel.relIdx(-1).type == "consonant")
            word.stressedVowel.relIdx(-1).stressed = true;

        if (variety != "norman")
            word.forEach(segment => {
                if (
                    segment.value == "a" && !segment.stressed && segment != word.vowels[0] && segment.relIdx(1).type == "consonant"
                    && !(segment.relIdx(2).type == "consonant" && !segment.relIdx(2).match("j", "w")
                        && !(segment.relIdx(1).match("p", "t", "k", "b", "d", "g", "f", "θ", "ð") && segment.relIdx(2).match("l", "ɾ")))
                    && !segment.relIdx(1).match("ʎ", "ɲ")
                )
                    segment.value = "ə";
            });

        word.forEach(segment => {
            if (segment.value == "ə" && segment.relIdx(-1).match("n", "ɾ") && segment.relIdx(1).value == "ɾ") {
                segment.relIdx(-1).remove();
                segment.relIdx(1).value = "r";
                segment.remove();
            }
        });

        //Final devoicing
        word.slice().reverse().forEach(segment => {
            if (segment == word.at(-1) || segment.relIdx(1).match("p", "t", "k", "t͡s", "t͡ʃ", "f", "θ", "s̺")) {
                switch (segment.value) {
                    case "b":
                        segment.value = "p";
                        break;
                    case "d":
                        segment.value = "t";
                        break;
                    case "g":
                        segment.value = "k";
                        break;
                    case "d͡z":
                        segment.value = "t͡s";
                        break;
                    case "d͡ʒ":
                        segment.value = "t͡ʃ";
                        break;
                    case "β":
                        segment.value = "f";
                        break;
                    case "ð":
                        segment.value = "θ";
                        break;
                    case "z̺":
                        segment.value = "s̺";
                        break;
                }
            }
        });
        word.forEach(segment => {
            if (segment.type == "consonant" && segment.value == segment.relIdx(1).value[0])
                segment.remove();
        });
        word.replace("t͡s", "s̺", "_C");

        word.replaceSeq("t,s̺", "t͡s");
        word.replaceSeq("θ,s̺", "t͡s");

        word.replace("s̺", "t͡s", "ɲ/ʎ_");

        word.forEach(segment => {
            if (segment.value == "ɲ" && segment.relIdx(1).type != "vowel" && segment.relIdx(-1).type == "vowel" && segment.relIdx(-1).value != "i") {
                word.insert("j", segment.i);
            }
        });

        word.forEach(segment => {
            if (segment.type == "vowel" && segment.relIdx(1).value == "j") {
                if (segment.value != "i" && !segment.value.endsWith("i̯"))
                    segment.value += "i̯";
                segment.relIdx(1).remove();
            }

            if (segment.type == "vowel" && segment.relIdx(1).value == "w" && segment.relIdx(2).type != "vowel") {
                if (segment.value != "u" && !segment.value.endsWith("u̯"))
                    segment.value += "u̯";
                segment.relIdx(1).remove();
            }
        });

        word.replace("ɲ", "n", "_C");
        word.replace("ʎ", "ɫ", "_C");

        word.forEach(segment => {
            if (segment.value == "e" && segment.relIdx(1).match("ɫ", "r") && segment.relIdx(2).type == "consonant" && !segment.stressed)
                segment.value = "ɛ";

            if (segment.value == "o" && segment.relIdx(1).value == "ɫ" && segment.relIdx(2).type == "consonant" && !segment.stressed)
                segment.value = "ɔ";
        });

        word.remove("s̺", "_t͡s");

        addRow("EOF", "Early Old French", "900", getSpelling_EOF(), word, true);
    }

    function EOF_to_LOF(variety) {
        word = outcomes.EOF.duplicate();

        word.replace("β", "v");

        word.replace("m", "n", "_#");
        word.replace("ɲ", "n", "_#");

        word.replace("e", "ei̯", "_ɲ");
        word.replace("u", "ui̯", "_ʎ/ɲ,V");

        word.remove("f", "_s̺/t,C/#");
        word.remove("p", "_s̺/t,C/#");
        word.remove("k", "_s̺/t,C/#");
        word.remove("s̺", "_s̺,C/#");
        word.replace("m", "n", "_s̺/t");
        word.replace("ŋ", "n", "_s̺/t");

        word.remove("k", "s̺_l");
        word.replace("s̺", "z̺", "_l");
        word.remove("g", "ɾ_l");

        word.forEach(segment => {
            if (segment.match("p", "t", "k", "b", "d", "g") && segment.relIdx(1).match("m", "n", "ɲ", "p", "t", "k", "b", "d", "g", "f"))
                segment.remove();
        });
        word.forEach(segment => {
            if (segment.match("m", "n", "ɲ", "ŋ") && segment.relIdx(1).match("m", "n", "ɲ"))
                segment.remove();
        });

        word.forEach(segment => {
            if (segment.type == "vowel" && segment.relIdx(1).match("m", "n", "ɲ", "ŋ"))
                segment.nasalized = true;
        });

        word.replaceSeq("ie̯u̯", "ie̯,w");
        word.replaceSeq("uo̯u̯", "uo̯,w");

        word.forEach(segment => {
            if (segment.value == "ei̯" && !segment.nasalized && variety != "norman")
                segment.value = "oi̯";

            if (segment.value == "ou̯" && !segment.relIdx(1).match("m", "p", "b", "f", "v"))
                segment.value = "eu̯";

            if (segment.value == "uo̯")
                segment.value = "ue̯";
        });

        word.forEach(segment => {
            if (segment.value == "ɫ" && segment.relIdx(1).type == "consonant") {
                segment.relIdx(-1).droppedL = true;
                if (segment.relIdx(-1).match("i", "u", "oi̯", "ə") || segment.relIdx(-1).value.endsWith("u̯") || segment.relIdx(-1).value == "w")
                    segment.remove();
                else
                    segment.value = "w";
            }
        });

        if (variety != "norman") {
            word.replace("æ", "ie̯", "_w");
            word.replace("ɛ", "e̯a", "_w");
            word.replace("ai̯", "e̯a", "_w");
        }

        word.replace("a", "ɑ", "_s̺/z̺");

        word.remove("θ");
        word.remove("ð");
        word.forEach(segment => {
            if (segment.type == "vowel" && segment.relIdx(1).match("m", "n", "ɲ", "ŋ"))
                segment.nasalized = true;
        });

        word.forEach(segment => {
            if (
                segment.value == "e" && !segment.stressed
                && !(segment.relIdx(1).type == "consonant" && segment.relIdx(2).type == "consonant" && !segment.relIdx(2).match("j", "w")
                    && !(segment.relIdx(1).match("p", "t", "k", "b", "d", "g", "f") && segment.relIdx(2).match("l", "ɾ")))
                && !segment.relIdx(1).match("ʎ", "ɲ")
            )
                segment.value = "ə";
        });

        word.replace("ɔ", "o", "_m/n/ɲ/ŋ");
        word.replace("ue̯", "o", "_m/n/ŋ");

        word.replace("u", "y");
        word.replace("ui̯", "yi̯");

        word.remove("m", "ɾ_C/#");
        word.remove("n", "ɾ_C/#");

        word.replace("æ", "e");

        if (!word.vowels.at(-1).stressed) {
            word.vowels.at(-1).value = "ə";
            if (word.vowels.at(-1).relIdx(1).value == "w")
                word.vowels.at(-1).relIdx(1).remove();
        }

        if (variety == "norman")
            word.remove("g", "#_w");
        else
            word.remove("w", "k/g_");

        word.replace("iu̯", "yi̯");

        word.forEach(segment => {
            if (segment.value == "w" && segment.relIdx(-1).type == "vowel" && segment.relIdx(-1).type == "vowel" && (segment.stressed || segment.relIdx(-1).match("i", "oi̯", "ə")))
                segment.value = "v";
        });

        word.forEach(segment => {
            if (segment.match("ɛ", "e") && segment.relIdx(1).match("m", "n", "ŋ") && variety != "norman")
                segment.value = "æ";
        });

        word.forEach(segment => {
            if (segment.value == "ie̯") {
                word.insert("j", segment.i);
                if (segment.stressed)
                    segment.relIdx(-1).stressed = true;
                segment.value = "e";
            }

            if (segment.value == "ue̯") {
                word.insert("w", segment.i);
                if (segment.stressed)
                    segment.relIdx(-1).stressed = true;
                segment.value = "e";
            }

            if (segment.value == "yi̯") {
                word.insert("ɥ", segment.i);
                if (segment.stressed)
                    segment.relIdx(-1).stressed = true;
                segment.value = "i";
            }
        });

        word.forEach(segment => {
            if (segment.type == "vowel" && segment.relIdx(1).value == "j" && segment.value != "ə" && !segment.value.endsWith("i̯") && !segment.value.endsWith("u̯")) {
                if (!segment.match("i", "y"))
                    segment.value = segment.value + "i̯";
                segment.relIdx(1).remove();
            }

            if (segment.type == "vowel" && segment.relIdx(1).value == "e̯au̯" && segment.value != "ə" && !segment.value.endsWith("i̯") && !segment.value.endsWith("u̯")) {
                if (!segment.match("i", "y"))
                    segment.value = segment.value + "i̯";
                segment.relIdx(1).value = "au̯";
            }

            if (segment.type == "vowel" && segment.relIdx(1).value == "w" && segment.value != "ə" && !segment.match("i", "y") && !segment.value.endsWith("i̯")) {
                if (segment.value != "u" && !segment.value.endsWith("u̯"))
                    segment.value = segment.value + "u̯";
                segment.relIdx(1).remove();
            }
        });

        word.replace("o", "u");
        word.replace("ou̯", "u");

        word.replace("ɔi̯", "oi̯");
        word.replace("ɛu̯", "eu̯");

        word.replace("e", "ø", "w_");
        word.replace("ɛ", "œ", "w_");
        word.replace("eu̯", "øu̯");

        //Loss of preconsonantal /z/
        word.forEach(segment => {
            if (segment.value == "z̺" && segment.relIdx(-1).type == "vowel" && segment.relIdx(1).type == "consonant" && !segment.relIdx(1).match("j", "w", "ɥ")) {
                if (segment.relIdx(-1).value.length == 1 && segment.relIdx(-1).value != "ə")
                    segment.relIdx(-1).value += "ː";
                segment.relIdx(-1).droppedS = true;
                segment.remove();
            }
        });

        word.replace("a", "ə", "_y");

        word.forEach(segment => {
            if (segment.value == "ə" && segment.relIdx(-1).type == "vowel" && segment.nextVowel().stressed)
                segment.remove();
        });

        addRow("LOF", "Late Old French", "1200", getSpelling_LOF(), word);
    }

    function LOF_to_MF() {
        word = outcomes.LOF.duplicate();

        word.replace("ɫ", "l");

        word.replace("ɔu̯", "u");

        word.replace("ai̯", "ɛ");

        //Loss of preconsonantal /s/ and other vowel lengthening
        word.forEach(segment => {
            if (segment.value == "s̺" && segment.relIdx(-1).type == "vowel" && segment.relIdx(1).type == "consonant" && !segment.relIdx(1).match("j", "w", "ɥ")) {
                if (segment.relIdx(-1).value.length == 1 && segment.relIdx(-1).value != "ə")
                    segment.relIdx(-1).value += "ː";
                segment.relIdx(-1).droppedS = true;
                segment.remove();
            }

            if (segment.type == "vowel" && segment.relIdx(1).match("z̺", "r") && segment.value.length == 1 && segment.value != "ə")
                segment.value += "ː";
        });
        word.replace("ɔ", "ɔː", "_v");

        word.forEach(segment => {
            if (segment.value == "e" && segment.relIdx(1).type == "consonant" && !(segment.relIdx(1).value == "ɾ" && segment.relIdx(2).value == "ə"))
                segment.value = "ɛ";
        });
        word.replace("ø", "œ");
        word.replace("øː", "œː");

        if (word.partOfSpeech == "inf" && word.at(-1).value == "ɾ" && word.at(-2).value == "ɛ" && word.at(-3)?.value == "j" && word.at(-4)?.type == "consonant")
            word.at(-3).remove();

        word.forEach(segment => {
            if (segment.value == "w" && segment.relIdx(1).value == "øu̯" && !segment.relIdx(-1).match("p", "k", "b", "g", "f", "v"))
                segment.value = "j";
        });

        word.replace("øu̯", "œ");
        word.remove("w", "_œ/œː/øː");

        //Loss of vowels in hiatus
        word.forEach(segment => {
            if (
                segment.type == "vowel"
                && (
                    segment.relIdx(-1).match("ə", "a")
                    || segment.relIdx(-1).value == segment.value[0]
                    || (segment.relIdx(-1).value == "ɛ" && segment.value.startsWith("e"))
                    || (segment.relIdx(-1).value == "ɔ" && (segment.value.startsWith("o") || segment.value.startsWith("u")))
                )
            ) {
                if (segment.stressed && segment.value.length == 1)
                    segment.value += "ː";
                if (segment.match("eː", "ei̯"))
                    segment.value = "ɛː";
                if (segment.relIdx(-1).match("a", "ɛ") && segment.match("ɛː", "iː")) {
                    segment.value = "ɛː";
                    segment.droppedA = true;
                }
                if (segment.relIdx(-1).value == "ɔ" && segment.value == "uː")
                    segment.value = "oː";
                else if (segment.relIdx(-1).match("ə", "a") && segment.value == "uː" && segment.relIdx(1).match("m", "n", "ɲ", "ŋ"))
                    segment.value = "ɑː";
                segment.relIdx(-1).remove();
            }
        });

        word.replace("aː", "ɑː");
        word.replace("eː", "ɛː");
        word.replace("ɔː", "oː");
        word.replace("æː", "ɑː");

        word.forEach(segment => {
            if (segment.relIdx(1).match("m", "n", "ɲ", "ŋ") && segment.relIdx(2).type != "vowel") {
                switch (segment.value) {
                    case "ɑː":
                        segment.value = "a";
                        break;
                    case "ɛː":
                        segment.value = "ɛ";
                        break;
                    case "iː":
                        segment.value = "i";
                        break;
                    case "oː":
                        segment.value = "ɔ";
                        break;
                    case "uː":
                        segment.value = "u";
                        break;
                    case "yː":
                        segment.value = "y";
                        break;
                }
            }
        });

        word.replace("u", "ɔ", "_m/n/ɲ/ŋ");

        word.forEach(segment => {
            if (segment.type == "vowel" && segment.relIdx(-1).value == "oi̯" && segment.stressed) {
                word.insert("j", segment.i);
                segment.relIdx(-1).stressed = true;
            }
        });

        //Loss of internal schwa
        word.forEach(segment => {
            if (segment.value == "ə" && segment.relIdx(-1).type == "consonant" && !segment.relIdx(-1).match("s̺", "z̺", "l") && segment.relIdx(-2).type == "vowel" && segment.relIdx(1).type == "consonant" && segment.relIdx(2).type == "vowel")
                segment.remove();

            if (segment.value == "ə" && segment.relIdx(-1).match("p", "t", "k", "b", "d", "g", "f", "v") && segment.relIdx(1).match("l", "ɾ"))
                segment.remove();
        });
        word.forEach(segment => {
            if (segment.value == "e" && segment.relIdx(1).type == "consonant" && !(segment.relIdx(1).value == "ɾ" && segment.relIdx(2).value == "ə"))
                segment.value = "ɛ";
        });

        word.forEach(segment => {
            if (segment.value == "ɛː" && !segment.stressed && segment.LOFValue != "ai̯")
                segment.value = "e";
        });

        word.replace("ɾ", "r");

        //Syllabification
        if (word.stressedVowel.relIdx(-1).type == "consonant")
            word.stressedVowel.relIdx(-1).stressed = true;
        if (word.stressedVowel.relIdx(-1).match("j", "w", "ɥ") && word.stressedVowel.relIdx(-2).type == "consonant" && !word.stressedVowel.relIdx(-2).match("j", "w", "ɥ"))
            word.stressedVowel.relIdx(-2).stressed = true;
        if (word.stressedVowel.relIdx(-1).match("l", "r") && word.stressedVowel.relIdx(-2).match("p", "t", "k", "b", "d", "g", "f"))
            word.stressedVowel.relIdx(-2).stressed = true;
        if (word.stressedVowel.relIdx(-1).match("j", "w", "ɥ") && word.stressedVowel.relIdx(-2).match("l", "r") && word.stressedVowel.relIdx(-3).match("p", "t", "k", "b", "d", "g", "f"))
            word.stressedVowel.relIdx(-3).stressed = true;
        if (word.stressedVowel.relIdx(-1).value == "r" && word.stressedVowel.relIdx(-2).value == "v")
            word.stressedVowel.relIdx(-2).stressed = true;
        if (word.stressedVowel.relIdx(-1).match("j", "w", "ɥ") && word.stressedVowel.relIdx(-2).value == "r" && word.stressedVowel.relIdx(-3).value == "v")
            word.stressedVowel.relIdx(-3).stressed = true;
        word.forEach(segment => {
            if (word.vowels[0].stressed && segment.i < word.vowels[0].i)
                segment.stressed = true;
        });

        word.lateOFWord = word.duplicate();

        word.replace("æ", "a");

        word.forEach(segment => {
            if (segment.value == "oi̯") {
                word.insert("w", segment.i);
                if (segment.stressed)
                    segment.relIdx(-1).stressed = true;
                segment.value = "ɛ";
            }
        });
        word.remove("w", "w_");

        word.replace("t͡s", "s");
        word.replace("d͡z", "z");
        word.replace("t͡ʃ", "ʃ");
        word.replace("d͡ʒ", "ʒ");

        word.replace("s̺", "s");
        word.replace("z̺", "z");

        //Vowel nasalization
        word.forEach(segment => {
            segment.nasalized = false;
            if (segment.type == "vowel" && segment.relIdx(1).match("m", "n", "ɲ", "ŋ") && segment.relIdx(2).type != "vowel" && !segment.relIdx(2).match("j", "w")) {
                segment.value = segment.value.slice(0, 1) + "̃" + segment.value.slice(1);
                if (segment.value.length > 2)
                    segment.value += "̃";
                else if (segment.value != "ə̃")
                    segment.value += "ː";
                segment.relIdx(1).remove();
            }
        });

        word.replace("ei̯", "ɛ");
        word.replace("ẽĩ̯", "ɛ̃");

        word.replace("ə̃", "ə");

        word.replace("au̯", "oː");
        word.replace("e̯au̯", "e̯oː");

        addRow("MF", "Middle French", "1600", getSpelling_MF(word.lateOFWord), word, true);
    }

    function MF_to_ModF() {
        word = outcomes.MF.duplicate();

        word.forEach(segment => {
            if (segment.value == "j" && segment.relIdx(-1).match("ʃ", "ʒ", "ʎ", "ɲ") && !segment.relIdx(1).value.includes("̃")) {
                word.lateOFWord.vowels[word.vowels.indexOf(segment.nextVowel())].relIdx(-1).remove();
                segment.remove();
            }
        });

        //Loss of final consonants
        while (word.vowels.at(-1) != word.at(-1) && !(word.at(-1)).match("t", "k", "l", "ʎ", "r", "f"))
            word.at(-1).remove();

        word.replace("ɛ", "a", "w_");

        word.replace("e", "ɛ", "_r");

        if (word.at(-1).value == "r" && word.at(-2).value == "ɛ" && word.at(-2).LOFValue != "ai̯" && word.vowels.length > 1)
            word.at(-1).remove();

        word.forEach(segment => {
            if (segment.value == "ɛ" && segment.relIdx(1).type != "consonant" && segment.LOFValue != "ai̯")
                segment.value = "e";
        });

        word.replace("œ", "ø", "_#/z/t");
        word.replace("œː", "øː");

        //Loss of vowel length distinction
        word.forEach(segment => {
            if (segment.value.endsWith("ː"))
                segment.value = segment.value.slice(0, -1);
        });

        word.remove("t", "_#");

        word.replace("r", "ʁ");

        word.replace("ʎ", "j");
        word.remove("j", "_j");

        //Elision of final schwa
        if (word.vowels.at(-1).value == "ə" && word.vowels.at(-1).relIdx(-1).value != "w")
            word.vowels.at(-1).remove();

        word.replace("e̯o", "o");

        word.forEach(segment => {
            if (
                segment.match("i", "u", "y") && segment.relIdx(1).type == "vowel"
                && !(segment.relIdx(-2).match("p", "t", "k", "b", "d", "g", "f", "v") && segment.relIdx(-1).match("l", "ʁ"))
                && !(segment.relIdx(-2).type == "consonant" && segment.relIdx(-1).match("j", "w", "ɥ"))
            ) {
                switch (segment.value) {
                    case "i":
                        segment.value = "j";
                        break;
                    case "u":
                        segment.value = "w";
                        break;
                    case "y":
                        segment.value = "ɥ";
                        break;
                }
                segment.type = "consonant";
            }
        });

        //Syllabification
        if (word.stressedVowel.relIdx(-1).type == "consonant")
            word.stressedVowel.relIdx(-1).stressed = true;
        if (word.stressedVowel.relIdx(-1).match("j", "w", "ɥ") && word.stressedVowel.relIdx(-2).type == "consonant" && !word.stressedVowel.relIdx(-2).match("j", "w", "ɥ"))
            word.stressedVowel.relIdx(-2).stressed = true;
        if (word.stressedVowel.relIdx(-1).match("l", "ʁ") && word.stressedVowel.relIdx(-2).match("p", "t", "k", "b", "d", "g", "f"))
            word.stressedVowel.relIdx(-2).stressed = true;
        if (word.stressedVowel.relIdx(-1).match("j", "w", "ɥ") && word.stressedVowel.relIdx(-2).match("l", "ʁ") && word.stressedVowel.relIdx(-3).match("p", "t", "k", "b", "d", "g", "f"))
            word.stressedVowel.relIdx(-3).stressed = true;
        if (word.stressedVowel.relIdx(-1).value == "ʁ" && word.stressedVowel.relIdx(-2).value == "v")
            word.stressedVowel.relIdx(-2).stressed = true;
        if (word.stressedVowel.relIdx(-1).match("j", "w", "ɥ") && word.stressedVowel.relIdx(-2).value == "ʁ" && word.stressedVowel.relIdx(-3).value == "v")
            word.stressedVowel.relIdx(-3).stressed = true;
        word.forEach(segment => {
            if (word.vowels[0].stressed && segment.i < word.vowels[0].i)
                segment.stressed = true;
        });

        word.replace("ĩ", "ɛ̃");
        word.replace("ỹ", "œ̃");
        word.replace("ɛ̃", "æ̃");
        word.replace("ã", "ɒ̃");
        word.replace("ɔ̃", "õ");

        //Metropolitan French vowel mergers
        word.replace("œ̃", "æ̃");
        word.replace("ɑ", "a");
        word.replace("ə", "œ");
        word.replace("ɔ", "o", "_#");

        //Allophonic vowel lengthening
        word.forEach(segment => {
            if (segment.type == "vowel" && segment.stressed && segment.relIdx(1).match("v", "z", "ʒ", "ʁ")
                && (segment == word.at(-2) || segment.relIdx(2).value == "ʁ"))
                segment.value += "ː";

            else if (segment.match("o", "ø", "ɒ̃", "æ̃", "õ") && segment.stressed && segment.relIdx(1).type == "consonant")
                segment.value += "ː";
        });

        word.replace("ʁ", "χ", "p/t/k/f/s/ʃ_");
        word.replace("ʁ", "χ", "_p/t/k/f/s/ʃ");
        word.replace("ʁ", "χ", "V_#");

        addRow("ModF", "Modern French", "2000", getSpelling_ModF(word.lateOFWord), word);
    }

    function getSpelling_OE() {
        let str = wordArg;
        str = str.replaceAll("ā", "a")
            .replaceAll("ē", "e")
            .replaceAll("ī", "i")
            .replaceAll("ō", "o")
            .replaceAll("ū", "u")
            .replaceAll("ȳ", "y")
            .replaceAll("ǣ", "æ")
            .replaceAll("ċ", "c")
            .replaceAll(/(?<![eiyæn])ġa/g, "gea")
            .replaceAll(/(?<![eiyæn])ġo/g, "geo")
            .replaceAll(/(?<![eiyæn])ġu/g, "geo")
            .replaceAll("ġ", "g");
        return str;
    }

    function getSpelling_EME() {
        let str = "";
        for (let i = 0; i < word.length; i++) {
            let segment = word[i];
            switch (segment.value) {
                case "a":
                case "aː":
                    str += "a";
                    break;
                case "e":
                case "ɛː":
                case "eː":
                case "ə":
                    str += "e";
                    break;
                case "i":
                case "iː":
                    str += "i";
                    break;
                case "o":
                case "ɔː":
                case "oː":
                    str += "o";
                    break;
                case "u":
                case "uː":
                    str += "u";
                    break;
                case "b":
                    str += "b";
                    break;
                case "t͡ʃ":
                    str += "ch";
                    break;
                case "d":
                    if (segment.relIdx(1).value == "d͡ʒ")
                        str += "g";
                    else
                        str += "d";
                    break;
                case "f":
                    str += "f";
                    break;
                case "g":
                case "d͡ʒ":
                    str += "g";
                    break;
                case "ɣ":
                case "ʝ":
                case "j":
                case "x":
                case "ç":
                    str += "ȝ";
                    break;
                case "h":
                    str += "h";
                    break;
                case "k":
                    if (segment.relIdx(1).value == "s") {
                        str += "x";
                        i++;
                    } else if (segment.relIdx(1).value == "w") {
                        str += "qu";
                        i++;
                    } else if (segment.relIdx(1).match("e", "ə", "ɛː", "eː", "i", "iː", "ɛi̯", "ɛu̯", "iu̯") || segment.relIdx(1).value == "k" || segment == word.at(-1)) {
                        str += "k";
                    } else {
                        str += "c";
                    }
                    break;
                case "l":
                case "ɫ":
                    str += "l";
                    break;
                case "m":
                    str += "m";
                    break;
                case "n":
                case "ŋ":
                    str += "n";
                    break;
                case "p":
                    str += "p";
                    break;
                case "r":
                case "rˠ":
                    str += "r";
                    break;
                case "s":
                case "z":
                    str += "s";
                    break;
                case "ʃ":
                    str += "sch";
                    break;
                case "t":
                    if (segment.relIdx(1).value == "t͡ʃ")
                        str += "c";
                    else
                        str += "t";
                    break;
                case "θ":
                case "ð":
                    str += "þ";
                    break;
                case "v":
                    if (segment.relIdx(1).type == "consonant")
                        str += "f";
                    else
                        str += "v";
                    break;
                case "w":
                    str += "w";
                    break;
                case "xʷ":
                    str += "hw";
                    break;
            }
        }

        return str.replace(/s$/, `<span class="nonHist">s</span>`);
    }

    function getSpelling_LME() {
        let str = "";
        for (let i = 0; i < word.length; i++) {
            let segment = word[i];
            switch (segment.value) {
                case "a":
                case "aː":
                    str += "a";
                    break;
                case "e":
                case "ə":
                    str += "e";
                    break;
                case "ɛː":
                case "eː":
                    if (segment.relIdx(2).type == "vowel" || segment.relIdx(1).type != "consonant" || (word.droppedE && segment == word.at(-2)))
                        str += "e";
                    else
                        str += "ee";
                    break;
                case "i":
                case "iː":
                    if ((segment == word.at(-1) && !word.droppedE) || segment.relIdx(1).value == "i" || (segment.i == 0 && !segment.stressed))
                        str += "y";
                    else
                        str += "i";
                    break;
                case "ɔ":
                    str += "o";
                    break;
                case "ɔː":
                case "oː":
                    if (
                        segment.relIdx(2).type == "vowel" || segment.relIdx(1).type != "consonant"
                        || (word.droppedE && segment == word.at(-2))
                        || (segment.relIdx(1).match("ɫ", "rˠ") && segment.relIdx(2).value == "d")
                        || (segment.relIdx(1).value == "m" && (segment.relIdx(1).droppedB || segment.relIdx(2).value == "b"))
                    )
                        str += "o";
                    else
                        str += "oo";
                    break;
                case "u":
                    if (segment.relIdx(-1).match("w", "v") || segment.relIdx(-1).droppedW || segment.relIdx(1).match("m", "n", "ŋ", "v"))
                        str += "o";
                    else
                        str += "u";
                    break;
                case "uː":
                case "ɔu̯":
                    if (segment.relIdx(1).type == "consonant")
                        str += "ou";
                    else
                        str += "ow";
                    break;
                case "ɑu̯":
                    if (segment.relIdx(1).type == "consonant")
                        str += "au";
                    else
                        str += "aw";
                    break;
                case "æi̯":
                    if (segment.EMEValue == "a")
                        str += "a";
                    else
                        str += "e";
                    if (segment.relIdx(1).type == "consonant")
                        str += "i";
                    else
                        str += "y";
                    break;
                case "ɛu̯":
                case "iu̯":
                    str += "ew";
                    break;
                case "ɔi̯":
                case "ui̯":
                    if (segment.relIdx(1).type == "consonant")
                        str += "oi";
                    else
                        str += "oy";
                    break;
                case "b":
                    if (segment.degeminated)
                        str += "bb";
                    else
                        str += "b";
                    break;
                case "t͡ʃ":
                    if (segment.degeminated)
                        str += "cch";
                    else
                        str += "ch";
                    break;
                case "d":
                    if (segment.degeminated)
                        str += "dd";
                    else
                        str += "d";
                    break;
                case "f":
                    if (segment.degeminated)
                        str += "ff";
                    else
                        str += "f";
                    break;
                case "g":
                case "d͡ʒ":
                    if (segment.degeminated)
                        str += "gg";
                    else
                        str += "g";
                    break;
                case "h":
                    str += "h";
                    break;
                case "x":
                case "ç":
                    str += "gh";
                    break;
                case "k":
                    if (segment.relIdx(1).value == "s") {
                        str += "x";
                        i++;
                    }
                    else if (segment.relIdx(1).value == "w") {
                        str += "qu";
                        i++;
                    } else if (segment.degeminated) {
                        str += "ck";
                    } else if (
                        segment.relIdx(1).match("e", "ə", "ɛː", "eː", "i", "iː", "ɛu̯", "iu̯", "j", "n")
                        || (segment.relIdx(1).value == "æi̯" && (segment.relIdx(1).EMEValue != "a"))
                        || segment == word.at(-1)
                    ) {
                        str += "k";
                    } else {
                        str += "c";
                    }
                    break;
                case "l":
                case "ɫ":
                    if (segment.degeminated)
                        str += "ll";
                    else
                        str += "l";
                    break;
                case "m":
                    if (segment.droppedB)
                        str += "mb";
                    else if (segment.droppedN)
                        str += "mn";
                    else if (segment.degeminated)
                        str += "mm";
                    else
                        str += "m";
                    break;
                case "n":
                case "ŋ":
                    if (segment.degeminated)
                        str += "nn";
                    else
                        str += "n";
                    break;
                case "p":
                    if (segment.degeminated)
                        str += "pp";
                    else
                        str += "p";
                    break;
                case "r":
                case "rˠ":
                    if (segment.degeminated)
                        str += "rr";
                    else
                        str += "r";
                    break;
                case "s":
                case "z":
                    if (segment.degeminated)
                        str += "ss";
                    else
                        str += "s";
                    if (segment.droppedW)
                        str += "w";
                    break;
                case "ʃ":
                    str += "sch";
                    break;
                case "t":
                    if (segment.degeminated)
                        str += "tt";
                    else
                        str += "t";
                    break;
                case "θ":
                case "ð":
                    if (segment.degeminated)
                        str += "thth";
                    else
                        str += "th";
                    break;
                case "v":
                    str += "v";
                    if (segment.relIdx(1).type == "consonant")
                        str += "e";
                    break;
                case "w":
                    str += "w";
                    break;
                case "xʷ":
                    str += "wh";
                    break;
                case "j":
                    if (segment.relIdx(-1).type == "consonant" && !segment.stressed)
                        str += "i";
                    else
                        str += "y";
                    break;
            }
        }

        if (word.droppedE)
            str += "e";

        return str;
    }

    function getSpelling_ESc() {
        let str = "";
        for (let i = 0; i < word.length; i++) {
            let segment = word[i];
            switch (segment.value) {
                case "a":
                    str += "a";
                    break;
                case "aː":
                    if (segment.relIdx(2).type == "vowel" || segment.relIdx(1).type != "consonant" || (word.droppedE && segment == word.at(-2)) || segment.relIdx(1).value == "ɫ")
                        str += "a";
                    else
                        str += "ai";
                    break;
                case "e":
                case "ə":
                    str += "e";
                    break;
                case "ɛː":
                case "eː":
                    if (segment.relIdx(2).type == "vowel" || segment.relIdx(1).type != "consonant" || (word.droppedE && segment == word.at(-2)))
                        str += "e";
                    else
                        str += "ei";
                    break;
                case "ɪ":
                case "iː":
                case "i":
                    if ((segment == word.at(-1) && !word.droppedE) || segment.relIdx(1).value == "ɪ")
                        str += "y";
                    else
                        str += "i";
                    break;
                case "ɔ":
                    str += "o";
                    break;
                case "ɔː":
                    if (segment.relIdx(2).type == "vowel" || segment.relIdx(1).type != "consonant" || (word.droppedE && segment == word.at(-2)))
                        str += "o";
                    else
                        str += "oo";
                    break;
                case "u":
                    if (segment.relIdx(-1).match("w", "v") || segment.relIdx(-1).droppedW || segment.relIdx(1).match("m", "n", "ŋ"))
                        str += "o";
                    else
                        str += "u";
                    break;
                case "øː":
                    if (segment.relIdx(2).type == "vowel" || segment.relIdx(1).type != "consonant" || (word.droppedE && segment == word.at(-2)))
                        str += "u";
                    else
                        str += "ui";
                    break;
                case "uː":
                case "ɔu̯":
                    if (segment.relIdx(1).type == "consonant")
                        str += "ou";
                    else
                        str += "ow";
                    break;
                case "ɑu̯":
                    if (segment.relIdx(1).type == "consonant")
                        str += "au";
                    else
                        str += "aw";
                    break;
                case "æi̯":
                    if (segment.EMEValue == "a")
                        str += "a";
                    else
                        str += "e";
                    if (segment.relIdx(1).type == "consonant")
                        str += "i";
                    else
                        str += "y";
                    break;
                case "ɛu̯":
                case "iu̯":
                    if (segment.relIdx(1).type == "consonant")
                        str += "eu";
                    else
                        str += "ew";
                    break;
                case "ɔi̯":
                case "ui̯":
                    if (segment.relIdx(1).type == "consonant")
                        str += "oi";
                    else
                        str += "oy";
                    break;
                case "b":
                    if (segment.degeminated)
                        str += "bb";
                    else
                        str += "b";
                    break;
                case "t͡ʃ":
                case "x":
                case "ç":
                    if (segment.degeminated)
                        str += "cch";
                    else
                        str += "ch";
                    break;
                case "d":
                    if (segment.degeminated)
                        str += "dd";
                    else
                        str += "d";
                    break;
                case "f":
                    if (segment.degeminated)
                        str += "ff";
                    else
                        str += "f";
                    break;
                case "g":
                case "d͡ʒ":
                    if (segment.degeminated)
                        str += "gg";
                    else
                        str += "g";
                    break;
                case "j":
                    str += "ȝ";
                    break;
                case "h":
                    str += "h";
                    break;
                case "k":
                    if (segment.relIdx(1).value == "s") {
                        str += "x";
                        i++;
                    } else if (segment.relIdx(1).value == "w") {
                        str += "qu";
                        i++;
                    } else if (segment.degeminated) {
                        str += "kk";
                    } else if (
                        segment.relIdx(1).match("e", "ə", "ɛː", "eː", "ɪ", "iː", "ɛu̯", "iu̯", "j", "n")
                        || (segment.relIdx(1).value == "æi̯" && (segment.relIdx(1).EMEValue != "a"))
                        || segment == word.at(-1)
                    ) {
                        str += "k";
                    } else {
                        str += "c";
                    }
                    break;
                case "l":
                case "ɫ":
                    if (segment.degeminated || (segment.relIdx(-1).type == "vowel" && segment.relIdx(1).type != "consonant" && segment.relIdx(-1).i > word.stressedVowel.i))
                        str += "ll";
                    else
                        str += "l";
                    break;
                case "m":
                    if (segment.degeminated)
                        str += "mm";
                    else
                        str += "m";
                    break;
                case "n":
                    if (segment.degeminated)
                        str += "nn";
                    else
                        str += "n";
                    break;
                case "ŋ":
                    if (segment.relIdx(1).value == "k")
                        str += "n";
                    else
                        str += "ng";
                    break;
                case "p":
                    if (segment.degeminated)
                        str += "pp";
                    else
                        str += "p";
                    break;
                case "r":
                case "rˠ":
                    if (segment.degeminated)
                        str += "rr";
                    else
                        str += "r";
                    break;
                case "s":
                case "z":
                    if (segment.degeminated)
                        str += "ss";
                    else
                        str += "s";
                    break;
                case "ʃ":
                    str += "sch";
                    break;
                case "t":
                    if (segment.degeminated)
                        str += "tt";
                    else
                        str += "t";
                    break;
                case "θ":
                case "ð":
                    if (segment.degeminated)
                        str += "þþ";
                    else
                        str += "þ";
                    break;
                case "v":
                case "w":
                    str += "v";
                    if (segment.value == "v" && segment.relIdx(1).type == "consonant")
                        str += "e";
                    break;
                case "xʷ":
                    str += "quh";
                    break;
            }
        }

        if (word.droppedE && ((word.at(-2)?.value.endsWith("ː") && word.at(-1).type == "consonant") || (word.at(-1).degeminated && word.at(-1).value != "ʃ")))
            str += "e";

        return str;
    }

    function getSpelling_EModE(word) {
        let laterWord = word;
        word = word.EModEWord;
        let str = "";

        let finalE = false;
        if (word.droppedE && (word.vowels.at(-1).stressed || (word.at(-1).type == "vowel" && !word.at(-1).stressed)) && !word.at(-1).match("eː", "ɛː") && word.at(-1).value != "θ")
            finalE = true;
        if (laterWord.vowels.at(-1).value.length > 1 && !word.sSuffix && !word.pastTense && !word.vowels.at(-1).droppedH && word.at(-1).type != "vowel" && word.at(-1).value != "θ")
            finalE = true;
        if (word.at(-1).match("v", "d͡ʒ") || (word.at(-1).match("ð", "z") && word.at(-2).type == "vowel" && word.at(-2).value.length > 1 && word.at(-2).stressed && !word.sSuffix))
            finalE = true;
        if (word.at(-1).value == "ð" && word.vowels.at(-1).stressed)
            finalE = true;
        if (word.at(-1).value == "s" && word.at(-2).type == "vowel" && word.at(-2).value.length == 1)
            finalE = true;
        if (word.at(-1).match("s", "z") && word.at(-2).type == "consonant" && !word.sSuffix)
            finalE = true;

        for (let i = 0; i < word.length; i++) {
            let segment = word[i];

            let addE = false;
            if (segment == word.at(-2) && word.sSuffix && (word.vowels.at(-1).stressed || segment.type == "vowel") && !segment.match("ə", "eː", "ɛː"))
                addE = true;
            if (segment == word.at(-2) && word.sSuffix && laterWord.vowels.at(-1).value.length > 1 && !word.vowels.at(-1).droppedH && segment.type != "vowel" && segment.value != "θ")
                addE = true;
            if (segment == word.at(-2) && word.pastTense && !(segment.type == "vowel" && segment.value.length == 1) && !(segment.type == "vowel" && segment.relIdx(1).value == "t") && !(segment.value == "eː" && segment.stressed))
                addE = true;
            if (segment == word.at(-4) && word.conjPastTense && !(segment.type == "vowel" && segment.value.length == 1) && !(segment.type == "vowel" && segment.relIdx(1).value == "t") && segment.value != "eː")
                addE = true;
            if (segment.value == "v" && segment.relIdx(1).type == "consonant")
                addE = true;
            if (segment.value == "d͡ʒ" && (segment.relIdx(1).type == "consonant"))
                addE = true;
            if (segment.value == "iː" && segment.relIdx(1).value == "rˠ" && !segment.stressed && segment == word.at(-2))
                addE = true;
            if (finalE && segment == word.at(-1))
                addE = true;

            let doubleCons = segment.relIdx(-1).match("a", "e", "i", "ɔ", "u") && segment.relIdx(-1).stressed && (segment.relIdx(1).type == "vowel" || addE);

            switch (segment.value) {
                case "a":
                case "aː":
                    str += "a";
                    break;
                case "e":
                    str += "e";
                    break;
                case "ə":
                    if (
                        segment.relIdx(1).value == "ɫ" && segment.relIdx(-1).type == "consonant" && segment.i > 0 && !segment.relIdx(-1).match("m", "n", "v", "l", "r", "θ", "t͡ʃ", "ʃ", "d͡ʒ", "j", "w") && !(str.at(-1) == "s" && str.at(-2) != "s")
                        && !(segment.relIdx(2).type == "consonant" && !(segment == word.at(-3) && (word.sSuffix || word.pastTense)) && segment.relIdx(3).type != "vowel")
                    ) {
                        str += "le";
                        i++;
                    } else if (segment.i == 0 && segment.relIdx(1).stressed) {
                        str += "a";
                    } else if (segment.LMEValue == "oː" || segment.LMEValue == "ɔ" || (segment.relIdx(1).match("m", "p", "b", "k") && !segment.relIdx(1).stressed)) {
                        str += "o";
                    } else {
                        str += "e";
                    }
                    break;
                case "ɛː":
                    str += "ea";
                    break;
                case "eː":
                    if (segment.relIdx(1).match("ɫ", "n") && segment.relIdx(2).value == "d")
                        str += "ie";
                    else
                        str += "ee";
                    break;
                case "i":
                case "iː":
                    if (segment.droppedH)
                        str += "igh";
                    else if (!segment.stressed && segment.LMEValue == "e")
                        str += "e";
                    else if ((segment == word.at(-1) && !finalE) || segment.relIdx(1).value == "i")
                        str += "y";
                    else
                        str += "i";
                    break;
                case "ɔ":
                    str += "o";
                    break;
                case "ɔː":
                    if (
                        segment.relIdx(2).type == "vowel" || segment.relIdx(1).type != "consonant" || addE
                        || (word.droppedE && segment == word.at(-2))
                        || (segment == word.at(-3) && (word.sSuffix || word.pastTense))
                        || (segment.relIdx(1).value == "ɫ" && segment.relIdx(2).value == "d")
                        || (segment.relIdx(1).value == "m" && segment.relIdx(1).droppedB)
                        || (segment.relIdx(1).value == "rˠ" && segment.relIdx(2).value == "n")
                    )
                        str += "o";
                    else
                        str += "oa";
                    break;
                case "oː":
                    if (segment.relIdx(1).droppedB || (segment.relIdx(1).value == "m" && segment.relIdx(2).value == "b"))
                        str += "o";
                    else
                        str += "oo";
                    break;
                case "u":
                    if (segment.relIdx(-1).match("w", "v") || segment.relIdx(1).value == "v")
                        str += "o";
                    else if (segment.i == 0 && !modernTypography)
                        str += "v";
                    else
                        str += "u";
                    break;
                case "uː":
                    if (segment.droppedH)
                        str += "ough";
                    else if (segment.relIdx(1).match("m", "p", "b", "f", "v"))
                        str += "oo";
                    else if (
                        segment.relIdx(1).type == "consonant" && !addE
                        && !(segment.relIdx(1).match("n", "l", "ɫ") && ((segment.relIdx(2).type != "consonant") || segment.relIdx(2).value == "z"))
                        && !(word.sSuffix && segment.relIdx(1).value == "z" && segment == word.at(-2))
                    )
                        str += "ou";
                    else
                        str += "ow";
                    break;
                case "ɑu̯":
                    if (segment.droppedH && segment.LMEValue == "ɔu̯")
                        str += "ough";
                    else if (segment.droppedH)
                        str += "augh";
                    else if (
                        segment.relIdx(1).type == "consonant" && !addE
                        && !(segment.relIdx(1).match("n", "l", "ɫ") && ((segment.relIdx(2).type != "consonant") || segment.relIdx(2).value == "z"))
                        && !(word.sSuffix && segment.relIdx(1).value == "z" && segment == word.at(-2))
                    )
                        str += "au";
                    else
                        str += "aw";
                    break;
                case "æi̯":
                    if (segment.droppedH)
                        str += "eigh";
                    else if (segment.relIdx(1).type == "consonant" && !addE && !(word.sSuffix && segment.relIdx(1).value == "z" && segment == word.at(-2)))
                        str += "ai";
                    else
                        str += "ay";
                    break;
                case "ɛu̯":
                case "iu̯":
                    str += "ew";
                    break;
                case "ɔi̯":
                case "ui̯":
                    str += "oy";
                    break;
                case "ɔu̯":
                    if (segment.droppedH)
                        str += "ough";
                    else
                        str += "ow";
                    break;
                case "b":
                    if (doubleCons)
                        str += "bb";
                    else
                        str += "b";
                    break;
                case "t͡ʃ":
                    if (segment.relIdx(-1).match("a", "e", "i", "ɔ", "u") && segment.relIdx(-1).stressed)
                        str += "tch";
                    else
                        str += "ch";
                    break;
                case "d":
                    if (doubleCons)
                        str += "dd";
                    else
                        str += "d";
                    break;
                case "f":
                    if (segment.relIdx(-1).match("a", "e", "i", "ɔ", "u") && segment.relIdx(-1).stressed
                        && (segment.relIdx(1).type != "consonant" || (word.sSuffix && segment == word.at(-2)) || addE))
                        str += "ff";
                    else
                        str += "f";
                    break;
                case "g":
                    if (doubleCons)
                        str += "gg";
                    else
                        str += "g";
                    break;
                case "h":
                    if (segment.LMEValue == "xʷ")
                        str += "wh";
                    else
                        str += "h";
                    break;
                case "d͡ʒ":
                    if (segment.relIdx(-1).match("a", "e", "i", "ɔ", "u"))
                        str += "dg";
                    else
                        str += "g";
                    break;
                case "k":
                    if (segment.relIdx(1).value == "s" && !(segment == word.at(-2) && word.sSuffix)) {
                        str += "x";
                        i++;
                    } else if (segment.relIdx(1).value == "w") {
                        str += "qu";
                        i++;
                    } else if (segment.relIdx(-1).match("a", "e", "i", "ɔ", "u", "ə") && (!segment.stressed || segment.relIdx(1).value == "n") && (segment.relIdx(1).type != "consonant" || segment.relIdx(1).match("s", "n", "l", "h") || addE)) {
                        str += "ck";
                    } else if (
                        segment.relIdx(1).match("e", "ɛː", "eː", "i", "iː", "ɛu̯", "iu̯", "j", "n", "h")
                        || (segment.relIdx(1).value == "ə" && !segment.relIdx(2).match("m", "p", "b", "k"))
                        || addE || segment == word.at(-1) || (segment == word.at(-2) && word.sSuffix)
                    ) {
                        str += "k";
                    } else {
                        str += "c";
                    }
                    break;
                case "l":
                case "ɫ":
                    if (segment.relIdx(-1).match("a", "e", "i", "ɔ", "u") && segment.relIdx(-1).stressed && (segment.relIdx(1).type != "consonant" || (word.sSuffix && segment == word.at(-2)) || addE))
                        str += "ll";
                    else
                        str += "l";
                    break;
                case "m":
                    if (segment.droppedB)
                        str += "mb";
                    else if (segment.droppedN)
                        str += "mn";
                    else if (doubleCons)
                        str += "mm";
                    else
                        str += "m";
                    break;
                case "n":
                case "ŋ":
                    if (doubleCons)
                        str += "nn";
                    else
                        str += "n";
                    break;
                case "p":
                    if (doubleCons)
                        str += "pp";
                    else
                        str += "p";
                    break;
                case "r":
                case "rˠ":
                    if (doubleCons)
                        str += "rr";
                    else
                        str += "r";
                    break;
                case "s":
                    if (segment.relIdx(-1).match("a", "e", "i", "ɔ", "u", "ə") && !segment.stressed && (segment.relIdx(1).type != "consonant" || addE)) {
                        if (modernTypography)
                            str += "ss";
                        else
                            str += "ſſ";
                    } else if (segment.relIdx(-1).value == "iː" && (segment.relIdx(1).type == "vowel" || addE)) {
                        str += "c";
                    } else if ((segment == word.at(-1) && !addE) || modernTypography) {
                        str += "s";
                    } else {
                        str += "ſ";
                    }
                    break;
                case "ʃ":
                    if (modernTypography)
                        str += "sh";
                    else
                        str += "ſh";
                    break;
                case "t":
                    if (segment.relIdx(1).value == "θ")
                        break;
                    else if (((segment == word.at(-1) && word.pastTense) || (segment == word.at(-3) && word.conjPastTense)) && segment.relIdx(-1).type == "consonant")
                        str += "d";
                    else if (doubleCons)
                        str += "tt";
                    else
                        str += "t";
                    break;
                case "θ":
                case "ð":
                    str += "th";
                    break;
                case "v":
                    if (segment.i == 0 || modernTypography)
                        str += "v";
                    else
                        str += "u";
                    break;
                case "w":
                    str += "w";
                    break;
                case "xʷ":
                    str += "wh";
                    break;
                case "j":
                    str += "y";
                    break;
                case "z":
                    if ((segment == word.at(-1) && !addE) || modernTypography)
                        str += "s";
                    else
                        str += "ſ";
                    break;
            }
            if (addE)
                str += "e";
        }

        return str;
    }

    function getSpelling_MSc(word) {
        word = word.EModEWord;
        let str = "";

        let finalE = false;
        if (word.at(-2)?.value == "iː" && word.at(-1).type == "consonant" && !word.sSuffix && !word.pastTense && !(word.at(-1).value == "rˠ" && !word.at(-2).stressed))
            finalE = true;
        if (word.droppedE && word.at(-2)?.match("aː", "ɛː", "ɔː", "oː", "øː") && word.at(-1).type == "consonant" && !word.sSuffix && !word.pastTense)
            finalE = true;
        if (word.at(-1).match("ð", "v", "d͡ʒ") || (word.at(-1).value == "z" && word.at(-2).type == "vowel" && word.at(-2).value.length > 1 && word.at(-2).stressed && !word.sSuffix))
            finalE = true;
        if (word.at(-1).match("s", "z") && word.at(-2).type == "consonant" && !word.sSuffix)
            finalE = true;

        for (let i = 0; i < word.length; i++) {
            let segment = word[i];

            let addE = false;
            if (segment.value == "v" && segment.relIdx(1).type == "consonant")
                addE = true;
            if (segment.value == "d͡ʒ" && (segment.relIdx(1).type == "consonant"))
                addE = true;
            if (segment.value == "iː" && segment.relIdx(1).value == "rˠ" && !segment.stressed && segment == word.at(-2))
                addE = true;
            if (finalE && segment == word.at(-1))
                addE = true;

            let addI = false;
            if (segment == word.at(-2) && word.sSuffix && !segment.match("ɪ", "eː", "ɛː"))
                addI = true;

            let doubleCons = segment.relIdx(-1).match("a", "e", "ɪ", "ɔ", "u") && segment.relIdx(-1).stressed && (segment.relIdx(1).type == "vowel" || addE || addI);

            switch (segment.value) {
                case "a":
                    str += "a";
                    break;
                case "aː":
                    if (segment.relIdx(2).type == "vowel" || segment.relIdx(1).type != "consonant" || addE || addI || (finalE && segment == word.at(-2)) || (word.sSuffix && segment == word.at(-3)) || segment.relIdx(1).value == "ɫ")
                        str += "a";
                    else
                        str += "ai";
                    break;
                case "e":
                    str += "e";
                    break;
                case "ə":
                    if (segment.i == 0 && segment.relIdx(1).stressed)
                        str += "a";
                    else if (segment.LMEValue == "ɔ" || (segment.relIdx(1).match("m", "p", "b", "k") && !segment.relIdx(1).stressed))
                        str += "o";
                    else
                        str += "e";
                    break;
                case "ɛː":
                case "eː":
                    if (segment.relIdx(2).type == "vowel" || segment.relIdx(1).type != "consonant" || addE || addI || (finalE && segment == word.at(-2)) || (word.sSuffix && segment == word.at(-3)))
                        str += "e";
                    else
                        str += "ei";
                    break;
                case "ɪ":
                case "iː":
                    if (!segment.stressed && segment.LMEValue == "e")
                        str += "e";
                    else if ((segment == word.at(-1) && !finalE) || segment.relIdx(1).value == "ɪ")
                        str += "y";
                    else
                        str += "i";
                    break;
                case "ɔ":
                case "ɔː":
                    str += "o";
                    break;
                case "øː":
                    if (segment.relIdx(2).type == "vowel" || segment.relIdx(1).type != "consonant" || addE || addI || (finalE && segment == word.at(-2)) || (word.sSuffix && segment == word.at(-3))) {
                        if (segment.i == 0 && !modernTypography)
                            str += "v";
                        else
                            str += "u";
                    } else {
                        if (segment.i == 0 && !modernTypography)
                            str += "vi";
                        else
                            str += "ui";
                    }
                    break;
                case "u":
                    if (segment.relIdx(-1).match("w", "v"))
                        str += "o";
                    else if (segment.i == 0 && !modernTypography)
                        str += "v";
                    else
                        str += "u";
                    break;
                case "uː":
                    if (segment.relIdx(1).type == "consonant" && !addE && !addI && !(word.sSuffix && segment.relIdx(1).value == "z" && segment == word.at(-2)))
                        str += "ou";
                    else
                        str += "ow";
                    break;
                case "ɑu̯":
                    if (segment.relIdx(1).type == "consonant" && !addE && !addI && !(word.sSuffix && segment.relIdx(1).value == "z" && segment == word.at(-2)))
                        str += "au";
                    else
                        str += "aw";
                    break;
                case "æi̯":
                    if (segment.relIdx(1).type == "consonant" && !addE && !addI && !(word.sSuffix && segment.relIdx(1).value == "z" && segment == word.at(-2)))
                        str += "ai";
                    else
                        str += "ay";
                    break;
                case "ɛu̯":
                case "iu̯":
                    if (segment.relIdx(1).type == "consonant" && !addE && !addI && !(word.sSuffix && segment.relIdx(1).value == "z" && segment == word.at(-2)))
                        str += "eu";
                    else
                        str += "ew";
                    break;
                case "ɔi̯":
                case "ui̯":
                    if (segment.relIdx(1).type == "consonant" && !addE && !addI && !(word.sSuffix && segment.relIdx(1).value == "z" && segment == word.at(-2)))
                        str += "oi";
                    else
                        str += "oy";
                    break;
                case "ɔu̯":
                    str += "ow";
                    break;
                case "b":
                    if (doubleCons)
                        str += "bb";
                    else
                        str += "b";
                    break;
                case "t͡ʃ":
                case "x":
                case "ç":
                    str += "ch";
                    break;
                case "d":
                    if (doubleCons)
                        str += "dd";
                    else
                        str += "d";
                    break;
                case "f":
                    if (segment.relIdx(-1).match("a", "e", "ɪ", "ɔ", "u") && segment.relIdx(-1).stressed
                        && (segment.relIdx(1).type != "consonant" || (word.sSuffix && segment == word.at(-2)) || addE || addI))
                        str += "ff";
                    else
                        str += "f";
                    break;
                case "g":
                    if (doubleCons)
                        str += "gg";
                    else
                        str += "g";
                    break;
                case "h":
                    if (segment.LMEValue == "xʷ")
                        str += "wh";
                    else
                        str += "h";
                    break;
                case "d͡ʒ":
                    str += "g";
                    break;
                case "k":
                    if (segment.relIdx(1).value == "s" && !(segment == word.at(-2) && word.sSuffix)) {
                        str += "x";
                        i++;
                    } else if (segment.relIdx(1).value == "w") {
                        str += "qu";
                        i++;
                    } else if (doubleCons) {
                        str += "kk";
                    } else if (
                        segment.relIdx(1).match("e", "ɛː", "eː", "ɪ", "iː", "ɛu̯", "iu̯", "j", "n", "h")
                        || (segment.relIdx(1).value == "ə" && !segment.relIdx(2).match("m", "p", "b", "k"))
                        || addE || addI || segment == word.at(-1) || (segment == word.at(-2) && word.sSuffix)
                    ) {
                        str += "k";
                    } else {
                        str += "c";
                    }
                    break;
                case "l":
                case "ɫ":
                    if (doubleCons || (segment.relIdx(-1).type == "vowel" && segment.relIdx(1).type != "consonant" && segment.relIdx(-1).i > word.stressedVowel.i))
                        str += "ll";
                    else
                        str += "l";
                    break;
                case "m":
                    if (doubleCons)
                        str += "mm";
                    else
                        str += "m";
                    break;
                case "n":
                    if (segment.ing)
                        str += "ng";
                    else if (segment.droppedD)
                        str += "nd";
                    else if (doubleCons)
                        str += "nn";
                    else
                        str += "n";
                    break;
                case "ŋ":
                    if (segment.relIdx(1).value == "k")
                        str += "n";
                    else
                        str += "ng";
                    break;
                case "p":
                    if (doubleCons)
                        str += "pp";
                    else
                        str += "p";
                    break;
                case "r":
                case "rˠ":
                    if (doubleCons)
                        str += "rr";
                    else
                        str += "r";
                    break;
                case "s":
                    if (segment.relIdx(-1).match("a", "e", "ɪ", "ɔ", "u", "ə") && !segment.stressed && (segment.relIdx(1).type != "consonant" || addE || addI)) {
                        if (modernTypography)
                            str += "ss";
                        else
                            str += "ſſ";
                    } else if (segment.relIdx(-1).value == "iː" && (segment.relIdx(1).type == "vowel" || addE || addI)) {
                        str += "c";
                    } else if ((segment == word.at(-1) && !addI) || modernTypography) {
                        str += "s";
                    } else {
                        str += "ſ";
                    }
                    break;
                case "ʃ":
                    if (modernTypography)
                        str += "sch";
                    else
                        str += "ſch";
                    break;
                case "t":
                    if (segment.relIdx(1).value == "θ")
                        break;
                    else if (doubleCons)
                        str += "tt";
                    else
                        str += "t";
                    break;
                case "θ":
                case "ð":
                    str += "th";
                    break;
                case "v":
                case "w":
                    if (segment.i == 0 || modernTypography)
                        str += "v";
                    else
                        str += "u";
                    break;
                case "xʷ":
                    str += "quh";
                    break;
                case "j":
                    str += "y";
                    break;
                case "z":
                    if ((segment == word.at(-1) && !addE) || modernTypography)
                        str += "s";
                    else
                        str += "ſ";
                    break;
            }
            if (addE)
                str += "e";
            if (addI)
                str += "i";
        }

        return str;
    }

    function getSpelling_ModE(word) {
        let str = "";

        let finalE = false;
        if (
            word.at(-2)?.match("aː", "iː") && !word.at(-2).droppedH && word.at(-1).type == "consonant" && !word.sSuffix && !word.pastTense && !word.at(-1).droppedB
            && !(word.at(-2).value == "iː" && !word.at(-2).stressed && word.at(-1).value == "rˠ")
        )
            finalE = true;
        if (word.at(-2)?.value == "ɔː" && word.at(-1).type == "consonant" && word.droppedE && !word.sSuffix)
            finalE = true;
        if (word.at(-1).match("v", "d͡ʒ") || (word.at(-1).match("ð", "z") && word.at(-2).type == "vowel" && word.at(-2).value.length > 1 && word.at(-2).stressed && !word.sSuffix))
            finalE = true;
        if (word.at(-1).value == "ð" && word.vowels.at(-1).stressed)
            finalE = true;
        if (word.at(-1).value == "s" && word.at(-2)?.type == "vowel" && word.at(-2).value.length > 1)
            finalE = true;
        if (word.at(-1).match("s", "z") && word.at(-2)?.type == "consonant" && !word.at(-2).match("k", "v") && !word.sSuffix)
            finalE = true;

        for (let i = 0; i < word.length; i++) {
            let segment = word[i];

            let addE = false;
            if (segment == word.at(-2) && segment.relIdx(-1).match("aː", "iː", "ɔː") && word.sSuffix && !segment.relIdx(-1).droppedH)
                addE = true;
            if (segment == word.at(-2) && (segment.match("aː", "iː", "ɔː") || (segment.match("eː", "ɛː") && !segment.stressed)) && word.sSuffix && !segment.droppedH)
                addE = true;
            if (segment == word.at(-2) && word.pastTense && !(segment.type == "vowel" && segment.value.length == 1) && !(segment.type == "vowel" && segment.relIdx(1).value == "t") && !(segment.value == "eː" && segment.stressed))
                addE = true;
            if (segment == word.at(-4) && word.conjPastTense && !(segment.type == "vowel" && segment.value.length == 1) && !(segment.type == "vowel" && segment.relIdx(1).value == "t") && segment.value != "eː")
                addE = true;
            if (segment.value == "v" && segment.relIdx(1).type == "consonant")
                addE = true;
            if (segment.value == "d͡ʒ" && (segment.relIdx(1).type == "consonant"))
                addE = true;
            if (segment.value == "iː" && segment.relIdx(1).value == "rˠ" && !segment.stressed && segment == word.at(-2))
                addE = true;
            if (finalE && segment == word.at(-1))
                addE = true;

            let doubleCons = segment.relIdx(-1).match("a", "e", "i", "ɔ", "u") && segment.relIdx(-1).stressed && (segment.relIdx(1).type == "vowel" || addE);

            switch (segment.value) {
                case "a":
                case "aː":
                    str += "a";
                    break;
                case "e":
                    str += "e";
                    break;
                case "ə":
                    if (
                        segment.relIdx(1).value == "ɫ" && segment.relIdx(-1).type == "consonant" && segment.i > 0
                        && !segment.relIdx(-1).match("m", "n", "v", "l", "r", "θ", "t͡ʃ", "ʃ", "d͡ʒ", "j", "w") && !(str.at(-1) == "s" && str.at(-2) != "s")
                        && !(segment.relIdx(2).type == "consonant" && !(segment == word.at(-3) && (word.sSuffix || word.pastTense))
                            && segment.relIdx(3).type != "vowel")
                    ) {
                        str += "le";
                        i++;
                    } else if (segment.i == 0 && segment.relIdx(1).stressed) {
                        str += "a";
                    } else if (segment.LMEValue == "oː" || segment.LMEValue == "ɔ" || (segment.relIdx(1).match("m", "p", "b", "k") && !segment.relIdx(1).stressed)) {
                        str += "o";
                    } else {
                        str += "e";
                    }
                    break;
                case "ɛː":
                    if (!segment.stressed && (segment == word.at(-1) || segment.relIdx(1).value == "i"))
                        str += "y";
                    else if (!segment.stressed && (segment.relIdx(1).type == "vowel" || addE))
                        str += "i";
                    else
                        str += "ea";
                    break;
                case "eː":
                    if (!segment.stressed && (segment == word.at(-1) || segment.relIdx(1).value == "i"))
                        str += "y";
                    else if (!segment.stressed && (segment.relIdx(1).type == "vowel" || addE))
                        str += "i";
                    else if (segment.relIdx(1).match("ɫ", "n") && segment.relIdx(2).value == "d")
                        str += "ie";
                    else
                        str += "ee";
                    break;
                case "i":
                case "iː":
                    if (segment.droppedH)
                        str += "igh";
                    else if (!segment.stressed && segment.LMEValue == "e")
                        str += "e";
                    else if (segment == word.at(-1) || segment.relIdx(1).value == "i")
                        str += "y";
                    else
                        str += "i";
                    break;
                case "ɔ":
                    str += "o";
                    break;
                case "ɔː":
                    if (
                        segment.relIdx(2).type == "vowel" || segment.relIdx(1).type != "consonant"
                        || addE || (finalE && segment == word.at(-2))
                        || (segment == word.at(-3) && (word.sSuffix || word.pastTense))
                        || (segment.relIdx(1).value == "m" && segment.relIdx(1).droppedB)
                        || (segment.relIdx(1).value == "rˠ" && segment.relIdx(2).value == "n")
                    )
                        str += "o";
                    else
                        str += "oa";
                    break;
                case "oː":
                    if (segment.relIdx(1).droppedB || (segment.relIdx(1).value == "m" && segment.relIdx(2).value == "b") || (segment.relIdx(1).value == "rˠ" && segment.relIdx(2).value == "d"))
                        str += "o";
                    else
                        str += "oo";
                    break;
                case "u":
                    if (segment.relIdx(-1).match("w", "v") || segment.relIdx(1).value == "v")
                        str += "o";
                    else
                        str += "u";
                    break;
                case "uː":
                    if (segment.droppedH)
                        str += "ough";
                    else if (segment.relIdx(1).match("m", "p", "b", "f", "v"))
                        str += "oo";
                    else if (
                        segment.relIdx(1).type == "consonant" && !addE
                        && !(segment.relIdx(1).match("n", "l", "ɫ") && ((segment.relIdx(2).type != "consonant") || segment.relIdx(2).value == "z"))
                        && !(word.sSuffix && segment.relIdx(1).value == "z" && segment == word.at(-2))
                    )
                        str += "ou";
                    else
                        str += "ow";
                    break;
                case "ɑu̯":
                    if (segment.droppedH && segment.LMEValue == "ɔu̯")
                        str += "ough";
                    else if (segment.droppedH)
                        str += "augh";
                    else if (
                        segment.relIdx(1).type == "consonant" && !addE
                        && !(segment.relIdx(1).match("n", "l", "ɫ") && ((segment.relIdx(2).type != "consonant") || segment.relIdx(2).value == "z"))
                        && !(word.sSuffix && segment.relIdx(1).value == "z" && segment == word.at(-2))
                    )
                        str += "au";
                    else
                        str += "aw";
                    break;
                case "æi̯":
                    if (segment.droppedH)
                        str += "eigh";
                    else if (segment.relIdx(1).type == "consonant" && !addE && !(word.sSuffix && segment.relIdx(1).value == "z" && segment == word.at(-2)))
                        str += "ai";
                    else
                        str += "ay";
                    break;
                case "ɛu̯":
                case "iu̯":
                    str += "ew";
                    break;
                case "ɔi̯":
                case "ui̯":
                    if (segment.relIdx(1).type == "consonant" && !addE && !(word.sSuffix && segment.relIdx(1).value == "z" && segment == word.at(-2)))
                        str += "oi";
                    else
                        str += "oy";
                    break;
                case "ɔu̯":
                    if (segment.droppedH)
                        str += "ough";
                    else
                        str += "ow";
                    break;
                case "b":
                    if (doubleCons)
                        str += "bb";
                    else
                        str += "b";
                    break;
                case "t͡ʃ":
                    if (segment.relIdx(-1).match("a", "e", "i", "ɔ", "u") && segment.relIdx(-1).stressed)
                        str += "tch";
                    else
                        str += "ch";
                    break;
                case "d":
                    if (doubleCons)
                        str += "dd";
                    else
                        str += "d";
                    break;
                case "f":
                    if (segment.relIdx(-1).match("a", "e", "i", "ɔ", "u") && segment.relIdx(-1).stressed
                        && (segment.relIdx(1).type != "consonant" || (word.sSuffix && segment == word.at(-2)) || addE))
                        str += "ff";
                    else
                        str += "f";
                    break;
                case "g":
                    if (doubleCons)
                        str += "gg";
                    else
                        str += "g";
                    break;
                case "h":
                    if (segment.LMEValue == "xʷ")
                        str += "wh";
                    else
                        str += "h";
                    break;
                case "d͡ʒ":
                    if (segment.relIdx(-1).match("a", "e", "i", "ɔ", "u"))
                        str += "dg";
                    else
                        str += "g";
                    break;
                case "k":
                    if (segment.relIdx(1).value == "s" && !(segment == word.at(-2) && word.sSuffix)) {
                        str += "x";
                        i++;
                    } else if (segment.relIdx(1).value == "w") {
                        str += "qu";
                        i++;
                    } else if (segment.relIdx(-1).match("a", "e", "i", "ɔ", "u", "ə") && (!segment.stressed || segment.relIdx(1).value == "n") && (segment.relIdx(1).type != "consonant" || segment.relIdx(1).match("s", "n", "l", "h") || addE)) {
                        str += "ck";
                    } else if (
                        segment.relIdx(1).match("e", "ɛː", "eː", "i", "iː", "ɛu̯", "iu̯", "j", "n", "h")
                        || (segment.relIdx(1).value == "ə" && !segment.relIdx(2).match("m", "p", "b", "k"))
                        || addE || segment == word.at(-1) || (segment == word.at(-2) && word.sSuffix)
                    ) {
                        str += "k";
                    } else {
                        str += "c";
                    }
                    break;
                case "l":
                case "ɫ":
                    if (segment.relIdx(-1).match("a", "e", "i", "ɔ", "u") && segment.relIdx(-1).stressed && (segment.relIdx(1).type != "consonant" || (word.sSuffix && segment == word.at(-2)) || addE))
                        str += "ll";
                    else
                        str += "l";
                    break;
                case "m":
                    if (segment.droppedB)
                        str += "mb";
                    else if (segment.droppedN)
                        str += "mn";
                    else if (doubleCons)
                        str += "mm";
                    else
                        str += "m";
                    break;
                case "n":
                case "ŋ":
                    if (doubleCons)
                        str += "nn";
                    else
                        str += "n";
                    break;
                case "p":
                    if (doubleCons)
                        str += "pp";
                    else
                        str += "p";
                    break;
                case "r":
                case "rˠ":
                    if (doubleCons)
                        str += "rr";
                    else
                        str += "r";
                    break;
                case "s":
                    if (segment.relIdx(-1).match("a", "e", "i", "ɔ", "u", "ə") && !segment.stressed && (segment.relIdx(1).type != "consonant" || addE))
                        str += "ss";
                    else if (segment.relIdx(-1).value == "iː" && (segment.relIdx(1).type == "vowel" || addE))
                        str += "c";
                    else
                        str += "s";
                    break;
                case "ʃ":
                    str += "sh";
                    break;
                case "t":
                    if (segment.relIdx(1).value == "θ")
                        break;
                    else if (((segment == word.at(-1) && word.pastTense) || (segment == word.at(-3) && word.conjPastTense)) && segment.relIdx(-1).type == "consonant")
                        str += "d";
                    else if (doubleCons)
                        str += "tt";
                    else
                        str += "t";
                    break;
                case "θ":
                case "ð":
                    str += "th";
                    break;
                case "v":
                    str += "v";
                    break;
                case "w":
                    str += "w";
                    break;
                case "xʷ":
                    str += "wh";
                    break;
                case "j":
                    str += "y";
                    break;
                case "z":
                    if (segment.relIdx(-1).match("a", "e", "i", "ɔ", "u") && segment.relIdx(-1).stressed && (segment.relIdx(1).type != "consonant" || addE))
                        str += "zz";
                    else
                        str += "s";
                    break;
            }
            if (addE)
                str += "e";
        }

        return str;
    }

    function getSpelling_ModSc(scotsWord) {
        let word = scotsWord.duplicate();
        word.remove("ʔ");
        let str = "";

        let longVowels = ["əi̯", "aɪ̯", "i", "iː", "e", "eː", "o", "oː", "u", "uː", "ʏ", "øː", "oɪ̯", "ɑː", "ʌu̯"];
        let shortVowels = ["a", "aː", "ɛ", "ɛː", "ɪ", "ɔ", "ɔː", "ʌ", "ə"];

        let finalE = false;
        if (word.at(-2)?.match("əi̯", "aɪ̯") && word.at(-2).LMEValue == "iː" && word.at(-1).type == "consonant" && !word.sSuffix && !word.pastTense)
            finalE = true;
        if (word.at(-2)?.match("e", "eː") && word.at(-1).type == "consonant" && word.droppedE && !word.sSuffix && !word.pastTense && word.at(-2).LMEValue != "æi̯")
            finalE = true;
        if (word.at(-2)?.match("o", "oː") && word.at(-1).type == "consonant" && !word.sSuffix && !word.pastTense)
            finalE = true;
        if (word.at(-1).match("v", "ð", "d͡ʒ", "ʒ") || (word.at(-1).value == "z" && word.at(-2).type == "vowel" && !word.sSuffix))
            finalE = true;
        if (word.at(-1).value == "s" && word.at(-2)?.match(...longVowels))
            finalE = true;
        if (word.at(-1).match("s", "z") && word.at(-2)?.type == "consonant" && !word.at(-2).match("k", "v") && !word.sSuffix)
            finalE = true;
        if (word.at(-1).value == "ʌu̯")
            finalE = true;

        for (let i = 0; i < word.length; i++) {
            let segment = word[i];

            let addE = false;
            if (segment == word.at(-2) && segment.relIdx(-1).match("e", "eː", "əi̯", "aɪ̯", "o", "oː", "ʌu̯") && !(segment.relIdx(-1).match("əi̯", "aɪ̯") && segment.relIdx(-1).LMEValue != "iː") && word.sSuffix)
                addE = true;
            if (segment == word.at(-2) && segment.match("eː", "aɪ̯", "ʌu̯") && word.sSuffix)
                addE = true;
            if (segment == word.at(-2) && word.pastTense && segment.value != "ɪ" && !shortVowels.includes(segment.value) && !segment.match("e", "eː", "i", "iː") && segment.relIdx(1).value == "d")
                addE = true;
            if (segment == word.at(-4) && word.conjPastTense && segment.value != "ɪ" && !shortVowels.includes(segment.value) && !segment.match("e", "eː", "i", "iː") && segment.relIdx(1).value == "d")
                addE = true;
            if (segment.value == "v" && segment.relIdx(1).type == "consonant")
                addE = true;
            if (segment.value == "d͡ʒ" && (segment.relIdx(1).type == "consonant"))
                addE = true;
            if (segment.value == "iː" && segment.relIdx(1).value == "rˠ" && !segment.stressed && segment == word.at(-2))
                addE = true;
            if (finalE && segment == word.at(-1))
                addE = true;

            let doubleCons = segment.relIdx(-1).match(...shortVowels) && segment.relIdx(-1).stressed && (segment.relIdx(1).type == "vowel" || addE);

            switch (segment.value) {
                case "əi̯":
                case "aɪ̯":
                    if (segment.LMEValue == "iː" && (segment == word.at(-1) || segment.relIdx(1).LMEValue == "i" || (segment.relIdx(1).inSuffix && word.partOfSpeech != "pastPtcp")))
                        str += "y";
                    else if (segment.LMEValue == "iː")
                        str += "i";
                    else
                        str += "ey";
                    break;
                case "i":
                case "iː":
                    if (segment.LMEValue == "eː")
                        str += "ee";
                    else
                        str += "ei";
                    break;
                case "e":
                case "eː":
                    if (segment.relIdx(1).value == "ə" && segment.relIdx(2).value == "ɾ")
                        str += "i";
                    else if ((segment == word.at(-1) || (segment == word.at(-2) && (word.sSuffix || word.pastTense))) && (segment.LMEValue == "iː" || segment.LMEValue == "i"))
                        str += "ie";
                    else if (segment == word.at(-1) || (segment == word.at(-2) && (word.sSuffix || word.pastTense)) && !addE)
                        str += "ae";
                    else if ((segment.relIdx(2).type == "vowel" || segment.relIdx(1).type != "consonant" || addE || (finalE && segment == word.at(-2)) || (segment == word.at(-3) && (word.sSuffix || word.pastTense))) && segment.LMEValue != "æi̯")
                        str += "a";
                    else if (segment.relIdx(1).type == "vowel")
                        str += "ay";
                    else
                        str += "ai";
                    break;
                case "o":
                case "oː":
                    str += "o";
                    break;
                case "u":
                case "uː":
                    if ((segment.LMEValue == "ɛu̯" || segment.LMEValue == "iu̯") && segment.relIdx(1).type != "consonant")
                        str += "ew";
                    else if (segment.LMEValue == "øː" || segment.LMEValue == "ɛu̯" || segment.LMEValue == "iu̯")
                        str += "eu";
                    else
                        str += "ou";
                    break;
                case "ʏ":
                case "øː":
                    str += "ui";
                    break;
                case "oɪ̯":
                    if (segment.relIdx(1).type == "consonant" && !addE && !(word.sSuffix && segment.relIdx(1).value == "z" && segment == word.at(-2)))
                        str += "oi";
                    else
                        str += "oy";
                    break;
                case "ɑː":
                    if (segment.LMEValue == "aː" && segment.relIdx(1).value != "ɫ")
                        str += "a";
                    else if (segment.relIdx(1).type == "consonant" && !addE && segment.relIdx(1).value != "k" && !(word.sSuffix && segment.relIdx(1).value == "z" && segment == word.at(-2)))
                        str += "au";
                    else
                        str += "aw";
                    break;
                case "ʌu̯":
                    str += "ow";
                    break;
                case "ɪ":
                    if (word.sSuffix && segment == word.at(-2))
                        str += "e";
                    else
                        str += "i";
                    break;
                case "ɛ":
                case "ɛː":
                    str += "e";
                    break;
                case "a":
                case "aː":
                    str += "a";
                    break;
                case "ɔ":
                case "ɔː":
                    str += "o";
                    break;
                case "ʌ":
                    str += "u";
                    break;
                case "ə":
                    if (segment.stressed || (segment.inSuffix && word.partOfSpeech != "pastPtcp") || (segment.LMEValue == "ɪ" && segment.relIdx(1).value == "n" && segment.i > word.stressedVowel.i)) {
                        str += "i";
                    } else if (
                        segment.relIdx(1).value == "ɫ" && segment.relIdx(-1).type == "consonant" && segment.relIdx(2).type != "vowel" && segment.i > 0
                        && !segment.relIdx(-1).match("v", "l", "r", "θ", "t͡ʃ", "ʃ", "d͡ʒ", "j", "w")
                        && !(str.at(-1) == "s" && str.at(-2) != "s")
                        && !(segment.relIdx(2).type == "consonant" && !(segment == word.at(-3) && word.sSuffix) && segment.relIdx(3).type != "vowel")
                    ) {
                        str += "le";
                        i++;
                    } else if (segment.i == 0 && (segment.relIdx(1).stressed || (segment.relIdx(1).value == "k" && segment.relIdx(2).value == "n") && segment.relIdx(2).stressed)) {
                        str += "a";
                    } else if (segment.LMEValue == "øː" || segment.LMEValue == "ɔ" || (segment.relIdx(1).match("m", "p", "b", "k") && !segment.relIdx(1).stressed)) {
                        str += "o";
                    } else {
                        str += "e";
                    }
                    break;
                case "b":
                    if (doubleCons)
                        str += "bb";
                    else
                        str += "b";
                    break;
                case "t͡ʃ":
                    if (segment.relIdx(-1).match(...shortVowels) && segment.relIdx(-1).stressed)
                        str += "tch";
                    else
                        str += "ch";
                    break;
                case "x":
                case "ç":
                    if (segment.relIdx(1).value == "j")
                        str += "h";
                    else
                        str += "ch";
                    break;
                case "d":
                    if (doubleCons)
                        str += "dd";
                    else
                        str += "d";
                    break;
                case "f":
                    if (segment.relIdx(-1).match(...shortVowels) && segment.relIdx(-1).stressed
                        && (segment.relIdx(1).type != "consonant" || (word.sSuffix && segment == word.at(-2)) || addE))
                        str += "ff";
                    else
                        str += "f";
                    break;
                case "g":
                    if (doubleCons)
                        str += "gg";
                    else
                        str += "g";
                    break;
                case "h":
                    str += "h";
                    break;
                case "d͡ʒ":
                case "ʒ":
                    if (segment.relIdx(-1).match(...shortVowels))
                        str += "dg";
                    else
                        str += "g";
                    break;
                case "k":
                    if (segment.relIdx(1).value == "s" && !(segment == word.at(-2) && word.sSuffix)) {
                        str += "x";
                        i++;
                    } else if (segment.relIdx(1).value == "w") {
                        str += "qu";
                        i++;
                    } else if (segment.relIdx(-1).match(...shortVowels) && !segment.stressed && (segment.relIdx(1).type != "consonant" || segment.relIdx(1).match("s", "n", "l", "h") || addE)) {
                        str += "ck";
                    } else if (
                        segment.relIdx(1).match("e", "eː", "ɛ", "ɛː", "i", "iː", "ɪ", "əi̯", "aɪ̯", "ɚ", "ɫ̩", "n̩", "j", "n", "h")
                        || (segment.relIdx(1).value == "ə" && (segment.stressed || !segment.relIdx(2).match("m", "p", "b", "k")))
                        || segment == word.at(-1)
                        || (segment == word.at(-2) && word.sSuffix)
                    ) {
                        str += "k";
                    } else {
                        str += "c";
                    }
                    break;
                case "ɫ":
                    if (segment.droppedD)
                        str += "ld";
                    else if (segment.relIdx(-1).match(...shortVowels) && segment.relIdx(-1).stressed
                        && (segment.relIdx(1).type != "consonant" || (segment.relIdx(1).value == "z") || addE))
                        str += "ll";
                    else
                        str += "l";
                    break;
                case "m":
                    if (doubleCons)
                        str += "mm";
                    else
                        str += "m";
                    break;
                case "n":
                    if (segment.droppedD && segment.relIdx(-1).stressed && (segment.relIdx(1).type != "vowel" || segment.relIdx(1).inSuffix))
                        str += "nd";
                    else if (segment.droppedK)
                        str += "kn";
                    else if (segment.droppedG)
                        str += "gn";
                    else if (doubleCons)
                        str += "nn";
                    else
                        str += "n";
                    break;
                case "ŋ":
                    if (segment.relIdx(1).value == "k")
                        str += "n";
                    else
                        str += "ng";
                    break;
                case "p":
                    if (doubleCons)
                        str += "pp";
                    else
                        str += "p";
                    break;
                case "ɾ":
                    if (segment.droppedW)
                        str += "wr";
                    else if (doubleCons)
                        str += "rr";
                    else
                        str += "r";
                    break;
                case "s":
                    if (segment.relIdx(-1).match(...shortVowels) && !segment.stressed && (segment.relIdx(1).type != "consonant" || addE))
                        str += "ss";
                    else if (segment.relIdx(-1).value == "əi̯" && (segment.relIdx(1).value == "ə" || addE))
                        str += "c";
                    else
                        str += "s";
                    break;
                case "ʃ":
                    if (segment.relIdx(-1).value == "n")
                        str += "ch";
                    else
                        str += "sh";
                    break;
                case "t":
                    if (segment.relIdx(1).value == "θ")
                        break;
                    else if (doubleCons)
                        str += "tt";
                    else
                        str += "t";
                    break;
                case "θ":
                case "ð":
                    str += "th";
                    break;
                case "v":
                    str += "v";
                    break;
                case "w":
                    str += "w";
                    break;
                case "xʷ":
                    str += "wh";
                    break;
                case "j":
                    if (!(segment.relIdx(1).match("u", "uː") && !segment.LMEValue))
                        str += "y";
                    break;
                case "z":
                    str += "s";
                    break;
            }
            if (addE)
                str += "e";
        }

        return str;
    }

    function getSpelling_lat() {
        let str = wordArg;
        str = str.replaceAll("ā", "a");
        str = str.replaceAll("ē", "e");
        str = str.replaceAll("ī", "i");
        str = str.replaceAll("ō", "o");
        str = str.replaceAll("ū", "u");
        str = str.replaceAll("ȳ", "y");

        if (modernTypography) {
            str = str.replaceAll(/^i(?=[aeiouy])/g, "j");
            str = str.replaceAll(/(?<=[aeiouy])i(?=[aeiouy])/g, "j");
        }
        else {
            str = str.replaceAll("u", "v");
        }

        return str;
    }

    function getSpelling_OSp() {
        let str = "";
        for (let i = 0; i < word.length; i++) {
            let segment = word[i];
            switch (segment.value) {
                case "a":
                    str += "a";
                    break;
                case "e":
                    str += "e";
                    break;
                case "i":
                case "j":
                    if (segment.relIdx(-1).type != "consonant" || segment == word.at(-1))
                        str += "y";
                    else
                        str += "i";
                    break;
                case "o":
                    str += "o";
                    break;
                case "u":
                    str += "u";
                    break;
                case "w":
                    if (segment.relIdx(-1).type != "consonant")
                        str += "h";
                    str += "u";
                    break;
                case "b":
                    str += "b";
                    break;
                case "t͡s":
                    if (segment.relIdx(1).match("e", "i", "j"))
                        str += "c";
                    else if (segment.relIdx(1).type == "vowel" || segment.relIdx(1).value == "w")
                        str += "ç";
                    else
                        str += "z";
                    break;
                case "t͡ʃ":
                    str += "ch";
                    break;
                case "d":
                case "ð":
                    str += "d";
                    break;
                case "h":
                case "ɸ":
                    str += "f";
                    break;
                case "g":
                case "ɣ":
                    if (segment.relIdx(1).match("e", "i", "j"))
                        str += "gu";
                    else
                        str += "g";
                    break;
                case "ʒ":
                    if (segment.relIdx(1).match("e", "i", "j"))
                        str += "g";
                    else
                        str += "j";
                    break;
                case "k":
                    if (segment.relIdx(1).match("e", "i", "j"))
                        str += "qu";
                    else if (segment.relIdx(1).value == "w" && !segment.relIdx(2).match("e", "i", "j"))
                        str += "q";
                    else
                        str += "c";
                    break;
                case "l":
                    str += "l";
                    break;
                case "ʎ":
                    str += "ll";
                    break;
                case "m":
                    str += "m";
                    break;
                case "n":
                case "ŋ":
                    str += "n";
                    break;
                case "ɲ":
                    str += "nn";
                    break;
                case "p":
                    str += "p";
                    break;
                case "ɾ":
                    str += "r";
                    break;
                case "r":
                    if (segment.relIdx(-1).type == "vowel" || segment.relIdx(-1).match("j", "w"))
                        str += "rr";
                    else
                        str += "r";
                    break;
                case "s̺":
                    if ((segment.relIdx(-1).type == "vowel" || segment.relIdx(-1).match("j", "w")) && (segment.relIdx(1).type == "vowel" || segment.relIdx(1).match("j", "w")))
                        str += "ss";
                    else
                        str += "s";
                    break;
                case "z̺":
                    str += "s";
                    break;
                case "t":
                    str += "t";
                    break;
                case "β":
                    if (segment.relIdx(1).type == "consonant" && !segment.relIdx(1).match("j", "w"))
                        str += "b";
                    else
                        str += "v";
                    break;
                case "ʃ":
                    str += "x";
                    break;
                case "ʝ":
                    str += "y";
                    break;
                case "d͡z":
                    str += "z";
                    break;
            }
        }

        return str.replace(/s$/, `<span class="nonHist">s</span>`);
    }

    function getSpelling_EModSp() {
        let str = "";

        if (wordArg.startsWith("h") && word[0].type == "vowel")
            str += "h";

        for (let i = 0; i < word.length; i++) {
            let segment = word[i];

            if (segment.droppedCons && (segment.type == "vowel" || segment.relIdx(-1).type == "vowel"))
                str += "h";

            switch (segment.value) {
                case "a":
                    if (segment == word.at(-1) && segment.stressed && word.vowels.length > 1)
                        str += "à";
                    else
                        str += "a";
                    break;
                case "e":
                    if (segment == word.at(-1) && segment.stressed && word.vowels.length > 1)
                        str += "è";
                    else
                        str += "e";
                    break;
                case "i":
                    if (str == "")
                        str += "y";
                    else if (segment == word.at(-1) && segment.stressed && word.vowels.length > 1)
                        str += "ì";
                    else
                        str += "i";
                    break;
                case "o":
                    if (segment == word.at(-1) && segment.stressed && word.vowels.length > 1)
                        str += "ò";
                    else
                        str += "o";
                    break;
                case "u":
                    if (segment == word.at(-1) && segment.stressed && word.vowels.length > 1)
                        str += "ù";
                    else if (str == "" && !modernTypography)
                        str += "v";
                    else
                        str += "u";
                    break;
                case "j":
                    if (segment == word.at(-1))
                        str += "y";
                    else
                        str += "i";
                    break;
                case "w":
                    if (segment.relIdx(1).type == "vowel" && segment.relIdx(-1).type != "consonant")
                        str += "h";
                    str += "u";
                    break;
                case "b":
                case "β":
                    if (segment.OSpValue == "b")
                        str += "b";
                    else if (str == "" || modernTypography)
                        str += "v";
                    else
                        str += "u";
                    break;
                case "t͡ʃ":
                    str += "ch";
                    break;
                case "d":
                case "ð":
                    str += "d";
                    break;
                case "f":
                    str += "f";
                    break;
                case "g":
                case "ɣ":
                    if (segment.relIdx(1).match("e", "i", "j"))
                        str += "gu";
                    else
                        str += "g";
                    break;
                case "ʃ":
                    if (segment.OSpValue == "ʃ")
                        str += "x";
                    else if (segment.relIdx(1).match("e", "i", "j"))
                        str += "g";
                    else if (modernTypography)
                        str += "j";
                    else
                        str += "i";
                    break;
                case "k":
                    if (segment.relIdx(1).match("e", "i", "j"))
                        str += "qu";
                    else if (segment.relIdx(1).value == "w" && !segment.relIdx(2).match("e", "i", "j"))
                        str += "q";
                    else
                        str += "c";
                    break;
                case "l":
                    str += "l";
                    break;
                case "ʎ":
                    str += "ll";
                    break;
                case "m":
                case "ɱ":
                    if (segment.relIdx(1).value == "b" && !(segment.relIdx(1).OSpValue == "b" || segment.relIdx(2).value == "w"))
                        str += "n";
                    else
                        str += "m";
                    break;
                case "n":
                case "ŋ":
                    str += "n";
                    break;
                case "ɲ":
                    str += "ñ";
                    break;
                case "p":
                    str += "p";
                    break;
                case "ɾ":
                    str += "r";
                    break;
                case "r":
                    if (segment.relIdx(-1).type == "vowel" || segment.relIdx(-1).match("j", "w"))
                        str += "rr";
                    else
                        str += "r";
                    break;
                case "s̺":
                case "z̺":
                    if (
                        segment.OSpValue == "s̺"
                        && (segment.relIdx(-1).type == "vowel" || segment.relIdx(-1).match("j", "w"))
                        && (segment.relIdx(1).type == "vowel" || segment.relIdx(1).match("j", "w"))
                    ) {
                        if (modernTypography)
                            str += "ss";
                        else
                            str += "ſſ";
                    } else if (segment == word.at(-1) || modernTypography) {
                        str += "s";
                    } else {
                        str += "ſ";
                    }
                    break;
                case "t":
                    str += "t";
                    break;
                case "ʝ":
                    str += "y";
                    break;
                case "s":
                case "z":
                    if (segment.OSpValue == "d͡z" || (segment.relIdx(1).type != "vowel" && !segment.relIdx(1).match("j", "w")))
                        str += "z";
                    else if (segment.relIdx(1).match("e", "i", "j"))
                        str += "c";
                    else
                        str += "ç";
                    break;
            }
        }

        return str;
    }

    function getSpelling_ModSp(EModSpWord) {
        let word = EModSpWord;
        let str = "";

        if (wordArg.startsWith("h") && word[0].type == "vowel")
            str += "h";

        for (let i = 0; i < word.length; i++) {
            let segment = word[i];

            if (segment.droppedCons && (segment.type == "vowel" || segment.relIdx(-1).type == "vowel"))
                str += "h";

            let defaultStress = false;
            if (segment == word.vowels.at(-2) && (word.at(-1).type == "vowel" || word.at(-1).match("s̺", "n")))
                defaultStress = true;
            if (segment == word.vowels.at(-1) && word.at(-1).type == "consonant" && !word.at(-1).match("s̺", "n"))
                defaultStress = true;
            if (word.vowels.length == 1 && segment.type == "vowel")
                defaultStress = true;
            if (segment.match("i", "u") && (segment.relIdx(1).type == "vowel" || segment.relIdx(-1).type == "vowel"))
                defaultStress = false;
            if (segment.match("i", "u") && segment.relIdx(1).match("j", "w") && segment.relIdx(2).type == "consonant")
                defaultStress = false;

            switch (segment.value) {
                case "a":
                    if (segment.stressed && !defaultStress)
                        str += "á";
                    else
                        str += "a";
                    break;
                case "e":
                    if (segment.stressed && !defaultStress)
                        str += "é";
                    else
                        str += "e";
                    break;
                case "i":
                    if (segment.stressed && !defaultStress)
                        str += "í";
                    else
                        str += "i";
                    break;
                case "o":
                    if (segment.stressed && !defaultStress)
                        str += "ó";
                    else
                        str += "o";
                    break;
                case "u":
                    if (segment.stressed && !defaultStress)
                        str += "ú";
                    else
                        str += "u";
                    break;
                case "j":
                    if (segment == word.at(-1))
                        str += "y";
                    else
                        str += "i";
                    break;
                case "w":
                case "w̝":
                    if (segment.relIdx(1).type == "vowel" && segment.relIdx(-1).type != "consonant")
                        str += "h";
                    if (segment.relIdx(-1).match("g", "ɣ") && segment.relIdx(1).match("e", "i", "j"))
                        str += "ü";
                    else
                        str += "u";
                    break;
                case "b":
                case "β":
                    if (segment.latValue == "b" || segment.latValue == "p" || segment.latValue == "pʰ" || !segment.latValue)
                        str += "b";
                    else
                        str += "v";
                    break;
                case "t͡ʃ":
                    str += "ch";
                    break;
                case "d":
                case "ð":
                    str += "d";
                    break;
                case "f":
                    str += "f";
                    break;
                case "g":
                case "ɣ":
                    if (segment.relIdx(1).match("e", "i", "j"))
                        str += "gu";
                    else
                        str += "g";
                    break;
                case "ʃ":
                    if (segment.latValue == "g" && segment.relIdx(1).match("e", "i", "j"))
                        str += "g";
                    else
                        str += "j";
                    break;
                case "k":
                    if (segment.relIdx(1).match("e", "i", "j"))
                        str += "qu";
                    else
                        str += "c";
                    break;
                case "l":
                    str += "l";
                    break;
                case "ʎ":
                    str += "ll";
                    break;
                case "m":
                case "ɱ":
                    if (segment.relIdx(1).value == "b" && !(segment.relIdx(1).latValue == "b" || segment.relIdx(1).latValue == "p" || !segment.relIdx(1).latValue || segment.relIdx(2).value == "w"))
                        str += "n";
                    else
                        str += "m";
                    break;
                case "n":
                case "ŋ":
                    str += "n";
                    break;
                case "ɲ":
                    str += "ñ";
                    break;
                case "p":
                    str += "p";
                    break;
                case "ɾ":
                    str += "r";
                    break;
                case "r":
                    if (segment.relIdx(-1).type == "vowel" || segment.relIdx(-1).match("j", "w"))
                        str += "rr";
                    else
                        str += "r";
                    break;
                case "s̺":
                case "z̺":
                    str += "s";
                    break;
                case "t":
                    str += "t";
                    break;
                case "ɟ͡ʝ":
                case "ʝ":
                    str += "y";
                    break;
                case "s":
                case "z":
                    if (segment.relIdx(1).match("e", "i", "j"))
                        str += "c";
                    else
                        str += "z";
                    break;
            }
        }

        return str;
    }

    function getSpelling_OGP() {
        let str = "";

        for (let i = 0; i < word.length; i++) {
            let segment = word[i];

            switch (segment.value) {
                case "a":
                    str += "a";
                    break;
                case "ɐ":
                    str += "a";
                    break;
                case "ɛ":
                    str += "e";
                    break;
                case "e":
                    str += "e";
                    break;
                case "i":
                    if ((segment.relIdx(-1).type != "consonant" && !segment.relIdx(-1).match("i", "ĩ") && !segment.relIdx(1).match("i", "ĩ")) || segment == word.at(-1))
                        str += "y";
                    else
                        str += "i";
                    break;
                case "ɔ":
                    str += "o";
                    break;
                case "o":
                    str += "o";
                    break;
                case "u":
                    if (segment == word.vowels.at(-1) && !segment.stressed && !segment.relIdx(-1).match("u", "ũ"))
                        str += "o";
                    else
                        str += "u";
                    break;
                case "ã":
                    if (segment.relIdx(1).type == "vowel")
                        str += "ã";
                    else if (segment.relIdx(1).match("p", "b"))
                        str += "am";
                    else
                        str += "an";
                    break;
                case "ẽ":
                    if (segment.relIdx(1).type == "vowel")
                        str += "ẽ";
                    else if (segment.relIdx(1).match("p", "b"))
                        str += "em";
                    else
                        str += "en";
                    break;
                case "ĩ":
                    if (segment.relIdx(1).type == "vowel")
                        str += "ĩ";
                    else if (segment.relIdx(1).match("p", "b"))
                        str += "im";
                    else
                        str += "in";
                    break;
                case "õ":
                    if (segment.relIdx(1).type == "vowel")
                        str += "õ";
                    else if (segment.relIdx(1).match("p", "b"))
                        str += "om";
                    else
                        str += "on";
                    break;
                case "ũ":
                    if (segment.relIdx(1).type == "vowel")
                        str += "ũ";
                    else if (segment.relIdx(1).match("p", "b"))
                        str += "um";
                    else
                        str += "un";
                    break;
                case "j":
                    if (segment.relIdx(1).type != "consonant")
                        str += "y";
                    else
                        str += "i";
                    break;
                case "w":
                    str += "u";
                    break;
                case "b":
                    str += "b";
                    break;
                case "k":
                    if (segment.relIdx(1).match("ɛ", "e", "i", "ẽ", "ĩ", "j"))
                        str += "qu";
                    else if (segment.relIdx(1).value == "w")
                        str += "q";
                    else
                        str += "c";
                    break;
                case "t͡s":
                    if (segment == word.at(-1))
                        str += "z";
                    else if (segment.relIdx(1).match("ɛ", "e", "i", "ẽ", "ĩ", "j"))
                        str += "c";
                    else
                        str += "ç";
                    break;
                case "t͡ʃ":
                    str += "ch";
                    break;
                case "d":
                    str += "d";
                    break;
                case "f":
                    str += "f";
                    break;
                case "g":
                    if (segment.relIdx(1).match("ɛ", "e", "i", "ẽ", "ĩ", "j"))
                        str += "gu";
                    else
                        str += "g";
                    break;
                case "ʒ":
                    if (segment.relIdx(1).match("ɛ", "e", "i", "ẽ", "ĩ", "j") && segment.latValue == "g")
                        str += "g";
                    else
                        str += "j";
                    break;
                case "l":
                case "ɫ":
                    str += "l";
                    break;
                case "ʎ":
                    str += "lh";
                    break;
                case "m":
                    str += "m";
                    break;
                case "n":
                    str += "n";
                    break;
                case "ɲ":
                    str += "nh";
                    break;
                case "p":
                    str += "p";
                    break;
                case "ɾ":
                    str += "r";
                    break;
                case "r":
                    if (segment.relIdx(-1).type == "vowel" || segment.relIdx(-1).match("j", "w"))
                        str += "rr";
                    else
                        str += "r";
                    break;
                case "s̺":
                    if ((segment.relIdx(-1).type == "vowel" || segment.relIdx(-1).match("j", "w")) && (segment.relIdx(1).type == "vowel" || segment.relIdx(1).match("j", "w")) && !str.endsWith("n"))
                        str += "ss";
                    else
                        str += "s";
                    break;
                case "z̺":
                    str += "s";
                    break;
                case "t":
                    str += "t";
                    break;
                case "β":
                    str += "v";
                    break;
                case "ʃ":
                    str += "x";
                    break;
                case "d͡z":
                    str += "z";
                    break;
            }
        }

        if (!modernTypography) {
            str = str.replaceAll("j", "i")
                .replaceAll("v", "u");
        }

        return str;
    }

    function getSpelling_ModPort(EModPortWord, variety) {
        let word = EModPortWord;
        let str = "";

        if (wordArg.startsWith("h") && word[0].type == "vowel")
            str += "h";

        for (let i = 0; i < word.length; i++) {
            let segment = word[i];

            let defaultStress = false;
            if (segment == word.vowels.at(-2) && (word.at(-1).type == "vowel" || word.at(-1).match("s", "t͡s")))
                defaultStress = true;
            if (segment == word.vowels.at(-2) && word.partOfSpeech == "conjVerb" && word.at(-2).value == "ɐ̃" && word.at(-1).value == "w" && !word.at(-2).stressed)
                defaultStress = true;
            if (segment == word.vowels.at(-2) && word.at(-2).value == "ẽ" && word.at(-1).value == "j")
                defaultStress = true;
            if (segment == word.vowels.at(-1) && segment.match("i", "u", "ɐ̃", "ĩ", "õ", "ũ"))
                defaultStress = true;
            if (segment == word.vowels.at(-1) && segment.relIdx(1).type == "consonant" && segment.relIdx(1).value != "s")
                defaultStress = true;
            if (segment.match("i", "ĩ", "u", "ũ") && segment.relIdx(-1).type == "vowel" && segment.relIdx(1).value != "ɲ" && !(segment.value == "i" && segment.relIdx(1).value == "ɾ" && segment == word.at(-2)))
                defaultStress = false;
            if (segment == word.vowels.at(-2) && word.at(-1).value == "ɐ̃")
                defaultStress = false;
            if (segment == word.vowels.at(-2) && word.vowels.at(-1).relIdx(-1).value == "w")
                defaultStress = false;
            if (segment.match("ɛ", "ɔ") && segment.relIdx(1).match("j", "w"))
                defaultStress = false;
            if (segment.value == "ẽ" && segment.relIdx(1).value == "j" && segment == word.at(-2) && word.vowels.length > 1)
                defaultStress = false;

            switch (segment.value) {
                case "a":
                    if (segment.stressed && !defaultStress)
                        str += "á";
                    else
                        str += "a";
                    break;
                case "ɐ":
                    if (segment.stressed && !defaultStress)
                        str += "â";
                    else
                        str += "a";
                    break;
                case "ɛ":
                    if (segment.stressed && !defaultStress && variety == "br" && segment.relIdx(1).match("m", "n", "ɲ"))
                        str += "ê";
                    else if (segment.stressed && !defaultStress)
                        str += "é";
                    else
                        str += "e";
                    break;
                case "e":
                    if (segment.stressed && !defaultStress)
                        str += "ê";
                    else
                        str += "e";
                    break;
                case "i":
                    if (
                        (segment.OGPValue == "e" || segment.OGPValue == "ẽ") && !segment.relIdx(1).match("ɛ", "e", "ẽ", "i", "ĩ")
                        && !(segment.relIdx(1).match("u", "ũ")
                            && ((segment.OGPValue == "o" || segment.OGPValue == "õ" || (segment == word.vowels.at(-1) && !segment.stressed))
                                && !segment.relIdx(1).match("ɔ", "o", "õ")))
                        && !segment.stressed
                    )
                        str += "e";
                    else if (segment.stressed && !defaultStress)
                        str += "í";
                    else
                        str += "i";
                    break;
                case "ɔ":
                    if (segment.stressed && !defaultStress && variety == "br" && segment.relIdx(1).match("m", "n", "ɲ"))
                        str += "ô";
                    else if (segment.stressed && !defaultStress)
                        str += "ó";
                    else
                        str += "o";
                    break;
                case "o":
                    if (segment.stressed && !defaultStress)
                        str += "ô";
                    else
                        str += "o";
                    break;
                case "u":
                    if ((segment.OGPValue == "o" || segment.OGPValue == "õ" || (segment == word.vowels.at(-1) && !segment.stressed)) && !segment.relIdx(1).match("ɔ", "o", "õ") && !segment.stressed)
                        str += "o";
                    else if (segment.stressed && !defaultStress)
                        str += "ú";
                    else
                        str += "u";
                    break;
                case "ɐ̃":
                    if (segment.relIdx(1).match("p", "b") || (word.partOfSpeech == "conjVerb" && segment == word.at(-2) && segment.relIdx(1).value == "w" && !segment.stressed)) {
                        if (segment.stressed && !defaultStress)
                            str += "ám";
                        else
                            str += "am";
                    } else if (segment.relIdx(1).type == "consonant" && !segment.relIdx(1).match("j", "w")) {
                        if (segment.stressed && !defaultStress)
                            str += "án";
                        else
                            str += "an";
                    } else {
                        str += "ã";
                    }
                    break;
                case "ẽ":
                    if (segment.relIdx(1).match("p", "b") || (segment.relIdx(1).value == "j" && (segment == word.at(-2) || segment.relIdx(2).match("p", "b")))) {
                        if (segment.stressed && !defaultStress && segment == word.vowels.at(-1) && segment.relIdx(1).value == "j")
                            str += "ém";
                        else if (segment.stressed && !defaultStress)
                            str += "êm";
                        else
                            str += "em";
                    } else {
                        if (segment.stressed && !defaultStress && segment == word.vowels.at(-1) && segment.relIdx(1).value == "j")
                            str += "én";
                        else if (segment.stressed && !defaultStress)
                            str += "ên";
                        else
                            str += "en";
                    }
                    break;
                case "ĩ":
                    if (segment == word.at(-1) || segment.relIdx(1).match("p", "b")) {
                        if (segment.stressed && !defaultStress)
                            str += "ím";
                        else
                            str += "im";
                    } else {
                        if (segment.stressed && !defaultStress)
                            str += "ín";
                        else
                            str += "in";
                    }
                    break;
                case "õ":
                    if (segment == word.at(-1) || segment.relIdx(1).match("p", "b")) {
                        if (segment.stressed && !defaultStress)
                            str += "ôm";
                        else
                            str += "om";
                    } else if (segment.relIdx(1).type == "consonant" && !segment.relIdx(1).match("j", "w")) {
                        if (segment.stressed && !defaultStress)
                            str += "ôn";
                        else
                            str += "on";
                    } else {
                        str += "õ";
                    }
                    break;
                case "ũ":
                    if (segment == word.at(-1) || segment.relIdx(1).match("p", "b")) {
                        if (segment.stressed && !defaultStress)
                            str += "úm";
                        else
                            str += "um";
                    } else {
                        if (segment.stressed && !defaultStress)
                            str += "ún";
                        else
                            str += "un";
                    }
                    break;
                case "j":
                    if (segment.relIdx(-1).value == "ẽ")
                        break;
                    else if (segment.relIdx(-1).match("ɐ̃", "õ") && segment.relIdx(-1) == word.vowels.at(-1))
                        str += "e";
                    else
                        str += "i";
                    break;
                case "w":
                    if (word.partOfSpeech == "conjVerb" && segment == word.at(-1) && segment.relIdx(-1).value == "ɐ̃" && !segment.relIdx(-1).stressed)
                        break;
                    else if (segment.relIdx(-1).value == "ɐ̃" && segment.relIdx(-1) == word.vowels.at(-1))
                        str += "o";
                    else
                        str += "u";
                    break;
                case "b":
                    str += "b";
                    break;
                case "k":
                    if (segment.relIdx(1).match("ɛ", "e", "i", "ẽ", "ĩ", "j"))
                        str += "qu";
                    else if (segment.relIdx(1).value == "w")
                        str += "q";
                    else
                        str += "c";
                    break;
                case "t͡s":
                    if (segment == word.at(-1) && segment.relIdx(-1).stressed)
                        str += "z";
                    else if (segment.relIdx(1).match("ɛ", "e", "i", "ẽ", "ĩ", "j"))
                        str += "c";
                    else if (segment == word.at(-1) || segment.i == 0)
                        str += "s";
                    else
                        str += "ç";
                    break;
                case "t͡ʃ":
                    str += "ch";
                    break;
                case "d":
                    str += "d";
                    break;
                case "f":
                    str += "f";
                    break;
                case "g":
                    if (segment.relIdx(1).match("ɛ", "e", "i", "ẽ", "ĩ", "j"))
                        str += "gu";
                    else
                        str += "g";
                    break;
                case "ʒ":
                    if (segment.relIdx(1).match("ɛ", "e", "i", "ẽ", "ĩ", "j") && segment.latValue != "j")
                        str += "g";
                    else
                        str += "j";
                    break;
                case "l":
                case "ɫ":
                    str += "l";
                    break;
                case "ʎ":
                    str += "lh";
                    break;
                case "m":
                    str += "m";
                    break;
                case "n":
                    str += "n";
                    break;
                case "ɲ":
                    str += "nh";
                    break;
                case "p":
                    str += "p";
                    break;
                case "ɾ":
                    str += "r";
                    break;
                case "r":
                    if (segment.relIdx(-1).type == "vowel" || segment.relIdx(-1).match("j", "w"))
                        str += "rr";
                    else
                        str += "r";
                    break;
                case "s":
                    if ((segment.relIdx(-1).type == "vowel" || segment.relIdx(-1).match("j", "w")) && (segment.relIdx(1).type == "vowel" || segment.relIdx(1).match("j", "w")) && !str.endsWith("n"))
                        str += "ss";
                    else
                        str += "s";
                    break;
                case "z":
                    if (str.endsWith("n"))
                        str += "z";
                    else
                        str += "s";
                    break;
                case "t":
                    str += "t";
                    break;
                case "v":
                    str += "v";
                    break;
                case "ʃ":
                    str += "x";
                    break;
                case "d͡z":
                    str += "z";
                    break;
            }
        }

        return str;
    }

    function getSpelling_EOF() {
        let str = "";
        for (let i = 0; i < word.length; i++) {
            let segment = word[i];
            switch (segment.value) {
                case "a":
                    str += "a";
                    break;
                case "ɛ":
                case "e":
                case "æ":
                case "ə":
                    str += "e";
                    break;
                case "i":
                case "j":
                    str += "i";
                    break;
                case "ɔ":
                case "o":
                    str += "o";
                    break;
                case "u":
                case "w":
                    str += "u";
                    break;
                case "ie̯":
                    str += "ie";
                    break;
                case "uo̯":
                    str += "uo";
                    break;
                case "ai̯":
                    str += "ai";
                    break;
                case "ei̯":
                    str += "ei";
                    break;
                case "ɔi̯":
                case "oi̯":
                    str += "oi";
                    break;
                case "ui̯":
                    str += "ui";
                    break;
                case "au̯":
                    str += "au";
                    break;
                case "ɛu̯":
                case "eu̯":
                    str += "eu";
                    break;
                case "iu̯":
                    str += "iu";
                    break;
                case "ɔu̯":
                case "ou̯":
                    str += "ou";
                    break;
                case "ie̯u̯":
                    str += "ieu";
                    break;
                case "uo̯u̯":
                    str += "uou";
                    break;
                case "b":
                    str += "b";
                    break;
                case "t͡ʃ":
                    str += "ch";
                    break;
                case "d":
                case "ð":
                    str += "d";
                    break;
                case "f":
                    str += "f";
                    break;
                case "g":
                    str += "g";
                    break;
                case "d͡ʒ":
                    if (["ɛ", "e", "æ", "ə", "i"].includes(segment.relIdx(1).value[0]))
                        str += "g";
                    else
                        str += "j";
                    break;
                case "k":
                    if (segment.relIdx(1).value == "w")
                        str += "q";
                    else if (["ɛ", "e", "æ", "ə", "i"].includes(segment.relIdx(1).value[0]))
                        str += "qu";
                    else
                        str += "c";
                    break;
                case "l":
                case "ɫ":
                    str += "l";
                    break;
                case "ʎ":
                    if (!str.endsWith("i"))
                        str += "i";
                    str += "l";
                    if (segment.relIdx(1).type == "vowel")
                        str += "l";
                    break;
                case "m":
                    str += "m";
                    break;
                case "n":
                case "ŋ":
                    str += "n";
                    break;
                case "ɲ":
                    if (segment == word.at(-1))
                        str += "ng";
                    else
                        str += "gn";
                    break;
                case "p":
                    str += "p";
                    break;
                case "ɾ":
                    str += "r";
                    break;
                case "r":
                    if (segment.i == 0)
                        str += "r";
                    else
                        str += "rr";
                    break;
                case "s̺":
                    if (segment.relIdx(-1).type == "vowel" && segment.relIdx(1).type == "vowel")
                        str += "ss";
                    else
                        str += "s";
                    break;
                case "z̺":
                    str += "s";
                    break;
                case "t":
                case "θ":
                    str += "t";
                    break;
                case "β":
                    str += "v";
                    break;
                case "t͡s":
                    if (segment == word.at(-1))
                        str += "z";
                    else if (modernTypography && !["ɛ", "e", "æ", "ə", "i"].includes(segment.relIdx(1).value[0]))
                        str += "ç";
                    else
                        str += "c";
                    break;
                case "d͡z":
                    str += "z";
                    break;
            }
        }

        return str;
    }

    function getSpelling_LOF() {
        let str = "";

        let frontVowels = ["ɛ", "e", "æ", "ə", "i", "ei̯", "e̯au̯", "øu̯", "ɛː", "eː", "iː", "j"];

        for (let i = 0; i < word.length; i++) {
            let segment = word[i];
            switch (segment.value) {
                case "a":
                case "ɑ":
                    if (segment.relIdx(1).value == "ɲ")
                        str += "ai";
                    else
                        str += "a";
                    break;
                case "ɛ":
                case "e":
                case "œ":
                case "ø":
                case "æ":
                case "ə":
                    str += "e";
                    break;
                case "i":
                    str += "i";
                    if (segment.droppedL)
                        str += "l";
                    break;
                case "ɔ":
                    str += "o";
                    break;
                case "u":
                    str += "o";
                    break;
                case "y":
                    str += "u";
                    if (segment.droppedL)
                        str += "l";
                    break;
                case "ai̯":
                    str += "ai";
                    if (segment.droppedS)
                        str += "s";
                    break;
                case "ei̯":
                    str += "ei";
                    break;
                case "oi̯":
                    str += "oi";
                    if (segment.droppedL)
                        str += "l";
                    else if (segment.droppedS)
                        str += "s";
                    break;
                case "au̯":
                    str += "au";
                    break;
                case "e̯au̯":
                    str += "eau";
                    break;
                case "øu̯":
                    str += "eu";
                    break;
                case "ɔu̯":
                    str += "ou";
                    break;
                case "ɑː":
                    str += "as";
                    break;
                case "ɛː":
                case "eː":
                case "øː":
                    if (segment.LOFValue == "ai̯")
                        str += "ais";
                    else
                        str += "es";
                    break;
                case "iː":
                    str += "is";
                    break;
                case "ɔː":
                case "uː":
                    if (segment.relIdx(1).value == "z")
                        str += "o";
                    else
                        str += "os";
                    break;
                case "yː":
                    str += "us";
                    break;
                case "j":
                    str += "i";
                    break;
                case "w":
                case "ɥ":
                    str += "u";
                    break;
                case "b":
                    str += "b";
                    break;
                case "t͡ʃ":
                    str += "ch";
                    break;
                case "d":
                    str += "d";
                    break;
                case "f":
                    str += "f";
                    break;
                case "g":
                    if (segment.relIdx(1).match(...frontVowels))
                        str += "gu";
                    else
                        str += "g";
                    break;
                case "d͡ʒ":
                    if (segment.relIdx(1).match(...frontVowels))
                        str += "g";
                    else
                        str += "j";
                    break;
                case "k":
                    if (segment.relIdx(1).match(...frontVowels) || (segment.latValue == "kʷ" && (segment.relIdx(1).type == "vowel" || segment.relIdx(1).match("j", "w", "ɥ"))))
                        str += "qu";
                    else
                        str += "c";
                    break;
                case "l":
                case "ɫ":
                    str += "l";
                    break;
                case "ʎ":
                    if (!str.endsWith("i"))
                        str += "i";
                    str += "l";
                    if (segment.relIdx(1).type == "vowel" || segment.relIdx(1).match("j", "w", "ɥ"))
                        str += "l";
                    break;
                case "m":
                    str += "m";
                    break;
                case "n":
                case "ŋ":
                    str += "n";
                    break;
                case "ɲ":
                    str += "gn";
                    break;
                case "p":
                    str += "p";
                    break;
                case "ɾ":
                    str += "r";
                    break;
                case "r":
                    if (segment.i == 0)
                        str += "r";
                    else
                        str += "rr";
                    break;
                case "s̺":
                    if (segment.relIdx(-1).type == "vowel" && (segment.relIdx(1).type == "vowel" || segment.relIdx(1).value == "j"))
                        str += "ss";
                    else
                        str += "s";
                    break;
                case "z̺":
                    str += "s";
                    break;
                case "t":
                    str += "t";
                    break;
                case "v":
                    str += "v";
                    break;
                case "t͡s":
                    if (segment == word.at(-1))
                        str += "z";
                    else if (modernTypography && !segment.relIdx(1).match(...frontVowels))
                        str += "ç";
                    else
                        str += "c";
                    break;
                case "d͡z":
                    str += "z";
                    break;
            }
        }

        return str.replace(/s$/, `<span class="nonHist">s</span>`);
    }

    function getSpelling_MF(lateOFWord) {
        let word = lateOFWord;
        let str = "";

        for (let i = 0; i < word.length; i++) {
            let segment = word[i];

            let frontVowels = ["ɛ", "e", "ə", "æ", "œ", "i", "ei̯", "e̯au̯", "ɛː", "iː", "øː", "j"];

            let doubleCons = segment.relIdx(-1).match("a", "ɛ", "æ", "ɔ", "o") && segment.relIdx(-1).stressed && segment.relIdx(-1).LOFValue != "ai̯"
                && segment.relIdx(1).value == "ə";

            switch (segment.value) {
                case "a":
                case "ɑ":
                    if (segment.LOFValue == "u")
                        str += "ao";
                    else if (segment.relIdx(1).value == "ɲ")
                        str += "ai";
                    else
                        str += "a";
                    break;
                case "ɛ":
                case "æ":
                    if ((segment.LOFValue == "ai̯" || segment.droppedA) && (segment == word.at(-1) || segment.relIdx(1).type == "vowel" || segment.relIdx(1).value == "j"))
                        str += "ay";
                    else if (segment.LOFValue == "ai̯" || segment.droppedA)
                        str += "ai";
                    else
                        str += "e";
                    break;
                case "e":
                    if (segment.droppedS && modernTypography)
                        str += "es";
                    else if (segment.droppedS)
                        str += "eſ";
                    else if (segment == word.at(-1) && word.vowels.length > 1)
                        str += "é";
                    else
                        str += "e";
                    break;
                case "ə":
                    str += "e";
                    break;
                case "i":
                    if (str.endsWith("y"))
                        break;
                    else if (segment.relIdx(-1).type == "vowel" || (segment.relIdx(1).value == "v" && (segment.i == 0 || segment.relIdx(-1).value == "w")))
                        str += "y";
                    else
                        str += "i";
                    if (segment.droppedL)
                        str += "l";
                    break;
                case "ɔ":
                case "o":
                    str += "o";
                    break;
                case "u":
                    str += "ou";
                    break;
                case "y":
                    if (segment.i == 0 && !modernTypography)
                        str += "v";
                    else
                        str += "u";
                    if (segment.droppedL)
                        str += "l";
                    break;
                case "œ":
                    if (segment.relIdx(-1).match("k", "g") && segment.relIdx(1).value == "ʎ")
                        str += "e";
                    else
                        str += "eu";
                    break;
                case "ei̯":
                    str += "ei";
                    break;
                case "oi̯":
                    if (segment.droppedS && modernTypography)
                        str += "ois";
                    else if (segment.droppedS)
                        str += "oiſ";
                    else if (segment.droppedL)
                        str += "oil";
                    else if (segment == word.at(-1) || segment.relIdx(1).type == "vowel" || segment.relIdx(1).value == "j")
                        str += "oy";
                    else
                        str += "oi";
                    break;
                case "au̯":
                    str += "au";
                    break;
                case "e̯au̯":
                    str += "eau";
                    break;
                case "ɑː":
                    if (segment.LOFValue == "u")
                        str += "ao";
                    else if (!segment.droppedS)
                        str += "a";
                    else if (modernTypography)
                        str += "as";
                    else
                        str += "aſ";
                    break;
                case "ɛː":
                    if (segment.LOFValue == "ai̯" || segment.droppedA)
                        str += "ai";
                    else
                        str += "e";
                    if (segment.droppedS && modernTypography)
                        str += "s";
                    else if (segment.droppedS)
                        str += "ſ";
                    break;
                case "iː":
                    if (!str.endsWith("y")) {
                        if (segment.relIdx(-1).type == "vowel")
                            str += "y";
                        else
                            str += "i";
                    }
                    if (segment.droppedS && modernTypography)
                        str += "s";
                    else if (segment.droppedS)
                        str += "ſ";
                    break;
                case "oː":
                    if (segment.relIdx(1).value == "z̺" || !segment.droppedS)
                        str += "o";
                    else if (modernTypography)
                        str += "os";
                    else
                        str += "oſ";
                    break;
                case "uː":
                    if (!segment.droppedS)
                        str += "ou";
                    else if (modernTypography)
                        str += "ous";
                    else
                        str += "ouſ";
                    break;
                case "yː":
                    if (segment.i == 0 && !modernTypography)
                        str += "v";
                    else
                        str += "u";
                    if (segment.droppedS && modernTypography)
                        str += "s";
                    else if (segment.droppedS)
                        str += "ſ";
                    break;
                case "œː":
                    if (!segment.droppedS)
                        str += "eu";
                    else if (modernTypography)
                        str += "eus";
                    else
                        str += "euſ";
                    break;
                case "j":
                    if (str.endsWith("y"))
                        break;
                    else if (segment.i == 0 || segment.relIdx(-1).type == "vowel")
                        str += "y";
                    else
                        str += "i";
                    break;
                case "w":
                    if (segment.i == 0)
                        str += "h";
                    str += "ou";
                    break;
                case "ɥ":
                    if (segment.i == 0)
                        str += "h";
                    str += "u";
                    break;
                case "b":
                    if (doubleCons)
                        str += "bb";
                    else
                        str += "b";
                    break;
                case "t͡ʃ":
                    str += "ch";
                    break;
                case "d":
                    str += "d";
                    break;
                case "f":
                    if (doubleCons)
                        str += "ff";
                    else
                        str += "f";
                    break;
                case "g":
                    if (segment.relIdx(1).match(...frontVowels) && segment.relIdx(1).LOFValue != "ai̯")
                        str += "gu";
                    else
                        str += "g";
                    break;
                case "d͡ʒ":
                    if (segment.relIdx(1).match(...frontVowels))
                        str += "g";
                    else if (modernTypography)
                        str += "j";
                    else
                        str += "i";
                    break;
                case "k":
                    if (segment.relIdx(1).match("œ", "øː") && segment.relIdx(2).value == "ʎ")
                        str += "cu";
                    else if (
                        (segment.relIdx(1).match(...frontVowels) && segment.relIdx(1).LOFValue != "ai̯")
                        || (segment.latValue == "kʷ" && (segment.relIdx(1).type == "vowel" || segment.relIdx(1).match("j", "w", "ɥ")))
                    )
                        str += "qu";
                    else
                        str += "c";
                    break;
                case "l":
                case "ɫ":
                    if (doubleCons)
                        str += "ll";
                    else
                        str += "l";
                    break;
                case "ʎ":
                    if (!str.endsWith("i"))
                        str += "i";
                    str += "l";
                    if (segment.relIdx(1).type == "vowel" || segment.relIdx(1).match("j", "w", "ɥ"))
                        str += "l";
                    break;
                case "m":
                    if (doubleCons)
                        str += "mm";
                    else
                        str += "m";
                    break;
                case "n":
                case "ŋ":
                    if (doubleCons)
                        str += "nn";
                    else
                        str += "n";
                    break;
                case "ɲ":
                    str += "gn";
                    break;
                case "p":
                    if (doubleCons)
                        str += "pp";
                    else
                        str += "p";
                    break;
                case "r":
                    if (doubleCons || (segment.LOFValue == "r" && segment.i != 0))
                        str += "rr";
                    else
                        str += "r";
                    break;
                case "s̺":
                    if (segment == word.at(-1) && segment.relIdx(-1).match("au̯", "e̯au̯", "œ"))
                        str += "x";
                    else if (segment.relIdx(-1).type == "vowel" && segment.relIdx(1).type == "vowel" && modernTypography)
                        str += "ss";
                    else if (segment.relIdx(-1).type == "vowel" && (segment.relIdx(1).type == "vowel" || segment.relIdx(1).value == "j"))
                        str += "ſſ";
                    else if (segment == word.at(-1) || modernTypography)
                        str += "s";
                    else
                        str += "ſ";
                    break;
                case "z̺":
                    if (segment == word.at(-1) || modernTypography)
                        str += "s";
                    else
                        str += "ſ";
                    break;
                case "t":
                    if (doubleCons)
                        str += "tt";
                    else
                        str += "t";
                    break;
                case "v":
                    if (segment.i == 0 || modernTypography)
                        str += "v";
                    else
                        str += "u";
                    break;
                case "t͡s":
                    if (segment == word.at(-1) && word.at(-2).type == "vowel" && word.at(-2).stressed && word.vowels.length > 1)
                        str += "z";
                    else if (segment == word.at(-1) && segment.relIdx(-1).match("au̯", "e̯au̯", "œ"))
                        str += "x";
                    else if (segment == word.at(-1))
                        str += "s";
                    else if (!segment.relIdx(1).match(...frontVowels))
                        str += "ç";
                    else
                        str += "c";
                    break;
                case "d͡z":
                    str += "z";
                    break;
            }
        }

        return str;
    }

    function getSpelling_ModF(lateOFWord) {
        let word = lateOFWord;
        let str = "";

        for (let i = 0; i < word.length; i++) {
            let segment = word[i];

            let frontVowels = ["ɛ", "e", "ə", "æ", "œ", "i", "ei̯", "e̯au̯", "ɛː", "iː", "øː", "j"];

            let doubleCons = segment.relIdx(-1).match("a", "ɛ", "æ", "ɔ", "o") && segment.relIdx(-1).stressed && segment.relIdx(-1).LOFValue != "ai̯"
                && segment.relIdx(1).value == "ə";

            switch (segment.value) {
                case "a":
                case "ɑ":
                    if (segment.LOFValue == "u")
                        str += "ao";
                    else
                        str += "a";
                    break;
                case "ɛ":
                    if ((segment.LOFValue == "ai̯" || segment.droppedA) && segment.relIdx(1).match("j", "i", "iː"))
                        str += "ay";
                    else if (segment.LOFValue == "ai̯" || segment.droppedA)
                        str += "ai";
                    else if (segment == word.at(-1) || segment.relIdx(1).value == "ə" || (word.vowels.length > 1 && segment == word.at(-2) && segment.relIdx(1).value == "s̺"))
                        str += "é";
                    else if ((segment.relIdx(1).match("d", "t͡ʃ", "t͡s", " d͡z", "v", "z̺") && segment != word.at(-2)) || (segment.relIdx(2).match("l", "r") && !segment.relIdx(1).match("l", "r")))
                        str += "è";
                    else
                        str += "e";
                    break;
                case "e":
                    if (segment.relIdx(1).value == "r")
                        str += "è";
                    else if (
                        segment.stressed && segment.relIdx(1).value != "ʎ"
                        || (segment.i < word.stressedVowel.i && segment.relIdx(1).value != "ʎ"
                            && !(segment.relIdx(1).type == "consonant" && segment.relIdx(2).type == "consonant"
                                && !(segment.relIdx(2).match("l", "r") && !segment.relIdx(1).match("l", "r"))))
                    )
                        str += "é";
                    else
                        str += "e";
                    break;
                case "ə":
                case "æ":
                    str += "e";
                    break;
                case "i":
                case "iː":
                    if (str.endsWith("y"))
                        break;
                    else if (segment.relIdx(-1).type == "vowel" && segment.relIdx(-1).value != "y")
                        str += "ï";
                    else
                        str += "i";
                    if (segment.droppedL)
                        str += "l";
                    break;
                case "ɔ":
                case "o":
                    str += "o";
                    break;
                case "u":
                case "uː":
                    str += "ou";
                    break;
                case "y":
                case "yː":
                    if (segment.droppedL)
                        str += "ul";
                    else if (str.endsWith("g") && segment.relIdx(1).match(...frontVowels) && segment.relIdx(1).LOFValue != "ai̯")
                        str += "ü";
                    else
                        str += "u";
                    break;
                case "œ":
                case "œː":
                    if (segment.relIdx(-1).match("k", "g") && segment.relIdx(1).value == "ʎ")
                        str += "e";
                    else
                        str += "eu";
                    break;
                case "ei̯":
                    str += "ei";
                    break;
                case "oi̯":
                    if (segment.droppedL)
                        str += "oil";
                    else if (segment.relIdx(1).match("j", "i", "iː"))
                        str += "oy";
                    else
                        str += "oi";
                    break;
                case "au̯":
                    str += "au";
                    break;
                case "e̯au̯":
                    str += "eau";
                    break;
                case "ɑː":
                    if (segment.LOFValue == "u")
                        str += "ao";
                    else if (segment == word.at(-1))
                        str += "as";
                    else
                        str += "â";
                    break;
                case "ɛː":
                    if (segment.LOFValue == "ai̯" || segment.droppedA)
                        str += "ai";
                    else if (segment.relIdx(1).LOFValue == "r")
                        str += "e";
                    else
                        str += "ê";
                    break;
                case "oː":
                    if (segment.relIdx(1).value == "z̺")
                        str += "o";
                    else
                        str += "ô";
                    break;
                case "j":
                    if (str.endsWith("y"))
                        break;
                    else if (segment.i == 0 || segment.relIdx(-1).type == "vowel")
                        str += "y";
                    else
                        str += "i";
                    break;
                case "w":
                    if (segment.i == 0)
                        str += "h";
                    str += "ou";
                    break;
                case "ɥ":
                    if (segment.i == 0)
                        str += "h";
                    str += "u";
                    break;
                case "b":
                    if (doubleCons)
                        str += "bb";
                    else
                        str += "b";
                    break;
                case "t͡ʃ":
                    str += "ch";
                    break;
                case "d":
                    str += "d";
                    break;
                case "f":
                    if (doubleCons)
                        str += "ff";
                    else
                        str += "f";
                    break;
                case "g":
                    if (segment.relIdx(1).match(...frontVowels) && segment.relIdx(1).LOFValue != "ai̯")
                        str += "gu";
                    else
                        str += "g";
                    break;
                case "d͡ʒ":
                    if (segment.relIdx(1).match(...frontVowels))
                        str += "g";
                    else
                        str += "j";
                    break;
                case "k":
                    if (segment.relIdx(1).match("œ", "øː") && segment.relIdx(2).value == "ʎ")
                        str += "cu";
                    else if (
                        (segment.relIdx(1).match(...frontVowels) && segment.relIdx(1).LOFValue != "ai̯")
                        || (segment.latValue == "kʷ" && (segment.relIdx(1).type == "vowel" || segment.relIdx(1).match("j", "w", "ɥ")))
                    )
                        str += "qu";
                    else
                        str += "c";
                    break;
                case "l":
                case "ɫ":
                    if (doubleCons)
                        str += "ll";
                    else
                        str += "l";
                    break;
                case "ʎ":
                    if (!str.endsWith("i"))
                        str += "i";
                    str += "l";
                    if (segment.relIdx(1).type == "vowel" || segment.relIdx(1).match("j", "w", "ɥ"))
                        str += "l";
                    break;
                case "m":
                    if (doubleCons)
                        str += "mm";
                    else
                        str += "m";
                    break;
                case "n":
                case "ŋ":
                    if (doubleCons)
                        str += "nn";
                    else
                        str += "n";
                    break;
                case "ɲ":
                    str += "gn";
                    break;
                case "p":
                    if (doubleCons)
                        str += "pp";
                    else
                        str += "p";
                    break;
                case "r":
                    if (doubleCons || (segment.LOFValue == "r" && segment.i != 0))
                        str += "rr";
                    else
                        str += "r";
                    break;
                case "s̺":
                    if (segment == word.at(-1) && segment.relIdx(-1).match("au̯", "e̯au̯", "œ"))
                        str += "x";
                    else if (segment.relIdx(-1).type == "vowel" && (segment.relIdx(1).type == "vowel" || segment.relIdx(1).value == "j"))
                        str += "ss";
                    else
                        str += "s";
                    break;
                case "z̺":
                    str += "s";
                    break;
                case "t":
                    if (doubleCons)
                        str += "tt";
                    else
                        str += "t";
                    break;
                case "v":
                    str += "v";
                    break;
                case "t͡s":
                    if (segment == word.at(-1) && word.at(-2).type == "vowel" && word.at(-2).stressed && word.vowels.length > 1)
                        str += "z";
                    else if (segment == word.at(-1) && segment.relIdx(-1).match("au̯", "e̯au̯", "œ"))
                        str += "x";
                    else if (segment == word.at(-1))
                        str += "s";
                    else if (segment.relIdx(1).match(...frontVowels))
                        str += "c";
                    else
                        str += "ç";
                    break;
                case "d͡z":
                    str += "z";
                    break;
            }
        }

        return str;
    }
</script>

</html>