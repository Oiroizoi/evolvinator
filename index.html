<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
    <meta charset="utf-8">
    <title>Evolvinator</title>

    <link rel="preload" href="fonts/PfefferMediaeval.otf" as="font" type="font/otf" crossorigin>
    <link rel="preload" href="fonts/PfefferSimpelgotisch.otf" as="font" type="font/otf" crossorigin>
    <link rel="preload" href="fonts/RusticCapitals.ttf" as="font" type="font/ttf" crossorigin>
    <link rel="preload" href="fonts/Stoix.ttf" as="font" type="font/ttf" crossorigin>
    <link rel="preload" href="fonts/P39.ttf" as="font" type="font/ttf" crossorigin>
    <link rel="preload" href="fonts/0800_theophanes.otf" as="font" type="font/otf" crossorigin>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400..900&family=EB+Garamond:ital,wght@0,400..800;1,400..800&family=Noto+Sans+Siddham&family=Noto+Nastaliq+Urdu:wght@400..700"
        rel="stylesheet">

    <link rel="icon" href="favicon.png">

    <style>
        @font-face {
            font-family: "Pfeffer Mediæval";
            src: url("fonts/PfefferMediaeval.otf") format("opentype");
            unicode-range: U+0100-02BA, U+02BD-02C5, U+02C7-02CC, U+02CE-02D7, U+02DD-02FF, U+0304, U+0308, U+0329, U+1D00-1DBF, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF;
        }

        @font-face {
            font-family: "Pfeffer Mediæval";
            src: url("fonts/PfefferMediaeval.otf") format("opentype");
            unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
        }

        @font-face {
            font-family: "Pfeffer Simpelgotisch";
            src: url("fonts/PfefferSimpelgotisch.otf") format("opentype");
        }

        @font-face {
            font-family: "Rustic Capitals";
            src: url("fonts/RusticCapitals.ttf") format("truetype");
        }

        @font-face {
            font-family: "Stoix";
            src: url("fonts/Stoix.ttf") format("truetype");
            text-transform: uppercase;
        }

        @font-face {
            font-family: "P39";
            src: url("fonts/P39.ttf") format("truetype");
        }

        @font-face {
            font-family: "0800_theophanes";
            src: url("fonts/0800_theophanes.otf") format("opentype");
        }

        body {
            font: 16px "Segoe UI", sans-serif;
            line-height: 150%;
        }

        form {
            line-height: 200%;
        }

        #word {
            width: 175px;
        }

        label {
            display: inline-block;
        }

        input[type=button] {
            margin-left: 4px;
        }

        #inputNote {
            font-size: 14px;
            line-height: 200%;
            margin-top: -5px;
        }

        #table {
            margin-top: 20px;
            text-align: center;
            border-spacing: 0;
        }

        th {
            position: relative;
            padding: 5px 0;
            background-color: lightgray;
            border-color: black;
            cursor: pointer;
        }

        #headerArrow {
            position: absolute;
            top: 0;
            right: 0;
            height: 100%;
            aspect-ratio: 1;
            padding: 5px 0;
        }

        td {
            padding: 15px 12px 0 12px;
        }

        #outcomes:not(.expanded) .hidden td {
            display: none;
        }

        .spelling {
            font-style: italic;
        }

        #outcomes:not(.modernTypography) {
            #Lat .spelling {
                font-family: "Cinzel";
                font-style: normal;
            }

            #LL .spelling {
                font-family: "Rustic Capitals";
                font-size: 14px;
                transform: translateY(2px);
                font-style: normal;
            }

            #OE .spelling {
                font-family: "Pfeffer Mediæval";
                font-feature-settings: "ss02";
                font-size: 18px;
                font-style: normal;
            }

            #EME .spelling,
            #OSp .spelling,
            #EOF .spelling,
            #LOF .spelling {
                font-family: "Pfeffer Mediæval";
                font-feature-settings: "hist";
                font-size: 18px;
                font-style: normal;
            }

            #LME .spelling,
            #OGP .spelling {
                font-family: "Pfeffer Simpelgotisch";
                font-feature-settings: "hist";
                font-size: 18px;
                font-style: normal;
            }

            #EModE .spelling,
            #EModSp .spelling,
            #MF .spelling {
                font-family: "EB Garamond";
                font-size: 18px;
                font-style: normal;
            }

            #AttGr .spelling {
                font-family: "Stoix";
                font-size: 18px;
                text-transform: uppercase;
                font-style: normal;
            }

            #KoiGr .spelling {
                font-family: "P39";
                font-size: 14px;
                font-style: normal;
            }

            #ByzGr .spelling {
                font-family: "0800_theophanes";
                font-size: 20px;
                font-style: normal;
            }
        }

        .from_San .spelling {
            font-style: normal;
        }

        #Apa .spelling {
            font-family: "Noto Sans Siddham";
            transform: translateY(5px);
            font-style: normal;
        }

        .to_ModUr #OH .spelling,
        #ModUr .spelling {
            font-family: "Noto Nastaliq Urdu";
            font-style: normal;
        }

        .nonHist {
            font-feature-settings: initial !important;
        }

        #checkboxes {
            margin-top: 30px;
            font-size: 13px;
        }

        input[type="checkbox"] {
            vertical-align: text-top;
        }

        #checkboxes label {
            margin-right: 10px;
        }

        #githubLink {
            position: absolute;
            top: 15px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 40px;
            font-size: 30px;
            text-align: center;
            line-height: 40px;
            font-weight: 500;
            font-style: italic;
            background-color: #999;
            color: white;
        }

        #githubLink:hover {
            background-color: #b4f;
        }
    </style>
</head>

<body>
    <form autocomplete="off">
        <select name="from" id="from">
            <option value="AttGr">Ancient Greek</option>
            <option value="Lat">Classical Latin</option>
            <option value="San">Classical Sanskrit</option>
            <option value="OE" selected>Old English</option>
        </select>
        →
        <select name="to" id="to"></select>
        <br>

        <label for="word" id="wordLabel">Word:</label>
        <input type="text" name="word" id="word">
        <span id="buttons"></span>
        <br>

        <div id="inputNote"></div>

        <label for="stress" id="stressLabel">Stressed syllable:</label>
        <select name="stress" id="stress" style="margin-right: 8px;">
            <option>1</option>
        </select>

        <label for="pos" id="posLabel">Part of speech:</label>
        <select name="pos" id="pos"></select>
        <br>

        <input type="submit">
    </form>

    <div id="outcomes">
        <table id="table">
            <tr id="header"></tr>
        </table>
        <div id="checkboxes"></div>
    </div>

    <a href="https://github.com/Oiroizoi/evolvinator" target="_blank">
        <div id="githubLink">i</div>
    </a>
</body>

<script src="langs/germanic.js"></script>
<script src="langs/romance.js"></script>
<script src="langs/greek.js"></script>
<script src="langs/indo-iranian.js"></script>
<script>
    let params = new URLSearchParams(window.location.search);
    let wordArg = params.get("word");
    let from = params.get("from") || "OE";
    let to = params.get("to") || "ModE";
    let stressArg = +params.get("stress") || 1;
    let word;
    let modernTypography = false;
    let partOfSpeech = params.get("pos");

    let outcomes = {};

    function init() {
        if (wordArg) {
            wordArg = wordArg.trim().toLowerCase().normalize("NFC");

            //Normalize spelling
            switch (from) {
                case "AttGr":
                    wordArg = wordArg.normalize("NFD");
                    wordArg = wordArg.replaceAll("\u0306", "") //Breve
                        .replaceAll("\u0313", "") //Smooth breathing
                        .replaceAll("\u0342", "\u0302") //Replace Greek circumflex with Latin form
                        .replaceAll("\u0300", "\u0301") //Replace grave accent with accute
                        .replaceAll(/([\u0301\u0302])\u0345/g, "\u0345$1") //Switch order of accents and iota subscript
                        .replaceAll(/\u0345/g, "\u0304\u0345") //Lengthen vowels with iota subscript
                        .replaceAll("\u0345", "i"); //Iota subscript
                    //Rough breathing
                    wordArg = wordArg.replaceAll("ῥ", "rh")
                        .replaceAll("ἁ", "ha")
                        .replaceAll("ᾱ̔", "hā")
                        .replaceAll("ἑ", "he")
                        .replaceAll("ἡ", "hē")
                        .replaceAll("ὁ", "ho")
                        .replaceAll("ὡ", "hō");
                    if (wordArg.includes("\u0314"))
                        wordArg = "h" + wordArg;
                    wordArg = wordArg.replaceAll("\u0314", "");
                    //Convert Greek input to Latin script
                    wordArg = wordArg.replaceAll("α", "a")
                        .replaceAll("β", "b")
                        .replaceAll("γ", "g")
                        .replaceAll("δ", "d")
                        .replaceAll("ε", "e")
                        .replaceAll("ζ", "z")
                        .replaceAll("η", "ē")
                        .replaceAll("θ", "th")
                        .replaceAll("ι", "i")
                        .replaceAll("κ", "k")
                        .replaceAll("λ", "l")
                        .replaceAll("μ", "m")
                        .replaceAll("ν", "n")
                        .replaceAll("ξ", "x")
                        .replaceAll("ο", "o")
                        .replaceAll("π", "p")
                        .replaceAll("ρ", "r")
                        .replaceAll("σ", "s")
                        .replaceAll("ς", "s")
                        .replaceAll("τ", "t")
                        .replaceAll("υ", "y")
                        .replaceAll("φ", "ph")
                        .replaceAll("χ", "ch")
                        .replaceAll("ψ", "ps")
                        .replaceAll("ω", "ō");
                    wordArg = wordArg.replaceAll("c", "k")
                        //Dieresis comes before accents
                        .replaceAll(/\u0301\u0308/g, "\u0308\u0301")
                        .replaceAll(/\u0302\u0308/g, "\u0308\u0302")
                        //Other spelling changes
                        .replaceAll("kh", "ch")
                        .replaceAll("u", "y")
                        .replaceAll("\u0304\u0304", "\u0304")
                        .replaceAll(/(?<=(a|ā|e|ē|o))y(?![\u0308\u0304])/g, "u")
                        .replaceAll(/g(?=[gkcx])/g, "n")
                        .replaceAll(/rr(?!h)/g, "rrh")
                        .replaceAll(/chch/g, "kch")
                        .replaceAll(/phph/g, "pph")
                        .replaceAll(/thth/g, "tth")
                        .replaceAll(/rhrh/g, "rrh")
                        //Remove redundant macron before circumflex
                        .replaceAll(/\u0304(?=\u0308?\u0302)/g, "")
                        //Add dieresis over "i" and "y" in certain cases
                        .replaceAll(/(?<=[\u0301\u0302])i(?![\u0308\u0304])/g, "ï")
                        .replaceAll(/(?<=[aeoy][\u0304\u0301\u0302\u0308]*)ī(?!\u0308)/g, "ī̈")
                        .replaceAll(/(?<=[aeo][\u0304\u0301\u0302\u0308]*)y(?![\u0308\u0304])/g, "ÿ")
                        .replaceAll(/(?<=[aeo][\u0304\u0301\u0302\u0308]*)ȳ(?!\u0308)/g, "ȳ̈")
                        //Remove dieresis over other vowels
                        .replaceAll(/(?<=(a|ā|e|ē|o|ō))\u0308/g, "");
                    wordArg = wordArg.replaceAll(/.\u0304/g, match => match.normalize("NFC"));
                    break;
                case "Lat":
                    wordArg = wordArg.replaceAll("k", "c").replaceAll("j", "i").replace(/^w/, "gu");
                    wordArg = wordArg.replaceAll(/(?<=[eouyāēīōūȳ])u(?=[aeiouyāēīōūȳ])/g, "v");
                    break;
                case "San":
                    wordArg = wordArg.replaceAll("ē", "e")
                        .replaceAll("ō", "o")
                        .replaceAll("r̥", "ṛ")
                        .replaceAll("l̥", "ḷ")
                        .replaceAll("ṁ", "ṃ")
                        .replaceAll(/(?<=j)n/g, "ñ");
                    wordArg = wordArg.normalize("NFD");
                    //Remove all accents
                    wordArg = wordArg.replaceAll(/(?<!s)\u0301/g, "")
                        .replaceAll("\u0300", "")
                        .replaceAll("\u0951", "")
                        .replaceAll("\u0952", "");
                    //Convert Devanagari input to Latin script
                    wordArg = wordArg.replaceAll("अ", "a")
                        .replaceAll(/आ|\u093E/g, "ā")
                        .replaceAll(/इ|\u093F/g, "i")
                        .replaceAll(/ई|\u0940/g, "ī")
                        .replaceAll(/उ|\u0941/g, "u")
                        .replaceAll(/ऊ|\u0942/g, "ū")
                        .replaceAll(/ऋ|\u0943/g, "ṛ")
                        .replaceAll(/ॠ|\u0944/g, "ṝ")
                        .replaceAll(/ए|\u0947/g, "e")
                        .replaceAll(/ऐ|\u0948/g, "ai")
                        .replaceAll(/ओ|\u094B/g, "o")
                        .replaceAll(/औ|\u094C/g, "au")
                        .replaceAll(/ऌ|\u0962/g, "ḷ")
                        .replaceAll(/\u0902/g, "ṃ")
                        .replaceAll(/\u0903/g, "ḥ");
                    let consMap = {
                        "क": "k",
                        "ख": "kh",
                        "ग": "g",
                        "घ": "gh",
                        "ङ": "ṅ",
                        "च": "c",
                        "छ": "ch",
                        "ज": "j",
                        "झ": "jh",
                        "ञ": "ñ",
                        "ट": "ṭ",
                        "ठ": "ṭh",
                        "ड": "ḍ",
                        "ढ": "ḍh",
                        "ण": "ṇ",
                        "त": "t",
                        "थ": "th",
                        "द": "d",
                        "ध": "dh",
                        "न": "n",
                        "प": "p",
                        "फ": "ph",
                        "ब": "b",
                        "भ": "bh",
                        "म": "m",
                        "य": "y",
                        "र": "r",
                        "ल": "l",
                        "व": "v",
                        "श": "ś",
                        "ष": "ṣ",
                        "स": "s",
                        "ह": "h",
                    };
                    for (let cons in consMap) {
                        let lat = consMap[cons];
                        let noInherent = new RegExp(cons + "(?!(a|e|i|o|u|ṛ|ḷ|\u094D))", "g");
                        wordArg = wordArg.replaceAll(noInherent, lat + "a").replaceAll(cons, lat);
                    }
                    wordArg = wordArg.replaceAll("\u094D", "");
                    wordArg = wordArg.normalize("NFC");
                    break;
                case "OE":
                    wordArg = wordArg.replaceAll("ð", "þ").replaceAll("ƿ", "w").replaceAll("k", "c"); //Alternative spellings
                    wordArg = wordArg.replaceAll("io", "eo").replaceAll("īo", "ēo").replaceAll("oe", "e").replaceAll("ōe", "ē").replaceAll("œ̄", "ē").replaceAll("œ", "e"); //Dialectal vowels
                    break;
            }

            params.set("word", wordArg);
            window.history.replaceState({}, "", "?" + params);

            if (!document.getElementById("word").value)
                document.getElementById("word").value = wordArg;
        }

        document.getElementById("word").oninput();

        let name;
        let descendants;
        let defaultId;
        switch (from) {
            case "AttGr":
                name = "Anceint Greek";
                descendants = {ModGr: "Modern Greek"};
                defaultId = "ModGr";
                break;
            case "Lat":
                name = "Classical Latin";
                descendants = {ModF: "Modern French", ModIt: "Modern Italian", ModPort: "Modern Portuguese", ModSp: "Modern Spanish"};
                defaultId = "ModSp";
                break;
            case "San":
                name = "Classical Sanskrit";
                descendants = {ModH: "Modern Hindi", ModUr: "Modern Urdu"};
                defaultId = "ModH";
                break;
            case "OE":
                name = "Old English";
                descendants = {ModE: "Modern English", ModSc: "Modern Scots"};
                defaultId = "ModE";
                break;
        }

        document.getElementById("to").innerHTML = "";
        for (let id in descendants) {
            let option = document.createElement("option");
            option.value = id;
            option.innerHTML = descendants[id];
            document.getElementById("to").append(option);
        }
        if (!descendants[to])
            to = defaultId;

        document.getElementById("from").value = from;
        document.getElementById("to").value = to;

        document.getElementById("word").placeholder = `Enter ${name} word`;

        let specialChars;
        switch (from) {
            case "AttGr":
                specialChars = ["ā", "ē", "ī", "ō", "ȳ", "´", "^", "¨"];
                break;
            case "Lat":
                specialChars = ["ā", "ē", "ī", "ō", "ū", "ȳ"];
                break;
            case "San":
                specialChars = ["ḍ", "ḥ", "ṃ", "ṇ", "ñ", "ṅ", "ṣ", "ś", "ṭ", "ḷ", "ṛ", "ā", "ī", "ū", "ṝ"];
                break;
            case "OE":
                specialChars = ["ċ", "ġ", "þ", "æ", "ā", "ē", "ī", "ō", "ū", "ȳ", "ǣ"];
                break;
        }
        document.getElementById("buttons").innerHTML = "";
        specialChars.forEach(char => {
            let inputChar;
            switch (char) {
                case "´":
                    inputChar = "\u0301";
                    break;
                case "^":
                    inputChar = "\u0302";
                    break;
                case "¨":
                    inputChar = "\u0308";
                    break;
                default:
                    inputChar = char;
            }

            let button = document.createElement("input");
            button.value = char;
            button.type = "button";
            button.onclick = () => {
                let wordInput = document.getElementById("word");
                wordInput.setRangeText(inputChar, wordInput.selectionStart, wordInput.selectionEnd, "end");
                wordInput.oninput();
                wordInput.focus();
            };
            document.getElementById("buttons").append(button);
        });

        if (from == "AttGr") {
            document.getElementById("inputNote").innerHTML = "Note: Latin- and Greek-script inputs are both accepted.";
            document.getElementById("inputNote").style.display = "";
        } else {
            document.getElementById("inputNote").innerHTML = "";
            document.getElementById("inputNote").style.display = "none";
        }

        if (from == "OE") {
            document.getElementById("stressLabel").style.display = "";
            document.getElementById("stress").style.display = "";
            document.getElementById("stress").value = stressArg;
        } else {
            document.getElementById("stressLabel").style.display = "none";
            document.getElementById("stress").style.display = "none";
            document.getElementById("stress").value = "";
        }

        switch (from) {
            case "AttGr":
                document.getElementById("pos").innerHTML = `
                    <option value="noun" selected>Noun</option>
                    <option value="verb">Verb</option>
                    <option value="other">Other</option>
            `;
                break;
            case "Lat":
                document.getElementById("pos").innerHTML = `
                    <option value="noun" selected>Noun</option>
                    <option value="inf">Infinitive verb</option>
                    <option value="conjVerb">Conjugated verb</option>
                    <option value="other">Other</option>
            `;
                break;
            case "San":
                document.getElementById("pos").innerHTML = `
                    <option value="noun" selected>Noun/adjective</option>
                    <option value="other">Other</option>
            `;
                break;
            case "OE":
                document.getElementById("pos").innerHTML = `
                    <option value="noun" selected>Noun</option>
                    <option value="inf">Infinitive verb</option>
                    <option value="conjVerb">Conjugated verb</option>
                    <option value="pastPtcp">Past participle</option>
                    <option value="other">Other</option>
            `;
                break;
        }

        if (Array.from(document.getElementById("pos").options).some(option => option.value == partOfSpeech))
            document.getElementById("pos").value = partOfSpeech;

        document.getElementById("outcomes").style.display = "none";

        document.getElementById("table").classList.add("from_" + from);
        document.getElementById("table").classList.add("to_" + to);

        document.getElementById("header").onclick = () => {
            document.getElementById("outcomes").classList.toggle("expanded");
            if (document.getElementById("headerArrow").innerHTML == "▲")
                document.getElementById("headerArrow").innerHTML = "▼";
            else
                document.getElementById("headerArrow").innerHTML = "▲";
        };

        if (!document.getElementById("word").value)
            document.getElementById("word").focus();
    }

    document.getElementById("from").onchange = () => {
        from = document.getElementById("from").value;
        if (from == (params.get("from") || "OE"))
            partOfSpeech = params.get("pos");
        else
            partOfSpeech = "";
        init();
    };

    function tableSetup() {
        document.getElementById("header").innerHTML = `<th colspan="4"> Expected outcomes: <div id="headerArrow">▼</div> </th>`;

        document.getElementById("checkboxes").innerHTML = `
            <label><input type="checkbox" id="expandChk">Automatically expand table</label>
            <label><input type="checkbox" id="modernChk">Use modern typography</label>
        `;

        document.getElementById("expandChk").onclick = function () {
            localStorage.setItem("ev-autoExpand", this.checked);
            if (this.checked && document.getElementById("headerArrow").innerHTML == "▼")
                document.getElementById("header").click();
        };

        document.getElementById("modernChk").onclick = function () {
            localStorage.setItem("ev-modernTypography", this.checked);
            document.getElementById("outcomes").classList.toggle("modernTypography");
            modernTypography = this.checked;
            getOutcomes();
        };

        if (localStorage.getItem("ev-autoExpand") == "true") {
            document.getElementById("expandChk").checked = true;
            document.getElementById("header").click();
        }

        if (localStorage.getItem("ev-modernTypography") == "true") {
            document.getElementById("modernChk").checked = true;
            document.getElementById("outcomes").classList.toggle("modernTypography");
            modernTypography = true;
        }
    }

    function addRow(id, name, date, spelling, word, hidden) {
        document.getElementById(id)?.remove();

        let row = document.createElement("tr");
        row.id = id;
        row.innerHTML = `<td>${name}</td> <td>${date ? "c. " + date : "—"}</td> <td class="spelling">${spelling || "—"}</td> <td>[${word}]</td>`;
        if (hidden)
            row.classList.add("hidden");
        document.getElementById("table").append(row);

        word.forEach(segment => segment[id + "Value"] = segment.value);
        outcomes[id] = word.duplicate();
    }

    function getOutcomes() {
        word = new Word();
        word.partOfSpeech = partOfSpeech;

        try {
            switch (from) {
                case "AttGr":
                    getIPA_AttGr();
                    AttGr_to_ModGr();
                    break;
                case "Lat":
                    getIPA_Lat();
                    Lat_to_LL();
                    switch (to) {
                        case "ModF":
                            LL_to_WR("french");
                            WR_to_EOF();
                            EOF_to_LOF();
                            LOF_to_MF();
                            MF_to_ModF();
                            break;
                        case "ModIt":
                            LL_to_ModIt("spanish");
                            break;
                        case "ModPort":
                            LL_to_WR("portuguese");
                            WR_to_IR();
                            IR_to_OGP();
                            OGP_to_ModPort();
                            ModPort_to_Port();
                            ModPort_to_Br();
                            break;
                        case "ModSp":
                            LL_to_WR("spanish");
                            WR_to_IR();
                            IR_to_OSp();
                            OSp_to_ModSp();
                            break;
                    }
                    break;
                case "San":
                    getIPA_San();
                    San_to_EPr();
                    EPr_to_Apa();
                    Apa_to_OH((to == "ModUr") ? "urdu" : "hindi");
                    OH_to_ModH((to == "ModUr") ? "urdu" : "hindi");
                    break;
                case "OE":
                    getIPA_OE();
                    switch (to) {
                        case "ModE":
                            OE_to_EME();
                            EME_to_LME();
                            LME_to_EModE();
                            EModE_to_ModE();
                            ModE_to_UK();
                            ModE_to_US();
                            UK_to_AU();
                            break;
                        case "ModSc":
                            OE_to_EME("northumbrian");
                            EME_to_LME("scots");
                            LME_to_EModE("scots");
                            EModE_to_ModE("scots");
                            ModE_to_ModSc();
                            break;
                    }
                    break;
            }

            document.getElementById("outcomes").style.display = "block";
        } catch (err) {
            console.error(err);
            alert((typeof err == "string") ? err : "Error: invalid word");
        }
    }

    document.getElementById("wordLabel").onclick = () => document.getElementById("word").select();

    document.getElementById("word").onmousedown = function () {
        if (this == document.activeElement)
            this.onclick = null;
        else {
            this.onclick = () => {
                if (!window.getSelection().toString())
                    this.select();
            };
        }
    };
    document.getElementById("word").ontouchstart = document.getElementById("word").onmousedown;

    document.getElementById("word").oninput = function () {
        if (from == "OE") {
            let vowels = ["a", "ā", "e", "ē", "i", "ī", "o", "ō", "u", "ū", "y", "ȳ", "æ", "ǣ",
                "ea", "ēa", "eo", "ēo", "ie", "īe", "io", "īo", "oe", "ōe", "œ", "œ̄"];
            let numVowels = 0;
            for (let i = 0; i < this.value.length; i++) {
                if (vowels.includes(this.value[i] + this.value[i + 1])) {
                    numVowels++;
                    i++;
                }
                else if (vowels.includes(this.value[i]))
                    numVowels++;
            }
            let stressValue = document.getElementById("stress").value;
            document.getElementById("stress").innerHTML = "";
            for (let i = 0; i < Math.max(numVowels, 1); i++) {
                let option = document.createElement("option");
                option.innerHTML = i + 1;
                if (i == stressValue - 1)
                    option.selected = true;
                document.getElementById("stress").append(option);
            }
        }
    };

    class Word extends Array {
        constructor() {
            super();

            this.atIdx = idx => this.at(idx) || new Segment("", this);

            this.insert = (value, i) => this.splice(i, 0, new Segment(value, this));

            function segmentMatch(segment, chkValues) {
                chkValues = chkValues.split("/");
                let valueIncluded = false;
                if (chkValues.includes(segment.value))
                    valueIncluded = true;
                if (chkValues.includes("C") && segment.type == "consonant")
                    valueIncluded = true;
                if (chkValues.includes("V") && segment.type == "vowel")
                    valueIncluded = true;
                if (chkValues.includes("#") && !segment.value)
                    valueIncluded = true;
                return valueIncluded;
            }

            this.replace = (original, replacement, context = "_") => {
                word.forEach(segment => {
                    if (segment.selfMatch(original) && segment.ctxMatch(context))
                        segment.value = replacement;
                });
            };

            this.remove = (original, context = "_") => {
                for (let i = 0; i < this.length; i++) {
                    let segment = this.atIdx(i);
                    if (segment.selfMatch(original) && segment.ctxMatch(context)) {
                        segment.remove();
                        i--;
                    }
                }
            };

            this.replaceSeq = (str, replacement) => {
                let sequence = str.split(",");
                for (let i = 0; i < this.length; i++) {
                    let segment = this[i];
                    if (sequence.every((seqSegment, j) => segment.relIdx(j).value == seqSegment)) {
                        let newSegments = replacement.split(",").map(segment => new Segment(segment, this));
                        newSegments.forEach((newSegment, j) => {
                            if (newSegments.length > j) {
                                for (let key in segment.relIdx(j))
                                    if (!newSegment[key])
                                        newSegment[key] = segment.relIdx(j)[key];
                                newSegment.stressed = segment.relIdx(j).stressed;
                            }
                        });
                        this.splice(segment.idx, sequence.length, ...newSegments);
                    }
                }
            };

            this.duplicate = () => {
                let newWord = new Word();
                this.forEach((segment, i) => {
                    let newSegment = new Segment(segment.value, newWord);
                    for (let key in segment)
                        if (!newSegment[key])
                            newSegment[key] = segment[key];
                    newSegment.stressed = segment.stressed;
                    newSegment.type = segment.type;
                    newWord.push(newSegment);
                });
                for (let key in this)
                    if (!newWord[key])
                        newWord[key] = this[key];
                return newWord;
            };

            this.toString = () => this.join("");
        };

        get vowels() {
            return this.filter(segment => segment.type == "vowel");
        }

        get stressedVowel() {
            return this.vowels.find(vowel => vowel.stressed);
        }
    }

    class Segment {
        constructor(value, word) {
            this.value = value;
            this.stressed = false;
            this.word = word;

            this.match = (...vals) => vals.includes(this.value);
            this.relIdx = diff => !this.value ? new Segment("", this.word) : (this.word[this.idx + diff] || new Segment("", this.word));
            this.nextVowel = () => this.word.slice(this.idx + 1).find(s => s.type == "vowel") || new Segment("", this.word);
            this.prevVowel = () => this.word.slice(0, this.idx).reverse().find(s => s.type == "vowel") || new Segment("", this.word);
            this.remove = () => this.word.splice(this.idx, 1);

            this.selfMatch = chk => {
                if (!chk)
                    return true;

                let chkArr = [];

                //Distribute the properties of a group to each value
                let groupProperties;
                for (let i = 0; i < chk.length; i++)
                    if (chk[i] == "{") {
                        let startIdx = chk.indexOf("}") + 1;
                        let endIdx = startIdx + chk.slice(startIdx).indexOf("/");
                        if (endIdx < startIdx)
                            endIdx = Infinity;
                        groupProperties = chk.slice(startIdx, endIdx);
                        chk = chk.slice(0, i) + chk.slice(i + 1);
                        i--;
                    } else if (chk[i] == "}") {
                        groupProperties = "";
                        chk = chk.slice(0, i) + chk.slice(i + 1);
                        i--;
                    } else if (chk[i] == "/" && groupProperties) {
                        chk = chk.slice(0, i) + groupProperties + chk.slice(i);
                        i += groupProperties.length;
                    }

                //Split chk at each slash that is not inside brackets
                let startIdx = 0;
                let bracketsDepth = 0;
                for (let i = 0; i < chk.length; i++)
                    if (chk[i] == "/" && !bracketsDepth) {
                        chkArr.push(chk.slice(startIdx, i));
                        startIdx = i + 1;
                    } else if (chk[i] == "[") {
                        bracketsDepth++;
                    } else if (chk[i] == "]") {
                        bracketsDepth--;
                    }
                chkArr.push(chk.slice(startIdx));

                for (let str of chkArr) {
                    let value;
                    let properties;

                    let boundary = str.indexOf("[");
                    if (boundary > -1) {
                        value = str.slice(0, boundary);
                        properties = str.slice(boundary);
                    } else {
                        value = str;
                    }

                    if (properties) {
                        properties = properties.slice(1, -1).split("][");
                        if (!properties.every(property => this.propMatch(property)))
                            continue;
                    }

                    if (value == this.value)
                        return true;
                    if (value == "")
                        return true;
                    if (value == "C" && this.type == "consonant")
                        return true;
                    if (value == "V" && this.type == "vowel")
                        return true;
                    if (value == "#" && !this.value)
                        return true;
                }

                return false;
            };

            this.propMatch = property => {
                let negate = property.includes("!");
                property = property.replace("!", "");

                let result;

                if (property.startsWith("=")) {
                    result = this.selfMatch(property.slice(1));
                } else if (property.includes("=")) {
                    let splitIdx = property.indexOf("=");
                    result = this[property.slice(0, splitIdx)] == property.slice(splitIdx + 1);
                } else {
                    result = this[property];
                }

                return negate ? !result : result;
            };

            this.ctxMatch = ctx => {
                ctx = ctx.split("_");
                let ctxBefore = ctx[0].split(",").reverse();
                let ctxAfter = ctx[1].split(",");

                if (!ctxBefore.every((chkValues, i) => this.relIdx(-1 - i).selfMatch(chkValues)))
                    return false;
                if (!ctxAfter.every((chkValues, i) => this.relIdx(1 + i).selfMatch(chkValues)))
                    return false;

                return true;
            };

            this.toString = () => {
                let str = "";
                for (let i in this.value) {
                    let char = this.value[i];
                    str += char;
                    if (this.nasalized && !char.match(/[\u0300-\u036fː̃]/))
                        str += "\u0303";
                    if (i == 0 && this.pitch)
                        switch (this.pitch) {
                            case "low":
                                str += "\u0300";
                                break;
                            case "high":
                                str += "\u0301";
                                break;
                            case "rising":
                                str += "\u030C";
                                break;
                            case "falling":
                                str += "\u0302";
                                break;
                        }
                }
                if (this.stressed && !this.relIdx(-1).stressed)
                    str = "ˈ" + str;
                return str;
            };

            if (
                this.value && [
                    "a", "æ", "ɛ", "e", "ɪ", "i", "ɶ", "œ", "ø", "ʏ", "y",
                    "ɐ", "ɜ", "ə", "ɘ", "ɨ", "ɞ", "ɵ", "ʉ",
                    "ɑ", "ʌ", "ɤ", "ɯ", "ɒ", "ɔ", "o", "ʊ", "u"
                ].includes(this.value[0])
            )
                this.type = "vowel";
            else if (this.value)
                this.type = "consonant";
        }

        get idx() {
            return this.word.indexOf(this);
        }

        get negIdx() {
            return this.idx - this.word.length;
        }
    }

    init();
    if (wordArg) {
        tableSetup();
        getOutcomes();
    }
</script>

</html>